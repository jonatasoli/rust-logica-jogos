
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://rustlogicajogos.jonatasoliveira.dev/1_1_jogo_floresta_misteriosa/">
      
      
        <link rel="prev" href="../1_0_introducao/">
      
      
        <link rel="next" href="../1_2_jogo_da_adivinhacao/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.1.21">
    
    
      
        <title>Floresta Misteriosa - Rust da Lógica aos Jogos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#floresta-misteriosa" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Rust da Lógica aos Jogos" class="md-header__button md-logo" aria-label="Rust da Lógica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Rust da Lógica aos Jogos
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Floresta Misteriosa
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema claro"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Mudar para o tema claro" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema escuro"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Mudar para o tema escuro" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Rust da Lógica aos Jogos" class="md-nav__button md-logo" aria-label="Rust da Lógica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Rust da Lógica aos Jogos
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Bem vindo ao curso Rust lógica com jogos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_0_introducao/" class="md-nav__link">
        Introdução
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Floresta Misteriosa
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Floresta Misteriosa
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#regras" class="md-nav__link">
    Regras
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-o-projeto" class="md-nav__link">
    Criando o projeto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#falando-de-tipagem" class="md-nav__link">
    Falando de tipagem
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variaveis" class="md-nav__link">
    Variaveis
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#controle-de-fluxo-condicional-com-if" class="md-nav__link">
    Controle de fluxo condicional com if
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introducao-a-variaveis-e-imutabilidade" class="md-nav__link">
    Introdução a váriaveis e imutabilidade
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variaveis-e-mutabilidade" class="md-nav__link">
    Variáveis e mutabilidade
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recebendo-parametros-do-jogador-e-usando-a-condicional-match" class="md-nav__link">
    Recebendo parametros do jogador e usando a condicional match
  </a>
  
    <nav class="md-nav" aria-label="Recebendo parametros do jogador e usando a condicional match">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#alguns-ajustes" class="md-nav__link">
    Alguns ajustes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exercicios-sugeridos" class="md-nav__link">
    Exercicíos sugeridos
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_2_jogo_da_adivinhacao/" class="md-nav__link">
        Jogo da adivinhação
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_3_jogo_blackjack/" class="md-nav__link">
        Jogo Blackjack
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../INDICE/" class="md-nav__link">
        Summary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Jogos/" class="md-nav__link">
        Jogos
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#regras" class="md-nav__link">
    Regras
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-o-projeto" class="md-nav__link">
    Criando o projeto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#falando-de-tipagem" class="md-nav__link">
    Falando de tipagem
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variaveis" class="md-nav__link">
    Variaveis
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#controle-de-fluxo-condicional-com-if" class="md-nav__link">
    Controle de fluxo condicional com if
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introducao-a-variaveis-e-imutabilidade" class="md-nav__link">
    Introdução a váriaveis e imutabilidade
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variaveis-e-mutabilidade" class="md-nav__link">
    Variáveis e mutabilidade
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recebendo-parametros-do-jogador-e-usando-a-condicional-match" class="md-nav__link">
    Recebendo parametros do jogador e usando a condicional match
  </a>
  
    <nav class="md-nav" aria-label="Recebendo parametros do jogador e usando a condicional match">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#alguns-ajustes" class="md-nav__link">
    Alguns ajustes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exercicios-sugeridos" class="md-nav__link">
    Exercicíos sugeridos
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="floresta-misteriosa">Floresta Misteriosa</h1>
<p>Para iniciar vamos dar um raio-x sobre nosso primeiro jogo, em a floresta misteriosa o jogador assume um papel de um aventureiro corajoso  que se aventura por uma floresta misteriosa. A cada escolha que o jogador faz vão influenciar a sua jornada, dependendo da sua decisão você vai ganhar ou perder pontos se você alcançar 100 pontos você vence o jogo.</p>
<h2 id="regras">Regras</h2>
<p>Nosso jogo apresentará um menu ao nosso jogador com as opções que ele pode escolher. Como nosso escopo é pequeno vamos limitar em 4 escolhas.</p>
<ul>
<li>Ele pode beber agua no rio onde o jogador vai ganhar 10 pontos.</li>
<li>Ele pode passar pela ponte frágil onde ele vai perder 20 pontos.</li>
<li>Ele pode querer entrar na caverna escura ele vai ganhar 50 pontos.</li>
<li>Ele pode passar pelo caminho iluminado onde vai perder 20 pontos.</li>
</ul>
<p>Essas escolhas vão aparecendo toda vez que o jogador faz uma escolha até ele ganhar ou perder o jogo. Caso ele consiga 100 pontos o jogador ganha e se o jogador chegar a 0 ele perde.</p>
<h2 id="criando-o-projeto">Criando o projeto</h2>
<p>Bom primeiro vamos criar um diretório onde vamos armazenar nossos projetos do curso, minha sugestão é criar um diretório chamado projects. Então vamos abrir um terminal primeiro vamos usar o comando <code>cd</code> para ir até o diretório <code>Home</code> do seu computador e depois vamos usar o comando <code>mkdir</code> para criar um diretório.</p>
<pre><code class="language-bash">cd
mkdir projects
</code></pre>
<p>Caso queria se aprofundar sobre os comandos via terminal minha sugestão é dar uma conferida no <a href="https://www.guiafoca.org/">guia focalinux</a> ele vai lhe ajudar a ter um entendimento melhor do funcionando dos comandos posix mas, vou explicando cada comando no terminal que vamos usar ao decorrer do curso.</p>
<p>Bom agora vamos acessar o diretório que criamos.</p>
<pre><code class="language-bash">cd projects
</code></pre>
<p>Agora que acessamos o diretório que vamos trabalho, o próximo passo é criarmos nosso projeto em rust, para criar um projeto em rust vamos usar o comando <code>cargo new</code> e o nome do nosso projeto é chamado <code>mysterious_forest</code>. Assim ele vai criar um diretório chamado <code>mysterious_forest</code> para confirmar-mos se a pasta foi criada vamos usar o comando <code>ls -la</code> onde o <code>-la</code> é um parametro apenas para listarmos também os arquivos ocultos.</p>
<pre><code class="language-bash">cargo new mysterious_forest
ls -la
</code></pre>
<p>Agora vamos acessar o direorio que criamos no qual podemos acessa-lo através do comando <code>cd mysterious_forest</code>.</p>
<pre><code class="language-bash">cd mysterious_forest
</code></pre>
<p>Agora podemos usar novamente o comando <code>ls -la</code> para vermos o que o comando cargo criou no nosso projeto.</p>
<pre><code class="language-bash">.git
.gitignore
Cargo.toml
src
</code></pre>
<p>Uma observação os arquivos com o <code>.</code> na frente como o <code>.git</code> e o <code>.gitignore</code> são arquivos ocultos no linux.</p>
<p>Bom agora vou dar o comando <code>cargo run</code> para executar meu projeto.</p>
<p>Assim vamos ter a saída.</p>
<pre><code class="language-rust">➜ cargo run
   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running `target/debug/mysterious_forest`
Hello, world!
</code></pre>
<p>Uma coisa interessante de notar quando executamos um projeto rust é que na primeira linha:
<code>Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)</code>
Nós temos o nome do nosso executável, no caso <code>mysterious_forest</code> e a versão do nosso executável no caso <code>v0.1.0</code>.</p>
<p>Na segunda linha temos:
<code>Finished dev [unoptimized + debuginfo] target(s) in 0.12s</code>
Aqui temos a informação que nosso executável foi compilado em modo dev e o tempo de compilação no caso <code>0.12</code></p>
<p>Na terceira linha temos:
<code>Running target/debug/mysterious_forest</code>
Essa linha nos mostra onde fica nosso executável ele que vamos dar a para que as pessoas possam jogar nosso jogo.</p>
<p>Certo agora vamos entrar no projeto no arquivo no caminho <code>src/main.rs</code></p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Isso é um "Hello, world!" padrão de um projeto rust, então nesse caso não começamos com um "Hello, world!" no projeto pois ele já vem no momento da criação.</p>
<h2 id="falando-de-tipagem">Falando de tipagem</h2>
<p>A tipagem em programação se refere à maneira como as linguagens de programação tratam os tipos de dados, ou seja, como elas definem e gerenciam os diferentes tipos de valores que podem ser usados em um programa. Rust é uma linguagem de programação que utiliza um sistema de tipagem estática, o que significa que os tipos de dados são verificados em tempo de compilação, tornando o código mais seguro e eficiente.
Tipagem Estática</p>
<p>Em Rust, você precisa declarar explicitamente o tipo de dado que uma variável pode armazenar. Isso é feito durante a declaração da variável, permitindo que o compilador verifique se o valor atribuído à variável é compatível com o tipo declarado. Se houver uma incompatibilidade de tipos, o código não será compilado, o que ajuda a evitar erros em tempo de execução.
Tipos Primitivos em Rust</p>
<p>Rust possui uma série de tipos primitivos que podem ser usados para representar diferentes tipos de dados. Vamos dar uma olhada nos tipos primitivos mais comuns em Rust:
1. Integer Types (Tipos Inteiros)</p>
<p>Os tipos inteiros em Rust representam números inteiros sem parte fracionária. Aqui estão alguns dos tipos inteiros mais comuns, junto com sua faixa de valores:</p>
<div class="highlight"><pre><span></span><code>i8: Intervalo de -128 a 127.

i16: Intervalo de -32,768 a 32,767.

i32: Intervalo de -2,147,483,648 a 2,147,483,647.

i64: Intervalo de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807.

i128: Intervalo extremamente grande de números inteiros com sinal.
</code></pre></div>
<p>Por exemplo, você pode declarar uma variável inteira em Rust da seguinte forma:</p>
<div class="highlight"><pre><span></span><code>rust

let numero: i32 = 42;
</code></pre></div>
<p>Os tipos inteiros sem sinal, representados com u, têm os mesmos tamanhos que os tipos inteiros com sinal e representam apenas valores não negativos. Por exemplo, u8 varia de 0 a 255, u16 varia de 0 a 65,535 e assim por diante.
2. Floating-Point Types (Tipos de Ponto Flutuante)</p>
<p>Os tipos de ponto flutuante em Rust representam números com parte fracionária. Os tipos mais comuns são:</p>
<div class="highlight"><pre><span></span><code>f32: Representa números de ponto flutuante de precisão simples.

f64: Representa números de ponto flutuante de dupla precisão (mais precisos).
</code></pre></div>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

let pi: f64 = 3.14159;
</code></pre></div>
<ol>
<li>Boolean Type (Tipo Booleano)</li>
</ol>
<p>O tipo booleano em Rust é usado para representar valores verdadeiro (true) ou falso (false). É frequentemente usado em expressões condicionais e lógicas.</p>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

let esta_chovendo: bool = true;
</code></pre></div>
<ol>
<li>Character Type (Tipo de Caractere)</li>
</ol>
<p>Rust também possui um tipo de caractere chamado char, que representa um único caractere Unicode. Isso é útil para lidar com texto e caracteres especiais.</p>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

let letra: char = &#39;A&#39;;
</code></pre></div>
<ol>
<li>String Type (Tipo de Texto)</li>
</ol>
<p>Rust diferencia entre dois tipos relacionados: str e String.</p>
<div class="highlight"><pre><span></span><code>str: Representa uma sequência de caracteres imutável (não pode ser modificada após a criação) e é frequentemente usado com referências (&amp;str) para manipulação de texto eficiente.

String: Representa uma sequência de caracteres mutável (pode ser modificada) e é mais flexível, geralmente alocada na memória de forma dinâmica.
</code></pre></div>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

let texto_estatico: &amp;str = &quot;Isso é um texto imutável&quot;;
let mut texto_mutavel: String = String::from(&quot;Isso é um texto mutável&quot;);
</code></pre></div>
<p>Essa é uma explicação mais abrangente sobre a tipagem em Rust, os tipos primitivos mais comuns e a diferença entre str e String. À medida que você se familiariza mais com Rust, poderá explorar tipos compostos, structs, enums e outros recursos poderosos que a linguagem oferece para lidar com problemas específicos de programação.</p>
<h2 id="variaveis">Variaveis</h2>
<p>Bom para começar nosso jogo precisamos definir algumas estruturas de dados que vão armazenar a pontuação do nosso jogador e o qual escolha ele vai fazer em seguida, pra isso vamos precisar criar variáveis.</p>
<p>As variáveis em rust são declarados usando a palavra reservada <code>let</code> o nome da variável e o tipo dela além do seu valor de inicialização.
Uma váriavel em rust é diferente de outras linguagens pois ela é imutável ou seja quando inicializamos ela, a mesma não altera seu valor, há uma forma de informar explicitamente que queremos que a variável receba valores dinamicamente mas, vamos ver mais a frente.</p>
<p>Então agora dentro do nosso main vamos declarar a primeira variável do nosso projeto.</p>
<pre><code class="language-rust">fn main() {
    let pontuacao: i32 = 0;
}
 ```

Vamos da uma olhada mais de perto no nosso código:
`fn` é a palavra reservada para declarar uma função
`main` é o nome da nossa função e os parenteses `()` é a estrutura que usamos para declarar os parametros da nossa função que no caso não temos nenhum então ela está vazia.
Para simplificar um pouco as coisas parametros nada mais é que as variáveis que uma função vai receber quando ela for executada, mas não tema em um outor momento vamos falar mais de funções e parametros.
`{}` determina um bloco de código então o que estiver ali dentro vai ser o código que será executado pela nossa função main.
`let pontuacao: i32 = 0;` aqui declaramos nossa variável começando com a palavra reservada `let` depois o nome da variável que no caso é `pontuacao` o tipo dela que no nosso caso é um `i32` ai temos o `=` que o nosso simbulo de atribuição ou seja, que `pontuacao` vai receber um valor, na sequencia temos o valor que estamos inicializando que no caso é o valor `0` e finalmente temos o simbulo `;` que indica pro compilador que a linha de execução foi encerrada finalizando a instrução.

Com isso podemos criar nossa segunda variável:

```rust
fn main() {
    let pontuacao: i32 = 0;
    let escolha: i32 = 1;
}
</code></pre>
<p>Então criamos uma variavel escolha que também é uma <code>i32</code> só que agora colocamos como valor incial <code>1</code>.</p>
<p>Para dar sequência no nosso projeto vamos criar uma mensagem de boas-vindas, pra isso vamos usar uma macro no rust que nada mais é que uma sequência de instruções que vão rodar internamente quando ela for executada que no nosso caso é o <code>println!</code> o  <code>!</code> no final nos indica que ela é uma macro.</p>
<pre><code class="language-rust">fn main() {
    let pontuacao: i32 = 0;
    let escolha: i32 = 1;

    ==println!(&quot;Bem-vindo à floresta misteriosa&quot;)==
}

</code></pre>
<p>Um ponto importante pra se observar nós não usamos o simbolo <code>;</code> no final da nossa macro <code>println!</code> isso por que em rust dentro de um bloco de código a ultima linha não precisa ter esse simbolo pois ele interpreta essa última linha como o valor a se retornar da função no nosso caso porém estamos executando uma macro que vai imprimir valores na tela então ele basicamente não está retornando nada.
Você pode observar que dentro dos parenteses da nossa macro temos os simbolos de aspas <code>""</code> e dentro delas colocamos nosso texto com acentos. Como o rust usa o padrão unicode para caracteres podemos usar qualquer simbolo ou diagrama representado pela tabela unicode. Mas, no nosso código em si nós evitamos usar acentos e caracteres especiais.</p>
<p>Agora vamos imprimir na tela o valor da nossa escolha e a pontuação pra isso vamos usar novamente a macro <code>println!</code>.</p>
<pre><code class="language-rust">fn main() {
    let pontuacao: i32 = 0;
    let escolha: i32 = 1;

    println!(&quot;Bem-vindo à floresta misteriosa&quot;);
    ==
    println!(&quot;A sua escolha foi {}&quot;, escolha);
    println!(&quot;A sua pontuação foi {}&quot;, pontuacao)
    ==
}

</code></pre>
<p>Observe que só deixamos sem o <code>;</code> a ultima linha por isso no nosso primeiro <code>println!</code> agora tem a pontuação. Outra coisa é que nosso código está usando a macro de uma forma diferente.
Temos o simbolo das chaves <code>{}</code> dentro das aspas, isso indica que queremos imprimir o valor de uma variável que no nosso caso são as variáveis <code>escolha</code> e <code>pontuacao</code>. No caso se quisermos colocar mais variáveis dentro de uma string que é o caso do nosso <code>println!</code> podemos usar mais chaves que ele vai entender.</p>
<p>Agora podemos rodar novamente  o <code>cargo run</code> para ver o retorno da nossa função.</p>
<pre><code class="language-bash">➜ cargo run
   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running `target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
A sua escolha foi 1
A sua pontuação foi 0
</code></pre>
<p>Perfeito tudo funcionando!</p>
<h2 id="controle-de-fluxo-condicional-com-if">Controle de fluxo condicional com if</h2>
<p>Vamos da uma olhada agora em como dar escolhas para nosso jogador. Primeiro vamos colocar um <code>println!</code> pedindo a escolha e 4 opções númericas para ele escolher.</p>
<pre><code class="language-rust">\\ código
    println!(&quot;Bem-vindo à floresta misteriosa&quot;);

    println!(&quot;Por favor escolha uma opção:&quot;);
    println!(&quot;1 - Entrar na caverna escura&quot;);
    println!(&quot;2 - Seguir no caminho iluminado&quot;);
    println!(&quot;3 - Cruzar a ponte frágil&quot;);
    println!(&quot;4 - Descansar na beira do riacho&quot;);
\\código
</code></pre>
<p>Agora precisamos de um recurso que nos mostre que quando digitarmos no teclado a opção 1 ele faça a ação <code>Entrar na caverna escura</code> e assim com as demais opções e quando ele escolher a opção faça a soma ou a subtração dos pontos. Pra isso vamos usar o <code>if</code> ele é nosso primeiro condicional e com ele podemos fazer que com determinada escolha ele faça uma sequencia de ações no nosso caso se o jogador escolher a opção 1 precisa realizar a ação de somar 50 pontos na pontuação atual.</p>
<pre><code class="language-rust">\\código
    println!(&quot;4 - Descansar na beira do riacho&quot;);
    if escolha == 1 {
        pontuacao = pontuacao + 50;
    }
\\código
</code></pre>
<p>Vamos ter um erro mas, vamos ignora-lo por enquanto, agora precisamos colocar as outras condições então usamos a palavra reservada <code>if</code> e poderiamos ficar usando ela para as demais opções mas, há um problema, nosso código usando 4 <code>if's</code> nesse caso ele vai verificar todas 4 vezes em todos os casos. Então podemos usar um outro recurso que é o <em>senão se</em>  que basicamente vai verificar a primeira condição e se ela não for verdade e vai verificar a próxima condição e assim sucessivamente.<br />
O código ficaria assim:</p>
<pre><code class="language-rust">fn main() {
    let pontuacao: i32 = 0;
    let escolha: i32 = 1;

    println!(&quot;Bem-vindo à floresta misteriosa&quot;);

    println!(&quot;Por favor escolha uma opção:&quot;);
    println!(&quot;1 - Entrar na caverna escura&quot;);
    println!(&quot;2 - Seguir no caminho iluminado&quot;);
    println!(&quot;3 - Cruzar a ponte frágil&quot;);
    println!(&quot;4 - Descansar na beira do riacho&quot;);

==
    if escolha == 1 {
        pontuacao = pontuacao + 50;
    } else if escolha == 2 {
        pontuacao = pontuacao - 20;
    } else if escolha == 3 {
        pontuacao = pontuacao - 20;
    } else if escolha == 4 {
        pontuacao = pontuacao + 10;
    }
==

    println!(&quot;A sua escolha foi {}&quot;, escolha);
    println!(&quot;A sua pontuação foi {}&quot;, pontuacao)
}
</code></pre>
<p>Agora vamos rodar nosso código ele vai receber um erro igual o abaixo:</p>
<pre><code class="language-bash">error[E0384]: cannot assign twice to immutable variable `pontuacao`
  --&gt; src/main.rs:20:9
   |
2  |     let pontuacao: i32 = 0;
   |         ---------
   |         |
   |         first assignment to `pontuacao`
   |         help: consider making this binding mutable: `mut pontuacao`
...
20 |         pontuacao = pontuacao + 10;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable

</code></pre>
<p>Aqui ele está dizendo que não pode mudar uma variável imutável e é isso que vamos explorar a seguinte.</p>
<h2 id="introducao-a-variaveis-e-imutabilidade">Introdução a váriaveis e imutabilidade</h2>
<p>Se você está começando a aprender sobre programação, é importante entender o que são variáveis e constantes em Rust, uma linguagem de programação moderna e segura. Vamos explorar esses conceitos e suas implicações, incluindo exemplos de constantes.
Variáveis em Rust</p>
<p>Uma variável em Rust é uma forma de armazenar e manipular dados em um programa. É como uma caixa que você pode usar para guardar informações temporariamente. No entanto, Rust difere de muitas outras linguagens de programação em um aspecto fundamental: por padrão, as variáveis são imutáveis, o que significa que não podem ser alteradas após a primeira atribuição.</p>
<p>Por exemplo, considere o seguinte código:</p>
<div class="highlight"><pre><span></span><code>rust

let nome = &quot;Alice&quot;;
nome = &quot;Bob&quot;; // Isso geraria um erro de compilação!
</code></pre></div>
<p>Neste exemplo, a tentativa de mudar o valor de nome para "Bob" resultaria em um erro de compilação. Isso ocorre porque, por padrão, Rust preza pela segurança e evita que você modifique dados acidentalmente.
A Palavra Reservada mut</p>
<p>Mas e se você quiser que uma variável seja mutável, ou seja, que possa ser alterada? É aí que entra a palavra reservada mut. Quando você declara uma variável com a palavra-chave mut, você está indicando explicitamente que a variável pode ser modificada.</p>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

let mut contador = 0;
contador = contador + 1; // Isso é permitido, pois &#39;contador&#39; é mutável
</code></pre></div>
<p>Neste caso, contador é uma variável mutável, e você pode aumentar seu valor sem problemas.
Constantes em Rust</p>
<p>Além de variáveis, Rust também oferece o conceito de constantes. As constantes são valores imutáveis que são definidos em tempo de compilação. Elas são declaradas usando a palavra-chave const e sempre devem ter um tipo de dado específico.</p>
<p>Exemplo:</p>
<div class="highlight"><pre><span></span><code>rust

const PI: f64 = 3.14159;
</code></pre></div>
<p>Aqui, PI é uma constante que representa o valor de π (pi) com uma precisão de ponto flutuante de dupla precisão (f64). Essa constante não pode ser alterada após sua definição e é acessível em todo o escopo em que está definida.
Vantagens e Desvantagens da Imutabilidade por Padrão</p>
<p>A abordagem de imutabilidade por padrão em Rust oferece algumas vantagens importantes:
1. Segurança:</p>
<div class="highlight"><pre><span></span><code>Evita erros comuns relacionados à mutação de dados, como condições de corrida (race conditions) em programas concorrentes.

Facilita a previsibilidade do código, uma vez que você não precisa se preocupar com efeitos colaterais inesperados.
</code></pre></div>
<ol>
<li>
<p>Melhora a Legibilidade:</p>
<p>Torna o código mais fácil de entender, uma vez que você sabe que uma variável não será alterada em lugares inesperados.</p>
</li>
<li>
<p>Facilita a Concorrência:</p>
<p>Permite que Rust garanta a segurança na concorrência, pois a imutabilidade reduz o risco de acesso concorrente a dados mutáveis.</p>
</li>
</ol>
<p>No entanto, essa abordagem também pode ter desvantagens, como:
1. Mais Digitação:</p>
<div class="highlight"><pre><span></span><code>Pode ser necessário digitar mais código para criar variáveis mutáveis quando necessário.
</code></pre></div>
<ol>
<li>
<p>Curva de Aprendizado:</p>
<p>Pode levar algum tempo para se acostumar com a imutabilidade por padrão, especialmente se você está familiarizado com linguagens que não a adotam.</p>
</li>
</ol>
<p>Outras Linguagens com Características Semelhantes</p>
<p>Algumas outras linguagens de programação também adotam a imutabilidade por padrão ou oferecem suporte a variáveis imutáveis:</p>
<div class="highlight"><pre><span></span><code>Haskell

Elm

Clojure
</code></pre></div>
<p>Em resumo, variáveis e constantes em Rust têm a característica única de serem imutáveis por padrão, proporcionando segurança e legibilidade. A palavra-chave mut permite que você torne variáveis mutáveis quando necessário, mantendo o controle sobre a mutabilidade dos dados em seu código. Rust também suporta constantes, que são valores imutáveis definidos em tempo de compilação. Essa abordagem pode ser diferente de outras linguagens, mas traz benefícios significativos em termos de segurança e concorrência.</p>
<p>É importante reforçar que com isso você pode usar uma variável imutável durante a maior parte da execução e quando ela precisar ser alterada redeclarar ela como mutável mais a frente vamos falar do conceito de como funciona o gerenciamente de memória do rust e isso vai acabar ficando mais claro.</p>
<h2 id="variaveis-e-mutabilidade">Variáveis e mutabilidade</h2>
<p>Bom conforme vimos anteriormente nosso código estava dando erro pois o rust acusava que estavamos tentando mudar uma variável imutável. Isso acontece por que em rust todas as variáveis por padrão são imutáveis, então não podemos modifica-la depois inicializar ela.
Para isso vamos precisamos indicar pro rust que nossa variável é mutável usando a palavra reservada <code>mut</code> depois do <code>let</code>.</p>
<pre><code class="language-rust">fn main() {
    ==let mut pontuacao: i32 = 0;== 
    let escolha: i32 = 1;

    // código
}

</code></pre>
<p>Agora você pode ver que seu editor deve parar de dar algum aviso de erro. Vamos tentar rodar nosso código.</p>
<pre><code class="language-bash">mysterious_forest on  main [?] is 📦 v0.1.0 via 🦀 v1.73.0 on ☁️  (eu-west-2) took 4m4s
➜ cargo run
   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running `target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
Por favor escolha uma opção:
1 - Entrar na caverna escura
2 - Seguir no caminho iluminado
3 - Cruzar a ponte frágil
4 - Descansar na beira do riacho
A sua escolha foi 1
A sua pontuação foi 50

</code></pre>
<p>Certo agora nosso código foi executado com sucesso mostrando que nossa pontuação foi 50.</p>
<h2 id="recebendo-parametros-do-jogador-e-usando-a-condicional-match">Recebendo parametros do jogador e usando a condicional match</h2>
<p>Bom nosso jogo está nos devolvendo a pontuação da nossa escolha, mas nosso jogador ainda não consegue nos passar a opção que ele quer, então pra isso vamos precisar receber os dados do usuário isso quer dizer que precisamos pedir pro rust pedir o <em>input</em> do teclado do usuário.
Pra isso vamos importar uma biblioteca que existe dentro do <em>built in</em> do rust ou seja uma biblioteca que ele já nos fornece por padrão pra ser usada.</p>
<p>Para importa-la precisamos usar a palavra reservada <code>use</code> chamar a biblioteca que queremos que no caso é a <code>std</code> que á biblioteca <em>standard</em> do rust, e no caso eu quero um módulo especifico da biblioteca e não ela toda pra chamar o módulo precisamos usar o simbolo <code>::</code> para indicar que vamos selecionar um módulo e escolhe-lo que no caso é o módulo <code>io</code>.</p>
<p>Nosso código ficaria assim:</p>
<pre><code class="language-rust">use std::io;
</code></pre>
<p>Agora vamos precisar criar uma variável mutavel para receber a escolha do nosso usuário, no caso a escolha de um usuário sempre será uma sequencia de caracteres no caso podemos incializa-la com uma <code>String</code> vazia conforme abaixo:</p>
<pre><code class="language-rust">    //código
    println!(&quot;4 - Descansar na beira do riacho&quot;);

    ==let mut escolha_str: String = String::new();==

    if escolha == 1 {
    //código
</code></pre>
<p>Aqui usamos o simbolo <code>::</code> para chamar um método associado chamado <code>new</code> dentro da <code>Struct</code> chamada <code>String</code> que é uma sequência de caracteres.</p>
<p>Agora vamos usar o módulo <code>io</code> e chamar duas funções a <code>stdin</code> e a <code>read_line</code>, nesse primeiro momento não precisa se preocupar muito com a chamada que vou fazer, mas atente-se que vou colocar como parametro de <code>read_line</code> nossa variável <code>escolha_str</code> mais a frente vamos explicar com mais detalhes como funciona essa chamada que vamos fazer.</p>
<pre><code class="language-rust">    // código
    let mut escolha_str: String = String::new();

    ==io::stdin().read_line(&amp;mut escolha_str);==

    if escolha == 1 {
    // código

</code></pre>
<p>Agora vamos fazer um <code>println!</code> para imprimir o que o usuário escolheu no meu caso vou escolha a opção <code>4</code>.</p>
<pre><code class="language-rust">    // código
    io::stdin().read_line(&amp;mut escolha_str);

    ==println!(&quot;Escolha str é {}&quot;, escolha_str);==

    if escolha == 1 {
    // código
</code></pre>
<p>Com a saída:</p>
<pre><code class="language-rust">warning: `mysterious_forest` (bin &quot;mysterious_forest&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
Por favor escolha uma opção:
1 - Entrar na caverna escura
2 - Seguir no caminho iluminado
3 - Cruzar a ponte frágil
4 - Descansar na beira do riacho
5
Escolha str é 4

A sua escolha foi 1
A sua pontuação foi 50
</code></pre>
<p>Atente-se que a escolha é ainda 1 mas, a escolha str foi 4.</p>
<p>Agora quero que meu escolha receba o valor de escolha_str, porém o escolha_str é uma <code>String</code> e o escolha é um <code>i32</code>. Então pra conseguir fazer o que quero vou mudar minha variável escolha para <code>u32</code> para não receber número negativos e vou converter minha <code>String</code> para isso preciso remover espaços e quebras de linha e pra isso uso a função <code>trim</code> e depois chamo a função <code>parse</code> que vai tentar converter pro tipo da variável que quero.</p>
<p>É importante ressalta que a função <code>parse</code> vai me voltar um <code>Rusult</code> que é uma estrutura no formato abaixo:</p>
<pre><code>    (OK, Err)
</code></pre>
<p>Onde <code>OK</code> vai ter o valor do parse caso de certo e em <code>Err</code> vai voltar o erro caso ocorra um erro. Essa estrutura nunca vai voltar os dois valores. Pois ele ou vai retornar um valor do tipo <code>OK</code> ou um valor do tipo <code>Err</code> assim não precisando ter recursos como o null de algumas linguagens.</p>
<p>Então vamos mover nosso escolha para abaixo de escolha_str e fazer o parse.</p>
<pre><code class="language-rust">    println!(&quot;Escolha str é {}&quot;, escolha_str);
    ==let escolha: i32 = escolha_str.trim().parse();==

    if escolha == 1 {

</code></pre>
<p>No caso como o <code>parse</code> vai nos retornar ou <code>OK</code> ou <code>Err</code> eu quero que quando vier um erro nossa escolha receba o valor <code>0</code>.
Poderiamos fazer isso com um <code>if</code> que nossa estrutura condicional que já conhecemos, mas, nesse momento quero lhe mostrar outra estrutura que no caso é o <code>match</code>.</p>
<pre><code class="language-rust">    //código
    println!(&quot;Escolha str é {}&quot;, escolha_str);
    let escolha: i32 = match escolha_str.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; 0,
    };

    if escolha == 1 {
</code></pre>
<p>Sua estrutura é:</p>
<pre><code>    match &lt;condição&gt; {
        possivel retorno =&gt; retorno do código,
        possivel retorno 2 =&gt; retorno do código,
        ...
        possível retorno n =&gt; retorno do código
    }
</code></pre>
<p>Outro ponto é o simbolo <code>_</code> que é um coringa o que quer dizer que não importa o valor que vir ele vai considerar ele um valor válido é como uma condição "Se tudo que foi verificado antes não deu certo me use".
Tudo certo agora vamos rodar nosso código.</p>
<p>Agora nossa saída fica assim:
 <code>``bash
warning:</code>mysterious_forest<code>(bin "mysterious_forest") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.14s
     Running</code>target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
Por favor escolha uma opção:
1 - Entrar na caverna escura
2 - Seguir no caminho iluminado
3 - Cruzar a ponte frágil
4 - Descansar na beira do riacho
4
Escolha str é 4</p>
<p>A sua escolha foi 4
A sua pontuação foi 10</p>
<pre><code>
## Trabalhando com loop

Bom agora a primeira coisa que quero fazer é parar de dar o warning na linha onde capturamos a entrada do jogador pra isso vamos fazer uma alteração no código:

```rust

    let _ = io::stdin().read_line(&amp;mut escolha_str);
</code></pre>
<p>Há outras formas de resolver isso mas, nesse momento vamos fazer esse que é o mais simples. Agora vamos fazer nossa condição de vitória e derrota.</p>
<p>// main.rs</p>
<pre><code class="language-rust">use std::io;

fn main() {
    let mut pontuacao: i32 = 0;

    println!(&quot;Bem-vindo à floresta misteriosa&quot;);

    println!(&quot;Por favor escolha uma opção:&quot;);
    println!(&quot;1 - Entrar na caverna escura&quot;);
    println!(&quot;2 - Seguir no caminho iluminado&quot;);
    println!(&quot;3 - Cruzar a ponte frágil&quot;);
    println!(&quot;4 - Descansar na beira do riacho&quot;);

    let mut escolha_str: String = String::new();

    let _ = io::stdin().read_line(&amp;mut escolha_str);

    let escolha: i32 = match escolha_str.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; 0,
    };

    if escolha == 1 {
        pontuacao = pontuacao + 50;
    } else if escolha == 2 {
        pontuacao = pontuacao - 20;
    } else if escolha == 3 {
        pontuacao = pontuacao - 20;
    } else if escolha == 4 {
        pontuacao = pontuacao + 10;
    }
    ==
    if pontuacao &gt;= 100 {
        println!(&quot;Parabéns você é um verdadeiro aventureiro!&quot;);
    } else if pontuacao &lt;= 0 {
        println!(&quot;Que pena você perdeu&quot;);
    }

    println!(&quot;Obrigado por jogar 'A floresta misteriosa!'&quot;)
    ==
}

</code></pre>
<p>Aqui eu fiz um if verificando se a pontuação é maior ou igual a 100 coloco um print parabenizando pela vitória ou se a pontuação for menor ou igual a zero informando a derrota.
Há também mais um print para informar o fim do jogo além de ter tirado nosso println! para escolha str.</p>
<p>Agora podemos rodar nosso jogo e ver a condição de derrota já que a de vitória ainda não vamos conseguir por conta da pontuação.</p>
<pre><code class="language-bash">✦ ➜ cargo run
   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
Por favor escolha uma opção:
1 - Entrar na caverna escura
2 - Seguir no caminho iluminado
3 - Cruzar a ponte frágil
4 - Descansar na beira do riacho
3
Obrigado por jogar 'A floresta misteriosa!'

</code></pre>
<blockquote>
<p>[!info] Condicionais</p>
<p>Vale ressaltar que podemos usar <code>==</code> para verificar igualdades, <code>!=</code> para verificar &gt;diferenças, <code>&lt;=</code> para verificar se é menor ou igual, <code>&gt;=</code> para verificar se é maior ou igual assim como <code>&lt;</code> e <code>&gt;</code> para verificar se é menor e igual respectivamente.
</p>
</blockquote>
<p>Agora vamos por 100 na ultima opção para conseguirmos testar nossa condição de vitória.</p>
<pre><code class="language-rust">    } else if escolha == 4 {
        pontuacao = pontuacao + 100;
    }

</code></pre>
<p>Agora podemos testar.</p>
<pre><code class="language-bash">mysterious_forest on  main [?] is 📦 v0.1.0 via 🦀 v1.76.0 on ☁️   (eu-west-2) took 11s
✦ ➜ cargo run
   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running `target/debug/mysterious_forest`
Bem-vindo à floresta misteriosa
Por favor escolha uma opção:
1 - Entrar na caverna escura
2 - Seguir no caminho iluminado
3 - Cruzar a ponte frágil
4 - Descansar na beira do riacho
4
Parabéns você é um verdadeiro aventureiro!
Obrigado por jogar 'A floresta misteriosa!'

</code></pre>
<p>Certo agora temos nossa condição de vitória e derrota funcionando, mas basicamente nosso jogo por enquanto só podemos escolher uma opção e o jogo acaba. Então precisamos de uma forma de pode escolher repetidas vezes. 
Primeiro vamos ajustar nossa pontuação inicial e o ganho e perda da pontuação do jogo.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    let mut pontuacao: i32 = 50;

    println!(&quot;Bem-vindo à floresta misteriosa&quot;);

    println!(&quot;Por favor escolha uma opção:&quot;);
    println!(&quot;1 - Entrar na caverna escura&quot;);
    println!(&quot;2 - Seguir no caminho iluminado&quot;);
    println!(&quot;3 - Cruzar a ponte frágil&quot;);
    println!(&quot;4 - Descansar na beira do riacho&quot;);

    let mut escolha_str: String = String::new();

    let _ = io::stdin().read_line(&amp;mut escolha_str);

    let escolha: i32 = match escolha_str.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; 0,
    };

    if escolha == 1 {
        pontuacao = pontuacao + 30;
    } else if escolha == 2 {
        pontuacao = pontuacao - 20;
    } else if escolha == 3 {
        pontuacao = pontuacao - 20;
    } else if escolha == 4 {
        pontuacao = pontuacao + 10;
    }

    if pontuacao &gt;= 100 {
        println!(&quot;Parabéns você é um verdadeiro aventureiro!&quot;);
    } else if pontuacao &lt;= 0 {
        println!(&quot;Que pena você perdeu&quot;);
    }

    println!(&quot;Obrigado por jogar 'A floresta misteriosa!'&quot;)
}

</code></pre>
<p>Agora não conseguimos chegar nem a 100 e nem a 0 na primeira escolha, agora precisamos de algo que ajude nosso jogo a se repetir para isso vamos usar uma estrutura chamada <code>loop</code>.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    let mut pontuacao: i32 = 50;

    println!(&quot;Bem-vindo à floresta misteriosa&quot;);

    ==loop <mark class="critic">
        println!(&quot;Por favor escolha uma opção:&quot;);
        println!(&quot;1 - Entrar na caverna escura&quot;);
        println!(&quot;2 - Seguir no caminho iluminado&quot;);
        println!(&quot;3 - Cruzar a ponte frágil&quot;);
        println!(&quot;4 - Descansar na beira do riacho&quot;);

        let mut escolha_str: String = String::new();

        let _ = io::stdin().read_line(&amp;mut escolha_str);

        let escolha: i32 = match escolha_str.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; 0,
        };

        if escolha == 1 {
            pontuacao = pontuacao + 30;
        } else if escolha == 2 {
            pontuacao = pontuacao - 20;
        } else if escolha == 3 {
            pontuacao = pontuacao - 20;
        } else if escolha == 4 {
            pontuacao = pontuacao + 10;
        }

        if pontuacao &gt;= 100 {
            println!(&quot;Parabéns você é um verdadeiro aventureiro!&quot;);
            ==break;==
        } else if pontuacao &lt;= 0 {
            println!(&quot;Que pena você perdeu&quot;);
            ==break;==
        }
    </mark>==
    println!(&quot;Obrigado por jogar 'A floresta misteriosa!'&quot;)
}
</code></pre>
<p>No código acima envolvelmos a lógica do nosso jogo dentro do <code>loop</code> com o bloco de código <code>{}</code> evitando as mensagens de vitória e derrota.
Se deixarmos só o <code>loop</code> nosso código iria rodar infinitamente, então precisamos definir uam condição para ele parar e no nosso caso podemos usar nossa condição de vitória/derrota, para isso depois da mensagens usamos a palavra reservada <code>break</code>.</p>
<p>Agora se rodarmos nosso jogo com <code>cargo run</code> nosso jogo já está funcionando perfeitamente.</p>
<h3 id="alguns-ajustes">Alguns ajustes</h3>
<p>Vamos fazer algumas melhorias no código, primeiro vou simplicicar a soma e subtração da nossa pontuação usando a expressão <code>+=</code> e <code>-=</code>.</p>
<pre><code class="language-rust">        if escolha == 1 {
            pontuacao += 30;
        } else if escolha == 2 {
            pontuacao -= 20;
        } else if escolha == 3 {
            pontuacao += 20;
        } else if escolha == 4 {
            pontuacao += 10;
        }

</code></pre>
<p>Agora vamos por alguma mensagem de feedback pro jogador saber se ele está fazendo uma ação correta ou não.</p>
<pre><code class="language-rust">        if escolha == 1 {
            ==println!(&quot;Você entrou na caverna escura e econtrou um tesouro parabéns!&quot;);==
            pontuacao += 30;
        } else if escolha == 2 {
            ==println!(&quot;Você encontrou um Ogro poderoso, mas com sorte conseguiu escapar!&quot;);==
            pontuacao -= 20;
        } else if escolha == 3 {
            ==println!(&quot;A ponte se quebrou com sorte você conseguiu nadar de volta para a margem!&quot;);==
            pontuacao += 20;
        } else if escolha == 4 {
            ==println!(&quot;Você conseguiu recuperar um pouco das suas forças!&quot;);==
            pontuacao += 10;
        }

</code></pre>
<p>Agora se rodarmos o feedback ficou muito mais fácil pro jogador.</p>
<p>Como desafio tente colocar uma opção de jogar novamente o jogo com a opção S/N.</p>
<p>Com isso finalizamos nosso primeiro jogo em Rust, agora você pode tentar fazer os desafios abaixo.</p>
<h2 id="exercicios-sugeridos">Exercicíos sugeridos</h2>
<p>Aqui vou colocar os projetos para você fazer suas revisões, muitas vezes os desafios poderão não ser jogos infelizmente, mas estarei disponível no forum ou no Revolt para tirar dúvidas.</p>
<p>Revisão 1</p>
<ul>
<li>Crie um programa em Rust que simule o controle de estoque de uma loja, faça simples só com um unico produto utilizando variáveis para armazenar a quantidade do produto e permitindo a atualização dos valores de estoque de forma mutável.</li>
</ul>
<p>Revisão 2</p>
<ul>
<li>Desenvolva um programa que calcule o fatorial de um número inserido pelo usuário. Utilize uma variável mutável para armazenar o resultado parcial do cálculo.</li>
</ul>
<p>Revisão 3</p>
<ul>
<li>Crie um programa que simule uma calculadora simples em Rust, permitindo que o usuário realize operações de adição, subtração, multiplicação e divisão. Utilize variáveis mutáveis para armazenar os valores inseridos pelo usuário e o resultado das operações.</li>
</ul>
<p>Revisão 4
- Implemente um programa em Rust que converta temperaturas entre Celsius e Fahrenheit. Utilize variáveis mutáveis para armazenar os valores e permitir que o usuário escolha a conversão desejada.</p>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">April 10, 2024</span>
      
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.220ee61c.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>