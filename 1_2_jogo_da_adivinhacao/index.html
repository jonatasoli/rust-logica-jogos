
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://rustlogicajogos.jonatasoliveira.dev/1_2_jogo_da_adivinhacao/">
      
      
        <link rel="prev" href="../1_1_jogo_floresta_misteriosa/">
      
      
        <link rel="next" href="../1_3_jogo_blackjack/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.1.21">
    
    
      
        <title>Jogo da adivinhação - Rust da Lógica aos Jogos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#jogo-da-adivinhacao" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Rust da Lógica aos Jogos" class="md-header__button md-logo" aria-label="Rust da Lógica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Rust da Lógica aos Jogos
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Jogo da adivinhação
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema claro"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Mudar para o tema claro" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema escuro"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Mudar para o tema escuro" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Rust da Lógica aos Jogos" class="md-nav__button md-logo" aria-label="Rust da Lógica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Rust da Lógica aos Jogos
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Bem vindo ao curso Rust lógica com jogos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_0_introducao/" class="md-nav__link">
        Introdução
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_1_jogo_floresta_misteriosa/" class="md-nav__link">
        Floresta Misteriosa
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Jogo da adivinhação
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Jogo da adivinhação
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#regras" class="md-nav__link">
    Regras
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comecando-o-projeto" class="md-nav__link">
    Começando o projeto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seguranca-de-memoria" class="md-nav__link">
    Segurança de Memória
  </a>
  
    <nav class="md-nav" aria-label="Segurança de Memória">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#memoria-estatica" class="md-nav__link">
    Memória Estática
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memoria-stack" class="md-nav__link">
    Memória Stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memoria-heap" class="md-nav__link">
    Memória Heap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o-que-e-raii" class="md-nav__link">
    O que é RAII?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diferenca-entre-str-e-string" class="md-nav__link">
    Diferença entre &amp;str e String
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alocacao-de-memoria-em-rust" class="md-nav__link">
    Alocação de memória em Rust
  </a>
  
    <nav class="md-nav" aria-label="Alocação de memória em Rust">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-stack-pilha" class="md-nav__link">
    1. Stack (Pilha)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-heap" class="md-nav__link">
    2. Heap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-memoria-estatica" class="md-nav__link">
    3. Memória Estática
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-string-vs-str" class="md-nav__link">
    4. String vs &amp;str
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-a-funcao-do-jogo" class="md-nav__link">
    Criando a função do jogo
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ownership-e-borrowing" class="md-nav__link">
    Ownership e Borrowing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introducao-sobre-testes-de-software" class="md-nav__link">
    Introdução sobre testes de software
  </a>
  
    <nav class="md-nav" aria-label="Introdução sobre testes de software">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#desenvolvimento-orientado-a-testes-tdd" class="md-nav__link">
    Desenvolvimento Orientado a Testes (TDD)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduzindo-testes-ao-nosso-codigo" class="md-nav__link">
    Introduzindo testes ao nosso código
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-o-chute-do-jogador" class="md-nav__link">
    Adicionando o chute do jogador
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-condicao-de-vitoria" class="md-nav__link">
    Adicionando condição de vitória
  </a>
  
    <nav class="md-nav" aria-label="Adicionando condição de vitória">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trait" class="md-nav__link">
    Trait
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#derive" class="md-nav__link">
    Derive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vantagens-do-derive" class="md-nav__link">
    Vantagens do Derive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#procedural-macros" class="md-nav__link">
    Procedural macros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#no-nosso-caso-vamos-passar-algumas-implementacoes-basicas-no-derive" class="md-nav__link">
    No nosso caso vamos passar algumas implementações básicas no derive
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-condicao-de-derrota" class="md-nav__link">
    Adicionando condição de derrota
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-mais-testes" class="md-nav__link">
    Criando mais testes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#melhorando-nossa-funcao-de-condicao-e-ajustando-a-funcao-game" class="md-nav__link">
    Melhorando nossa função de condição e ajustando a função game.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#colocando-aleatoriedade-no-nosso-jogo" class="md-nav__link">
    Colocando aleatoriedade no nosso jogo
  </a>
  
    <nav class="md-nav" aria-label="Colocando aleatoriedade no nosso jogo">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#introducao-aos-crates" class="md-nav__link">
    Introdução aos crates
  </a>
  
    <nav class="md-nav" aria-label="Introdução aos crates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#o-que-sao-crates" class="md-nav__link">
    O Que São Crates?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-crates" class="md-nav__link">
    Tipos de Crates
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estrutura-de-diretorios-de-um-crate" class="md-nav__link">
    Estrutura de Diretórios de um Crate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gerenciando-dependencias" class="md-nav__link">
    Gerenciando Dependências
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-crates-de-terceiros" class="md-nav__link">
    Usando Crates de Terceiros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-o-cargo-fmt" class="md-nav__link">
    Usando o cargo fmt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-clippy" class="md-nav__link">
    Usando Clippy
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#update-rust" class="md-nav__link">
    Update Rust
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusao" class="md-nav__link">
    Conclusão
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exercicios-sugeridos" class="md-nav__link">
    Exercicíos sugeridos
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_3_jogo_blackjack/" class="md-nav__link">
        Jogo Blackjack
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../INDICE/" class="md-nav__link">
        Summary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Jogos/" class="md-nav__link">
        Jogos
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#regras" class="md-nav__link">
    Regras
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comecando-o-projeto" class="md-nav__link">
    Começando o projeto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seguranca-de-memoria" class="md-nav__link">
    Segurança de Memória
  </a>
  
    <nav class="md-nav" aria-label="Segurança de Memória">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#memoria-estatica" class="md-nav__link">
    Memória Estática
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memoria-stack" class="md-nav__link">
    Memória Stack
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memoria-heap" class="md-nav__link">
    Memória Heap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#o-que-e-raii" class="md-nav__link">
    O que é RAII?
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diferenca-entre-str-e-string" class="md-nav__link">
    Diferença entre &amp;str e String
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alocacao-de-memoria-em-rust" class="md-nav__link">
    Alocação de memória em Rust
  </a>
  
    <nav class="md-nav" aria-label="Alocação de memória em Rust">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-stack-pilha" class="md-nav__link">
    1. Stack (Pilha)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-heap" class="md-nav__link">
    2. Heap
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-memoria-estatica" class="md-nav__link">
    3. Memória Estática
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-string-vs-str" class="md-nav__link">
    4. String vs &amp;str
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-a-funcao-do-jogo" class="md-nav__link">
    Criando a função do jogo
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ownership-e-borrowing" class="md-nav__link">
    Ownership e Borrowing
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introducao-sobre-testes-de-software" class="md-nav__link">
    Introdução sobre testes de software
  </a>
  
    <nav class="md-nav" aria-label="Introdução sobre testes de software">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#desenvolvimento-orientado-a-testes-tdd" class="md-nav__link">
    Desenvolvimento Orientado a Testes (TDD)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduzindo-testes-ao-nosso-codigo" class="md-nav__link">
    Introduzindo testes ao nosso código
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-o-chute-do-jogador" class="md-nav__link">
    Adicionando o chute do jogador
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-condicao-de-vitoria" class="md-nav__link">
    Adicionando condição de vitória
  </a>
  
    <nav class="md-nav" aria-label="Adicionando condição de vitória">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trait" class="md-nav__link">
    Trait
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#derive" class="md-nav__link">
    Derive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vantagens-do-derive" class="md-nav__link">
    Vantagens do Derive
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#procedural-macros" class="md-nav__link">
    Procedural macros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#no-nosso-caso-vamos-passar-algumas-implementacoes-basicas-no-derive" class="md-nav__link">
    No nosso caso vamos passar algumas implementações básicas no derive
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adicionando-condicao-de-derrota" class="md-nav__link">
    Adicionando condição de derrota
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#criando-mais-testes" class="md-nav__link">
    Criando mais testes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#melhorando-nossa-funcao-de-condicao-e-ajustando-a-funcao-game" class="md-nav__link">
    Melhorando nossa função de condição e ajustando a função game.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#colocando-aleatoriedade-no-nosso-jogo" class="md-nav__link">
    Colocando aleatoriedade no nosso jogo
  </a>
  
    <nav class="md-nav" aria-label="Colocando aleatoriedade no nosso jogo">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#introducao-aos-crates" class="md-nav__link">
    Introdução aos crates
  </a>
  
    <nav class="md-nav" aria-label="Introdução aos crates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#o-que-sao-crates" class="md-nav__link">
    O Que São Crates?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-crates" class="md-nav__link">
    Tipos de Crates
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estrutura-de-diretorios-de-um-crate" class="md-nav__link">
    Estrutura de Diretórios de um Crate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gerenciando-dependencias" class="md-nav__link">
    Gerenciando Dependências
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-crates-de-terceiros" class="md-nav__link">
    Usando Crates de Terceiros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-o-cargo-fmt" class="md-nav__link">
    Usando o cargo fmt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usando-clippy" class="md-nav__link">
    Usando Clippy
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#update-rust" class="md-nav__link">
    Update Rust
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusao" class="md-nav__link">
    Conclusão
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exercicios-sugeridos" class="md-nav__link">
    Exercicíos sugeridos
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="jogo-da-adivinhacao">Jogo da adivinhação</h1>
<p>Vamos começar um novo jogo que é o jogo da adivinhação "Guessing Game" o objetivo desse jogo é identificar um número escolhido aleatóriamente. O jogo inicia com 1000 pontos para o
jogador e cada vez que ele erra o número é subtraido 100 pontos do placar dele quando o placar chegar a zero o jogo é encerrado.</p>
<h2 id="regras">Regras</h2>
<p>As regras são as seguintes:
- Ao iniciar o jogo o jogador tem a escolha de começar o jogo ou sair do jogo
- O jogador vai escolher um número entre 0 a 100
- Caso o jogador escolha um número fora desse intervalo será solicitado para ele escolher novamente
- Caso o jogador escolha uma letra ou um caractere especial também será solicitado para escolher o novamente
- Caso o jogador escolha um número menor que o número escolhido pelo jogo o jogo deve informar que o número escolhido foi menor
- Caso o jogador escolha um número maior que o número escolhido pelo jogo o jogo deve informar que o número escolhido foi maior
- Casa escolha que não seja o número escolhido pelo jogo deverá marcar um contador de erro
- O jogador começa com 1000 pontos caso aconteça um erro cada contador de erro deve subtrair 100 pontos
- Caso o jogador perca o jogo deverá ter um menu informando pra fechar o jogo ou jogar novamente
- Caso o jogador vença deverá mostrar o placar que ele obteve o a opção de sair do jogo ou tentar novamente.</p>
<h2 id="comecando-o-projeto">Começando o projeto</h2>
<p>Vamos iniciar um novo projeto em nossa pasta projects</p>
<pre><code class="language-bash">cd ~/projects
cargo new guessing_game
</code></pre>
<p>Agora para iniciar o nosso jogo vamos fazer o loop que já conhecemos e vamos criar o menu recebendo o input do usuário e imprimir na tela o valor escolhido e caso ele escolha
iniciar vamos imprimir que o jogo começou e caso ele sair nós vamos encerrar o jogo.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

        println!(&quot;A sua escolha foi {}&quot;, escolha_str);
        break;
    }

}
</code></pre>
<p>Aqui vamos mudar ao invés de usar números para opções vamos usar letras pois vamos precisar fazer um tratamento especial no código, estamos usando a captura que estavamos fazendo
anteriormente fazendo um println apenas no item escolhido, no final vamos dar um break apenas pra encerrar o loop.
Agora se rodarmos o código vamos ver que ele pegou a escolha que gostariamos e printou na tela.</p>
<pre><code>cargo run
</code></pre>
<p>Certo agora vamos fazer um match com nossa escolha str só que como estamos usando letras vou forçar que o que venha de letras senha minuscula ou maiuscula que ele force sempre a
ser minúsculo.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

==
        match escolha_str.trim().to_lowercase().as_str() {
        };
==

    }
}
</code></pre>
<p>Criamos a nossa linha como <code>match escolha.str.trim().to_lowercase()</code> usando a função <code>trim()</code> para removermos espaços em branco e agora usamos uma nova função chamada
<code>to_lowercase()</code> que vai transformar nossa string caso tenha letras maiusculas em minúsculas.
Outra função que usamos foi o <code>as_str</code> pois quando usamos o <code>trim</code> e o <code>to_lowercase</code> eles voltam uma String que é um tipo diferente do str, e nesse caso vamos comparar com "i" e "q" e quando passamos esses valores com aspas eles são do tipo str então pra comparar vamos precisar reconverter novamente para str e ai usamos o <code>as_str</code>.</p>
<p>Assim conseguimos agora colocar a comparação com a string "i" e a string "q".</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

==
        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                println!(&quot;Iniciar Jogo&quot;);
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };
==

    }
}
</code></pre>
<p>Aqui colocamos o "i" para imprimir e usamos o <code>continue</code> para voltar ao inicio do loop. No caso o jogador use "q" o programa vai ser encerrado.
Também usamos o coringa "_" caso seja dada outra opção que não seja "i" ou "q" nós colocamos a mensagem de erro e reiniciamos o loop.</p>
<p>Agora podemos testar e verificar se nossa função está correta.</p>
<h2 id="seguranca-de-memoria">Segurança de Memória</h2>
<p>Rust fornece uma série de garantias de segurança de memória durante o tempo de compilação. Essas garantias são fundamentais para evitar erros comuns, como vazamentos de memória, referências nulas e acessos inválidos.</p>
<ul>
<li>Sem Referências Nulas: Rust garante que as referências não sejam nulas, eliminando muitos erros de acesso nulo.</li>
<li>Sem Vazamentos de Memória: Rust controla rigorosamente o ciclo de vida dos recursos, o que impede vazamentos de memória.</li>
<li>Sem Concorrência de Dados Mutáveis: Rust impõe regras rigorosas para evitar a concorrência de dados mutáveis, garantindo a segurança em threads.</li>
</ul>
<p>Exitem 3 locais de memória que trabalhamos com rust que é a memória estática, stack e heap.</p>
<p><a class="glightbox" href="../images/memory.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Estrutura da memória" src="../images/memory.png" /></a></p>
<h3 id="memoria-estatica">Memória Estática</h3>
<p><a class="glightbox" href="../images/static-memory.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Estática" src="../images/static-memory.png" /></a></p>
<p>A memória estática é onde fica o binário do nosso programa, variáveis estáticas, strings literais. Nós conhecemos ela em tempo de compilação pois o rust vai reservar a memória necessária para acomodar os recursos criados aqui.
Ela possui um tamanho fixo e essa memória existe durante o tempo de alocação do programa e é liberada assim que o programa é encerrado e a forma mais rápida de acessar um recurso.</p>
<h3 id="memoria-stack">Memória Stack</h3>
<p><a class="glightbox" href="../images/stack-memory.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Stack" src="../images/stack-memory.png" /></a></p>
<p>A memória stack armazena argumentos de funções e variaveis locais ou seja recursos dentro de um bloco de função quando trabalhamos com várias threads cada thread vai ter uma stack especifica e ele é conhecido em tempo de compilação porém ele tem um tamanho dinâmico dentro de um limite especifico, quando esse limite é estourado recebemos o famoso erro <em>stack overflow</em>.
Como é uma memória dinâmica o gatilho pra liberar a memória é quando uma função é encerrada.</p>
<h3 id="memoria-heap">Memória Heap</h3>
<p><a class="glightbox" href="../images/heap-memory.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="Heap" src="../images/heap-memory.png" /></a></p>
<p>A memória heap é um tipo de memória onde armazenamos valores dinâmicos ou seja que durante a execução de um programa pode variar, por exemplo num jogo onde recebemos o nome do jogador nós não vamos saber previamente o tamanho do nome do mesmo então ele será armazenado na memória heap. Ele é usado sempre que tivermos variáveis que são muito grandes ou qual eu não conheça o valor previamente.
Quanto trabalhamos com threads esse valor é compartilhado e não sabemos em tempo de compilação onde o valor disponível normalmente é fornecido pelo sistema operacional.
O tempo de vida dessas variáveis serão determinados pelo programador ou pela linguagem usada e no caso do Rust ela é liberada usando RAII.</p>
<h3 id="o-que-e-raii">O que é RAII?</h3>
<p>RAII significa "Resource Acquisition Is Initialization". É um princípio de programação utilizado em linguagens como C++ e Rust. A ideia principal por trás do RAII é associar a aquisição de recursos à inicialização de objetos.</p>
<h2 id="diferenca-entre-str-e-string">Diferença entre &amp;str e String</h2>
<p>Rust é uma linguagem de programação moderna que coloca um forte foco na segurança e no gerenciamento de memória, permitindo aos desenvolvedores escrever código seguro e eficiente. Duas estruturas de dados muito importantes em Rust são &amp;str e String. Embora ambas sejam usadas para representar texto, elas têm diferenças fundamentais em termos de propriedades e uso. Vamos explorar as distinções entre &amp;str e String em Rust.</p>
<p>&amp;str - Referência para uma Sequência de Caracteres</p>
<p>É importante reforçar que caratere representa um simbolo em Rust e ele é um tipo primitivo que acabamos não vendo ainda, o tipo str é uma sequência de caracteres que é o tipo primitivo.
&amp;str é uma fatia (slice) que representa uma sequência de caracteres em Rust. Essa fatia é uma referência a uma sequência de caracteres armazenada em outro local da memória. Aqui estão algumas características importantes do &amp;str:</p>
<div class="highlight"><pre><span></span><code>Imutável: O &amp;str é imutável, o que significa que você não pode modificar o conteúdo da sequência de caracteres a que ele faz referência.

Alocação Zero: O &amp;str em si não aloca memória para a sequência de caracteres. Ele simplesmente aponta para uma sequência existente.

View (Visão): O &amp;str é uma visão de uma sequência de caracteres (tipo primitivo). Pode ser usado para referenciar substrings de uma String ou literais de string.

Lifetime: O &amp;str é um tipo estático ou seja ele vai alocar a memória quando o programa é compilado e vai existir durante todo o tempo em que o programa for executado.
</code></pre></div>
<p>Aqui está um exemplo de &amp;str:</p>
<pre><code class="language-rust">fn main() {
    let texto: &amp;str = &quot;Olá, Mundo!&quot;;
    println!(&quot;{}&quot;, texto);
}

</code></pre>
<p>String - Propriedade de uma Sequência de Caracteres</p>
<p>String é uma estrutura de dados que representa uma sequência de caracteres alocada dinamicamente em Rust. Aqui estão algumas características importantes da String:</p>
<div class="highlight"><pre><span></span><code>Mutável: A String é mutável, o que significa que você pode modificar seu conteúdo, adicionando ou removendo caracteres.

Alocação Dinâmica: A String aloca memória dinamicamente para armazenar a sequência de caracteres. Isso permite que você ajuste o tamanho conforme necessário.

Proprietária: A String é proprietária, o que significa que é responsável por gerenciar a memória da sequência de caracteres que ela contém.

Conversão: Você pode converter um &amp;str em uma String usando a função to_string(), ou usar a função String::from().
</code></pre></div>
<p>Aqui está um exemplo de String:</p>
<pre><code class="language-rust">fn main() {
    let mut texto: String = String::from(&quot;Olá, &quot;);
    texto.push_str(&quot;Mundo!&quot;);
    println!(&quot;{}&quot;, texto);
}
</code></pre>
<p>Quando Usar &amp;str e String</p>
<p>A escolha entre &amp;str e String depende do contexto e dos requisitos do seu programa:</p>
<div class="highlight"><pre><span></span><code>Use &amp;str quando precisar de uma referência imutável a uma sequência de caracteres existente. Por exemplo, ao passar argumentos de função ou realizar operações de leitura em uma sequência.

Use String quando precisar de uma sequência de caracteres mutável que pode ser modificada. Por exemplo, para construir uma sequência de caracteres dinamicamente.

Lembre-se de que &amp;str e String são intercambiáveis por meio de conversões quando necessário.
</code></pre></div>
<h2 id="alocacao-de-memoria-em-rust">Alocação de memória em Rust</h2>
<p>Rust é uma linguagem de programação conhecida por seu controle rigoroso sobre a memória. Ela oferece diversos tipos de memória com comportamentos distintos, o que é fundamental para garantir a segurança e o desempenho dos programas. Vamos explorar os principais tipos de memória em Rust e como eles se comportam.</p>
<h4 id="1-stack-pilha">1. Stack (Pilha)</h4>
<p>A pilha, ou stack, é um local de armazenamento de memória de curto prazo e é usada para alocar variáveis locais e controlar a execução do programa. Aqui estão algumas características da pilha:</p>
<ul>
<li>Alcance Limitado: As variáveis alocadas na pilha têm um tempo de vida limitado e são desalocadas automaticamente quando saem do escopo.</li>
<li>Alocação Rápida: A alocação e liberação de memória na pilha é rápida, pois segue uma ordem rigorosa de LIFO (último a entrar, primeiro a sair).</li>
<li>Tamanho Conhecido em Tempo de Compilação: O tamanho das variáveis alocadas na pilha deve ser conhecido em tempo de compilação.</li>
</ul>
<p>Exemplo de alocação na pilha:</p>
<pre><code class="language-rust">fn main() {
    let x = 42; // Variável &quot;x&quot; alocada na pilha
}
</code></pre>
<h4 id="2-heap">2. Heap</h4>
<p>O heap é um local de armazenamento de memória de longo prazo, usado para alocar dados cujo tamanho não é conhecido em tempo de compilação e/ou que precisam de tempo de vida mais longo. Aqui estão algumas características do heap:</p>
<ul>
<li>Alcance Mais Amplo: Os dados alocados no heap podem ter um tempo de vida mais longo e persistir além do escopo atual.</li>
<li>Alocação e Liberação Controladas: A alocação e liberação de memória no heap são controladas manualmente pelo programador, usando funções como Box::new, Vec::new, etc.</li>
</ul>
<p>Exemplo de alocação no heap:</p>
<pre><code class="language-rust">fn main() {
    let x = Box::new(42); // Variável &quot;x&quot; alocada no heap
}
</code></pre>
<h4 id="3-memoria-estatica">3. Memória Estática</h4>
<p>A memória estática é usada para armazenar dados que têm um tempo de vida durante toda a execução do programa. Ela é alocada em tempo de compilação e não pode ser liberada durante a execução.</p>
<ul>
<li>Tempo de Vida Global: Os dados estáticos têm um tempo de vida global e existem durante toda a execução do programa.</li>
<li>Alocação em Tempo de Compilação: A memória estática é alocada em tempo de compilação e não pode ser liberada ou realocada.</li>
</ul>
<p>Exemplo de alocação de memória estática:</p>
<pre><code class="language-rust">static HELLO: &amp;str = &quot;Hello, World!&quot;;
</code></pre>
<h4 id="4-string-vs-str">4. String vs &amp;str</h4>
<p>Rust distingue entre String e &amp;str. String é uma sequência de caracteres alocada no heap, que permite modificações. &amp;str é uma referência a uma sequência de caracteres (geralmente String ou literal de string) e é imutável.</p>
<ul>
<li>Use String quando precisar de uma sequência de caracteres que pode ser modificada.</li>
<li>Use &amp;str para referenciar sequências de caracteres imutáveis.</li>
</ul>
<pre><code class="language-rust">fn main() {
    let s1: String = String::from(&quot;Hello&quot;);
    let s2: &amp;str = &quot;World&quot;;
}
</code></pre>
<h2 id="criando-a-funcao-do-jogo">Criando a função do jogo</h2>
<p>Agora vamos criar uma função onde vamos manter nossa lógica do jogo para isso vamos usar a palavra reservada fn</p>
<pre><code class="language-rust">fn game() -&gt; () {
    println!(&quot;Iniciar Jogo&quot;);
}
</code></pre>
<p>Com isso movemos nosso print iniciar jogo para dentro da função e vamos ver que vai continuar funcionando vale notar que na função nós anotamos <code>()</code> que quer dizer que a função vai
retornar uma Option vazia ou seja se for OK vão vai ter valor algum isso faz a função main que chama a função game saber que essa função não tem retorno se nós tentarmos receber
algum valor de game nós vamos receber a Option porém ela vai ver sem nenhum valor, com isso nós nunca vamos receber um valor Nulo no máximo um Option com um Ok porém não existe um
valor empty ou None isso é uma caracteristica do rust para trabalhar sem usar valores nulos.
Agora quero que nosso jogo defina o número secreto, nesse momento vamos definir um número fixo, mais a frente vamos fazer esse número ser aleatório, também vamos receber a
pontuação do jogador e vamos já contar um erro e o fim do jogo.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                ==
                let mut _pontuacao: u16 = 1000;
                let _numero_alvo: u8 = 42;
                game(pontuacao=_pontuacao, numero=_numero_alvo);
                ==
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };

    }
}


fn game(pontuacao: u16, numero: u8) -&gt; () {
    println!(&quot;Iniciar Jogo&quot;);
    ==
    pontuacao = pontuacao - 100;
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
    ==
}
</code></pre>
<p>Se tentarmos compilar vamos receber o erro abaixo:</p>
<pre><code class="language-bash">❮ cargo run
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
error[E0384]: cannot assign to immutable argument `pontuacao`
  --&gt; src/main.rs:35:5
   |
33 | fn game(pontuacao: u16, numero: u8) -&gt; () {
   |         --------- help: consider making this binding mutable: `mut pontuacao`
34 |     println!(&quot;Iniciar Jogo&quot;);
35 |     pontuacao = pontuacao - 100;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument

For more information about this error, try `rustc --explain E0384`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to previous error
</code></pre>
<p>Essa mensagem diz que pontuação dentro de game é um atributo imutável então precisamos deixar nosso parametro mutável. então simplesmente vamos usar um mut no cabeçalho da função
game.</p>
<pre><code class="language-rust">fn game(mut pontuacao: u16, numero: u8) -&gt; () {
...
</code></pre>
<p>Agora se rodarmos vai voltar o resultado que gostariamos.</p>
<pre><code class="language-bash">Bem vindo ao jogo da adivinhação escolha uma das opções abaixo
i - Iniciar o jogo
q - Fechar o jogo
i
Iniciar Jogo
A sua pontuação foi 900, e o número era 42
...
</code></pre>
<p>Agora vamos mudar um pouco queremos que nosso print do resultado também seja impresso depois que o loop do game acabar então vamos copia-lo pra fora da função.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                let mut _pontuacao: u16 = 1000;
                let _numero_alvo: u8 = 42;
                game(_pontuacao, _numero_alvo);
                ==
                println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, _pontuacao, _numero_alvo);
                ==
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };

    }
}
</code></pre>
<p>Agora vamos receber essa saida</p>
<pre><code class="language-bash">➜ cargo run
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target/debug/guessing_game`
Bem vindo ao jogo da adivinhação escolha uma das opções abaixo
i - Iniciar o jogo
q - Fechar o jogo
i
Iniciar Jogo
A sua pontuação foi 900, e o número era 42
A sua pontuação foi 1000, e o número era 42
</code></pre>
<p>O que aconteceu?
Acontece que do jeito que está a função game está recebendo uma cópia dos valores de _pontuacao e _numero_alvo ou seja o valor reduzido de 900 só existe dentro da função game
quando a função termina o rust limpa as variáveis do escopo de game poderiamos facilmente resolver isso fazendo com que game retorne o valor de 900 para nossa variável _pontuacao
mas, podemos resolver isso sem precisar duplicar os valores dentro da função passando a referência delas através de Borrowing que é o que vamos discutir a seguinte.</p>
<h2 id="ownership-e-borrowing">Ownership e Borrowing</h2>
<p>Rust introduz o conceito de "ownership" (propriedade) e "borrowing" (empréstimo) para gerenciar a memória de forma segura. Isso implica que, em Rust, você precisa seguir regras rigorosas para acessar e modificar a memória. A ideia principal é que um recurso só pode ser possuído por uma única parte do código em um determinado momento.</p>
<ul>
<li>Propriedade (Ownership): Uma variável é a "dona" de um recurso e é responsável por liberá-lo quando não for mais necessário.</li>
<li>Empréstimo (Borrowing): Outras partes do código podem "emprestar" acesso à variável, mas não podem modificar a propriedade.</li>
</ul>
<p>Assim sendo no nosso caso particular podemos pedir pro rust nos dar as referências das variáveis _pontuacao e _numero_alvo assim sendo ele não cria uma nova variável <code>numero</code> e
<code>pontuacao</code> ele vai simplesmente pegar a referencia onde está armazenado os valores de _pontuacao e _numero_alvo e começar a apontar para os parametros que existem na função assim
quando a função terminar ela vai devolver as referências para os parametros originais.</p>
<pre><code>use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                let mut _pontuacao: u16 = 1000;
                let _numero_alvo: u8 = 42;
                ==
                game(&amp;mut _pontuacao, &amp;_numero_alvo);
                ==
                println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, _pontuacao, _numero_alvo);
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };

    }
}


==
fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
==
    println!(&quot;Iniciar Jogo&quot;);
    ==
    *pontuacao -= 100;
    ==
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}
</code></pre>
<p>Aqui fizemos algumas alterações a primeira é que passamos na variável o simbolo "&amp;" que indica que estamos emprestando a referência para a função ou seja ela vai ser
temporáriamente a dona dos parametros passados e no caso de pontuação nós passamos como &amp;mut que quer dizer que ela pode ser modificada, caso fosse passado apenas om o &amp; comercial
a função game só teria a permissão de ler o parametro e não modificalo.</p>
<pre><code class="language-rust">fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
</code></pre>
<p>No cabeçalho da função mudamos também indicando que pontuação é a referencia mutavel de um u16 e a referencia de u8 assim na compilação ele sabe que a função está trabalhando com
referências e não vai criar uma cópia da função.</p>
<p>Por ultimo vamos fazer uma alteração na nossa operação de subtração</p>
<pre><code class="language-rust">    *pontuacao -= 100;
</code></pre>
<p>Usamos o simbilo "*" para indicar que não queremos mexer na referência onde está pontuacao mas, no valor que ele possui assim o valor que estava em _pontuacao mudou de 1000 para
900.</p>
<p>Agora com isso conseguimos compreender as linhas onde capturamos a entrada do teclado do jogador</p>
<pre><code class="language-rust">        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);
</code></pre>
<p>Onde criamos uma variável escolha_str que é uma String vazia e mutável e quando chamamos a função read_line nós passamos a referência mutável de escolha_str e enquanto ela está em
execução ela está alterando o valor do <code>escolha_str</code> para nós e quando termina conseguimos usar o valor de escolha_str com os valores modificados pela função <code>read_line</code> sem
precisar duplicar a variável dentro da função. 
É importante reforçar que em muitas linguagens não conseguimos fazer isso nós normalmente precisamos receber a copia modificada dentro da função para conseguir trabalhar. Essa
característica do rust é muito importante para casos que trabalhamos com pouca memória ou mesmo um jogo onde quanto menos recursos usarmos mais leve será nosso jogo.</p>
<h2 id="introducao-sobre-testes-de-software">Introdução sobre testes de software</h2>
<p>A programação é uma tarefa complexa que envolve a criação de software que seja confiável, eficiente e livre de erros. À medida que os projetos de desenvolvimento de software crescem em complexidade, torna-se cada vez mais crítico garantir a qualidade do código. Uma das abordagens mais eficazes para assegurar a qualidade do software é a prática de testes, especialmente o Desenvolvimento Orientado a Testes (TDD).</p>
<p>Então vamos agora explorar sobre a importância dos testes na programação e como o TDD pode ser uma ferramenta valiosa para alcançar um código mais robusto e confiável. Vamos mergulhar no mundo dos testes e entender por que eles são essenciais para qualquer desenvolvedor de software.</p>
<p>Os testes desempenham um papel fundamental no processo de desenvolvimento de software por várias razões:</p>
<ul>
<li>Detecção Precoce de Erros: Os testes permitem que os desenvolvedores identifiquem e corrijam erros em um estágio inicial do desenvolvimento, economizando tempo e recursos no longo prazo.</li>
<li>Manutenção Simplificada: Um código bem testado é mais fácil de manter. Quando novos recursos são adicionados ou modificações são feitas, os testes garantem que as funcionalidades existentes continuem funcionando conforme o esperado.</li>
<li>Redução de Bugs em Produção: Testar seu código ajuda a evitar que bugs cheguem aos usuários finais, resultando em uma melhor experiência do cliente e economizando custos associados à correção de problemas em produção.</li>
<li>Documentação Automática: Testes bem escritos funcionam como documentação viva do seu código. Eles descrevem como as diferentes partes do software devem se comportar.</li>
<li>Confiança no Código: Testar seu código cria confiança tanto para os desenvolvedores quanto para os usuários. Saber que o software passou em uma bateria de testes proporciona tranquilidade.</li>
</ul>
<h4 id="desenvolvimento-orientado-a-testes-tdd">Desenvolvimento Orientado a Testes (TDD)</h4>
<p>O Desenvolvimento Orientado a Testes (TDD) é uma abordagem de desenvolvimento que enfatiza a escrita de testes antes de escrever o código real. O ciclo TDD segue três passos simples: "Red-Green-Refactor."</p>
<ul>
<li>Red (Vermelho): Neste estágio, você escreve um teste que descreve a funcionalidade que deseja implementar. Como você ainda não escreveu o código, o teste falhará.</li>
<li>Green (Verde): Agora, você escreve o código mínimo necessário para fazer o teste passar. O objetivo é fazer o teste passar o mais rápido possível.</li>
<li>Refactor (Refatorar): Com o teste passando, você pode refatorar o código para torná-lo mais limpo, eficiente e legível.</li>
</ul>
<p>O TDD oferece inúmeras vantagens, incluindo:</p>
<ul>
<li>Maior Qualidade do Código: TDD incentiva a escrita de código de alta qualidade desde o início.</li>
<li>Projeto Centrado no Usuário: Testes escritos com base nos requisitos do usuário garantem que o software atenda às expectativas.</li>
<li>Facilidade de Manutenção: O código resultante do TDD é mais fácil de manter, pois as mudanças não quebram as funcionalidades existentes.</li>
<li>Confiança nas Mudanças: TDD permite que os desenvolvedores façam alterações no código com confiança, sabendo que os testes irão detectar problemas.</li>
<li>Feedback Rápido: TDD fornece feedback imediato, acelerando o processo de desenvolvimento.</li>
</ul>
<p>A importância dos testes na programação não pode ser subestimada. Eles desempenham um papel crítico na criação de software de alta qualidade, confiável e seguro. O Desenvolvimento Orientado a Testes (TDD) é uma abordagem valiosa que torna os testes uma parte integrante do processo de desenvolvimento, resultando em um código mais robusto e confiável.</p>
<p>Para os desenvolvedores, a prática de testes e o uso do TDD representam um investimento que se traduz em economia de tempo, redução de custos e satisfação do cliente. À medida que a indústria de software continua a evoluir, a cultura de testes se torna cada vez mais fundamental para o sucesso de projetos de desenvolvimento de software.</p>
<p>Portanto, da próxima vez que você começar a escrever código, lembre-se da importância dos testes e considere adotar o Desenvolvimento Orientado a Testes como parte integrante do seu processo de desenvolvimento. A qualidade do seu software agradecerá.</p>
<h2 id="introduzindo-testes-ao-nosso-codigo">Introduzindo testes ao nosso código</h2>
<p>Agora vamos abrir nosso arquivo test_game_loop.rs, esse teste vai ser usado para testarmos nossas condições do jogo então vamos criar um primeiro teste para validar a condição que
está fixa hoje.
Vamos adicionar o código abaixo no final do nosso main.rs</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;

    // Act
    game(&amp;mut pontuacao, &amp;numero)

    // Assert
    assert_eq!(pontuacao, 900)
}

</code></pre>
<p>Inicialmente precisamos adicionar uma anotação <em>annotattion</em> <code>#[test]</code> as anotações são colocadas no inicio de uma função/módulo/trait para adicionar alguma funcionalidade aquele
bloco de código.
NO nosso caso estamos adicionando uma funcionalidade de teste para nossa função de teste <code>test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral</code> assim podemos rodar o
comando de teste <code>cargo test</code>.
Nossa estrutura de testes é divida em 3 partes:
- Arrange -&gt; que é os dados que precisamos preparar para o teste
- Act -&gt; Execução do código que queremos testas
- Assert -&gt; Que é o que esperamos que aconteça depois do código sendo executado.</p>
<p>No caso do assert executamos uma macro nova que é o <code>assert_eq!</code> sua função é comprar dois valores caso sejam iguais ele termina corretamente, caso sejam diferentes ele vai voltar
um erro no nosso teste, vamos primeiro rodar o teste do jeito que está.</p>
<pre><code class="language-bash">cargo test
</code></pre>
<p>Você deve ter um retorno parecido com esse:</p>
<pre><code class="language-bash">➜ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Vale destacar alguns pontos:</p>
<pre><code class="language-bash">➜ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
    <mark class="critic">
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)
     </mark>

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Aqui mostra onde foi compilado o teste</p>
<pre><code class="language-bash">➜ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

    <mark class="critic">
running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
     </mark>

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Nessas linhas mostram quantos testes rodaram, o nome do teste que rodou e se foi ok ou não</p>
<pre><code class="language-bash">➜ cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

    <mark class="critic">
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
     </mark>
</code></pre>
<p>Nessa linha temos um pequeno relatório dos testes quando passaram quantos derram erro e por ai vai, além de tudo mostra o tempo que demorou pra rodar os testes.</p>
<p>Agora vamos mudar nosso teste para ele falhar</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;

    // Act
    game(&amp;mut pontuacao, &amp;numero);

    // Assert
    ==assert_eq!(pontuacao, 0)==
}
</code></pre>
<p>Agora temos uma saída diferente</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.12s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... FAILED

failures:

---- test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral stdout ----
<mark class="critic">
Iniciar Jogo
A sua pontuação foi 900, e o número era 42
thread 'test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral' panicked at src/main.rs:51:5:
assertion `left == right` failed
  left: 900
 right: 0
</mark>
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


<mark class="critic">
failures:
    test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</mark>

error: test failed, to rerun pass `--bin guessing_game`

</code></pre>
<p>É importante não ter medo de ler toda a mensagem mesmo que seja grande pois com ela podemos ver o problema.</p>
<p>Veja que agora ele mostra a saida da execução de game, no caso ele vai mostrar os dois prints que criamos depois ele vai mostrar o erro do assertion mostrando que o valor de
pontuação foi 900 e o valor da direita foi 0 então sabemos quanto nossa variavel retornou e o valor da comparação.</p>
<p>Também podemos ver que agora no nosso relatório temos um teste como failed pois o teste falhou.</p>
<p>Vamos agora voltar nosso teste para passar novamente e rodar os testes.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Certo agora podemos continuar trabalhando no jogo.</p>
<h2 id="adicionando-o-chute-do-jogador">Adicionando o chute do jogador</h2>
<p>Agora vamos adicionar a captura da entrada do jogador para e vamos passar o valor para nossa função game.</p>
<pre><code class="language-rust">fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
    <mark class="critic">
    println!(&quot;Por favor digite o número que você acredita ser&quot;);
    let mut chute = String::new();
    let _ = io::stdin().read_line(&amp;mut chute);
    </mark>
    *pontuacao -= 100;
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}
</code></pre>
<p>Se rodarmos nosso teste ele ainda vai passar.</p>
<pre><code class="language-bash">➜  cargo test
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Agora vamos fazer algumas alterações vamos criar uma nova função que vai atualizar a pontuação. Mas primeiro vamos mudar nosso teste para verificar com a função
<em>check_win_condition</em> e passar mais um parametro chamado chute que vai ser um inteiro também.</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    check_win_conditition(&amp;mut pontuacao, &amp;numero);

    // Assert
    assert_eq!(pontuacao, 900)
}
</code></pre>
<p>Vamos receber agora um erro de compilação</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
error[E0425]: cannot find function `check_win_conditition` in this scope
  --&gt; src/main.rs:55:5
   |
55 |     check_win_conditition(&amp;mut pontuacao, &amp;numero, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope

For more information about this error, try `rustc --explain E0425`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot; test) due to previous error
</code></pre>
<p>É importante sempre ler a mensagem de erro e tentar entender também sempre que quiser poder rodar o <code>--explain</code> para ver a descrição do erro.</p>
<pre><code class="language-bash">rustc --explain E0425
</code></pre>
<p>Nesse caso o erro é que check_win_conditition não existe dentro  do escopo isso por que ele não foi criado, vamos então cria-lo e mover o código responsável por diminuir a
pontuação.</p>
<pre><code class="language-rust">fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
    println!(&quot;Por favor digite o número que você acredita ser&quot;);
    let mut chute = String::new();
    let _ = io::stdin().read_line(&amp;mut chute);
}

fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
    *pontuacao -= 100;
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}
</code></pre>
<p>Se rodarmos o teste ele vai funcionar com um warning que logo vamos remove-lo.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused variable: `pontuacao`
  --&gt; src/main.rs:33:9
   |
33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pontuacao`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `numero`
  --&gt; src/main.rs:33:30
   |
33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {
   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_numero`

warning: unused variable: `chute`
  --&gt; src/main.rs:39:59
   |
39 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 3 warnings (run `cargo fix --bin &quot;guessing_game&quot; --tests` to apply 3 suggestions)
    Finished test [unoptimized + debuginfo] target(s) in 0.15s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>O principal ponto desse warnings é que não estamos usando várias variaveis vamos ajusta-las. Primeiro precisamos converter nossa variavel chute para int.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        let _ = io::stdin().read_line(&amp;mut escolha_str);

        match escolha_str.trim().to_lowercase().as_str() {
            <mark class="critic">
            &quot;i&quot; =&gt; {
                game();
                continue;
            }
            </mark>
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };

    }
}

<mark class="critic">
fn game() -&gt; () {
    println!(&quot;Por favor digite o número que você acredita ser&quot;);
    let mut pontuacao: u16 = 1000;
    let numero_alvo: u8 = 42;
    let mut chute = String::new();
    let _ = io::stdin().read_line(&amp;mut chute);

    let chute: u8 = match chute.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; { 
            println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
            0
        }
    };
    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero_alvo);
}

fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
    *pontuacao -= 100;
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}
</mark>



#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(pontuacao, 900)
}

</code></pre>
<p>Temos algumas mudanças aqui, precisamos mover pontuacao e numero_alvo para dentro da função game, pois não podemos reimprestar  pontuacao para <em>verify_win_conditition</em> essa é uma
caracteristica do rust então jogamos tudo para a função game deixando a main apenas para menu.
Também fizemos o match abaixo para converter a entrada  string para u8 e com isso temos um efeito colateral que precisamos voltar um número que no caso é 0.</p>
<pre><code class="language-rust">    let chute: u8 = match chute.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; { 
            println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
            0
        }
    };
</code></pre>
<p>Agora vamos rodar nosso teste.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused variable: `chute`
  --&gt; src/main.rs:48:59
   |
48 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 1 warning (run `cargo fix --bin &quot;guessing_game&quot; --tests` to apply 1 suggestion)
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Vamos agora remover o ultimo warning e vamos começar a usar nosso parametro chute.</p>
<pre><code class="language-rust">fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
    <mark class="critic">
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    </mark>
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}
</code></pre>
<p>Assim agora apenas se o número for menor que o número a pontuação vai mudar. Vamos rodar o teste.</p>
<pre><code class="language-rust">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 1 test
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Agora vamos alterar nossa entrada para não receber o parametro "_", pois há uma forma melhor de fazer isso.</p>
<pre><code class="language-rust">use std::io;

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        <mark class="critic">
        io::stdin().read_line(&amp;mut escolha_str).expect(&quot;Erro ao receber sua escolha&quot;);
        </mark>

        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                game();
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };

    }
}

fn game() -&gt; () {
    println!(&quot;Por favor digite o número que você acredita ser&quot;);
    let mut pontuacao: u16 = 1000;
    let numero_alvo: u8 = 42;
    let mut chute = String::new();
    <mark class="critic">
    io::stdin().read_line(&amp;mut chute).expect(&quot;Erro ao receber o número&quot;);
    </mark>

    let chute: u8 = match chute.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; { 
            println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
            0
        }
    };
    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero_alvo);
}

fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
}



#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(pontuacao, 900)
}
</code></pre>
<p>Aqui retiramos o parametro não usado e colocamo no final um expect isso é uma captura de erro, vamos detalhar isso mais a frente mas, se pense que agora caso a option que esteja
com algum dado é a <code>Err</code> ele vai printar no nosso console as mensagens que colocamos.</p>
<h2 id="adicionando-condicao-de-vitoria">Adicionando condição de vitória</h2>
<p>Primeiro passo que vamos fazer é criar um teste para a condição de vitória:</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(pontuacao, 900)
}

<mark class="critic">
#[test]
fn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 42;

    //Act
    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(pontuacao, 1000)
}
</mark>
</code></pre>
<p>Aqui criamos uma função de teste <em>test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao</em> onde simplesmente passamos o número correto e ele deve voltar a com a
pontuação exata que passamos.
Vamos rodar o teste:</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 2 tests
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Certo o teste está passando vamos fazer com que nossa função retorne que o jogador ganhou, normalmente em muitas linguagens trabalhariamos com um valor de verdadeiro ou falso
poderiamos fazer isso aqui também, porém como o rust nos da a ferramenta do result vamos voltar um tipo Result::Win para dizer que o jogador ganhou, mas como vamos ter outras
condições vamos criar uma estrutura de enumerador para representar os estados que jogo pode retornar:</p>
<pre><code>#[derive(Debug, PartialEq)]
enum GameResult {
    Win,
    Gaming,
    Lose,
}
</code></pre>
<p>Vamos primeiro entender o que é um enum:</p>
<blockquote>
<p>! Enum
Enum é um tipo de dado que representa um conjunto de valores que você quer relacionar no nosso caso estamos criando um conjunto relacionado com os estados que podemos representar
sobre a nossa condição de vitória "WIN" para dizer que o jogador venceu, "GAMING" para dizer que o jogador continua jogando, "LOSE" para dizer que o jogador perdeu, nosso caso essa
representação é um enum por isso precisamos passar o tipo de dado e o nome desse enum que no nosso caso é GameResult.
Alguns pontos importantes sobre enums:
* <em>Valores Variantes</em>: Em uma enumeração, você define os valores possíveis, chamados de "variantes". Cada variante representa um valor específico que o tipo de enumeração pode ter.
* <em>Tipos Personalizados</em>: Enums permitem que você crie tipos personalizados com valores limitados. Por exemplo, você pode criar uma enumeração para representar os dias da semana ou os estados de um jogo.
* <em>Padrão de Correspondência</em>: Enums são frequentemente usadas em combinação com o padrão de correspondência (match) para fazer escolhas com base no valor da enumeração. Isso torna as enums úteis para expressar a lógica condicional.
* <em>Segurança de Tipos</em>: Enums ajudam a garantir a segurança de tipos, pois o compilador verifica se todas as variantes são tratadas nos padrões de correspondência. Isso evita erros em tempo de execução.
* <em>Enumerações com Dados</em>: Enums podem ter dados associados a suas variantes. Isso permite que você armazene informações adicionais com uma variante. Por exemplo, uma enumeração de formas geométricas pode ter uma variante "Círculo" com um raio associado.
* <em>Enums Genéricas</em>: Enums podem ser genéricas, o que significa que você pode parametrizá-las com tipos de dados, tornando-as versáteis e reutilizáveis.</p>
</blockquote>
<p>Enuns podem ter uma chave e um valor como no exemplo abaixo:</p>
<pre><code class="language-rust">enum DiaDaSemana {
    Segunda(u32),
    Terca(u32),
    Quarta(u32),
    Quinta(u32),
    Sexta(u32),
    Sabado(u32),
    Domingo(u32),
}
</code></pre>
<p>Ou com multiplos valores para representar uma chave como abaixo:</p>
<pre><code class="language-rust">enum Cor {
    RGB(u8, u8, u8),
    Nome(String),
}
</code></pre>
<p>Há outras formas mas, vamos nos fixar em usa-lo apenas para que a chave e o valor sejam os mesmos que no caso é forma que criamos nosso enum sem passar nenhum tipo.</p>
<p>Agora usamos uma anotação nova que é o  `#[derive(...)]
A anotação #[derive(...)] em Rust é uma característica poderosa que gera automaticamente a implementação de certos traços (traits) para tipos de dados personalizados, como structs e enums. Isso ajuda a evitar a escrita repetitiva de código ao criar tipos de dados personalizados.</p>
<h4 id="trait">Trait</h4>
<p>Em Rust, um trait é como um contrato ou um conjunto de regras que um tipo de dado deve seguir. É uma maneira de definir comportamentos que tipos diferentes podem compartilhar.</p>
<p>Um trait especifica métodos que um tipo deve implementar, e outros tipos podem aderir a esse trait, implementando esses métodos. Isso permite que diferentes tipos de dados compartilhem funcionalidades comuns.</p>
<p>Por exemplo, você pode ter um trait chamado "Imprimível" que especifica um método imprimir, e várias estruturas diferentes podem implementar esse trait para que possam ser impressas de maneira semelhante, mesmo que sejam tipos diferentes. Isso torna o código mais genérico e reutilizável.</p>
<p>Traits usam conceito de polimorfismo.</p>
<p>Polimorfismo permite que objetos de diferentes tipos sejam tratados de maneira uniforme, permitindo o uso de métodos ou funções comuns a esses objetos, independentemente de seus tipos específicos.</p>
<h4 id="derive">Derive</h4>
<p>A atribuição #[derive] em Rust permite que os programadores gerem automaticamente a implementação de certos traços para suas estruturas de dados, enums ou uniões. Ele é usado para derivar a implementação de traços comuns, como Clone, Debug, Eq, PartialEq, Hash, entre outros, com base na estrutura da sua estrutura de dados.</p>
<p>Elas podem ser implementadas diretamente no código caso precise de um código mais complexo.</p>
<ul>
<li>Traits de comparação: Eq, PartialEq, Ord, PartialOrd.</li>
<li>Clone, para criar um novo objeto a partir de outro via copia.</li>
<li>Copy, para copiar o elemento ao invés de mover.</li>
<li>Hash, para computar um hast a partir &amp;T.</li>
<li>Default, para criar um objeto padrão do tipo especificado.</li>
<li>Debug, para formatar a partir de {:?} formatter.</li>
</ul>
<h4 id="vantagens-do-derive">Vantagens do Derive</h4>
<p>Facilita a implementação de traços comuns para tipos de dados personalizados.
Reduz a necessidade de escrever código manualmente para cada traço.
Permite que o compilador Rust gere automaticamente código de implementação eficiente para os traços derivados.
Simplifica a manutenção e o desenvolvimento de código, tornando-o mais conciso e legível.
Você pode criar um código com <code>#[derive]</code> usando <code>procedural macros</code></p>
<h4 id="procedural-macros">Procedural macros</h4>
<p>As macros procedurais são uma característica avançada do Rust que permite que os desenvolvedores escrevam código que manipula a representação de código Rust em tempo de compilação. Essas macros permitem que você escreva código que gera código, o que pode ser útil para automatizar tarefas repetitivas, criar DSLs específicas do domínio ou realizar transformações complexas no código Rust.</p>
<ul>
<li>Permitem a geração de código personalizado em tempo de compilação.</li>
<li>Podem ser usadas para automatizar tarefas tediosas ou repetitivas.</li>
<li>Permitem a criação de DSLs específicas do domínio para tornar o código mais expressivo e legível.</li>
<li>Podem ser usadas para realizar transformações complexas no código, como otimizações de desempenho ou análise estática avançada.</li>
</ul>
<h4 id="no-nosso-caso-vamos-passar-algumas-implementacoes-basicas-no-derive">No nosso caso vamos passar algumas implementações básicas no derive</h4>
<p>Debug <code>derive</code> (#[derive(Debug)]): Ao usar #[derive(Debug)] em uma estrutura ou enumeração, Rust gera automaticamente a implementação do Debug para esse tipo. O <code>derive</code> Debug permite que você formate o valor do tipo de forma legível por humanos quando você imprime um objeto desse tipo usando a função println!("{:?}", objeto). Isso é particularmente útil para fins de depuração, pois fornece informações detalhadas sobre o estado do objeto.</p>
<p>PartialEq derive (#[derive(PartialEq)]): Usando #[derive(PartialEq)], Rust gera a implementação do trait PartialEq para o tipo. O PartialEq permite que você compare objetos do tipo com operadores de igualdade (==) e desigualdade (!=). Isso significa que você pode verificar se dois objetos são iguais ou diferentes com facilidade, simplificando a lógica de comparação.</p>
<p>Certo agora vamos ajustar o teste para nossa função:</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 42;

    //Act
    ==let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);==

    //Assert
    ==assert_eq!(result, Ok(GameResult::Win));==
    assert_eq!(pontuacao, 1000)
}
</code></pre>
<p>Ali colocamos uma variavel para receber o retorno da nossa função chamado result e também verificamos se essa variavél result retorna no seu ResultSet o valor do enum GameResult
como Win que é o valor do enum que criamos.
Agora vamos rodar o teste.</p>
<pre><code class="language-bash">cargo test
</code></pre>
<p>Com o seguinte resultado</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:89:24
   |
89 |     assert_eq!(result, Ok(GameResult::Win));
   |                        ^^^^^^^^^^^^^^^^^^^ expected `()`, found `Result&lt;GameResult, _&gt;`
   |
   = note: expected unit type `()`
                   found enum `Result&lt;GameResult, _&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot; test) due to previous error
</code></pre>
<p>Isso ocorreu por que estamos voltando um ResultSet vazio e ele esperava um ResultSet com um GameResult, então vamos mudar o retorno da nossa função.</p>
<pre><code class="language-rust">...
fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {
...
</code></pre>
<p>Aqui falamos que o result tem o OK como  um <code>GameResult</code> e o Erro também como um <code>GameResult</code> vamos rodar o teste.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:59:5
   |
59 |     println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;GameResult, ...&gt;`, found `()`
   |
   = note:   expected enum `Result&lt;GameResult, GameResult&gt;`
           found unit type `()`
   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin &quot;guessing_game&quot; test) due to previous error

</code></pre>
<p>Aqui fala que o problema é que temos um print no final da função vamos colocar no final um <code>GameResult::Gaming</code> para mostrar a condição que o jogo ainda não terminou.</p>
<pre><code class="language-rust">fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero);
    ==Ok(GameResult::Gaming)==
}
</code></pre>
<p>Aqui colocamos de maneira explicita no final ele vai retornar um result do tipo <code>OK</code> com o valor <em>Gaming</em> do nosso enum.
Vale atentar que precisamos agora colocar um  ";" no nosso print.
Agora vamos rodar os testes:</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: variant `Lose` is never constructed
 --&gt; src/main.rs:7:5
  |
4 | enum GameResult {
  |      ---------- variant in this enum
...
7 |     Lose,
  |     ^^^^
  |
  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
  = note: `#[warn(dead_code)]` on by default

warning: unused `Result` that must be used
  --&gt; src/main.rs:51:5
   |
51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: unused `Result` that must be used
  --&gt; src/main.rs:73:5
   |
73 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
   |
73 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 3 warnings
    Finished test [unoptimized + debuginfo] target(s) in 0.15s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 2 tests
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... FAILED

failures:

---- test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao stdout ----
A sua pontuação foi 1000, e o número era 42
<mark class="critic">
thread 'test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao' panicked at src/main.rs:90:5:
assertion `left == right` failed
  left: Ok(Gaming)
 right: Ok(Win)
</mark>
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace



failures:
    test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--bin guessing_game`
</code></pre>
<p>Aqui vamos ter alguns warnings, mas no ponto de destaque mostra ainha que deu erro, no meu caso ainha 90 e mostra que ele espearava um <code>Ok(Win)</code> mas, recebeu um <code>Ok(Gaming)</code>.
Então finalmente  podemos agora colocar nosso bloco de código que determina que o usuário venceu que nesse caso será um <em>if</em>.</p>
<pre><code class="language-rust">fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {
    <mark class="critic">
    if chute == numero {
        return Ok(GameResult::Win)
    }
    </mark>
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    println!(&quot;A sua pontuação foi {}, e o número era {}&quot;, pontuacao, numero);
    Ok(GameResult::Gaming)
}
</code></pre>
<p>Aqui comparamos que o chute é igual ao número e caso essa comparação seja verdadeira precisamos colocar a palavra chave return com o  <code>Ok(GameResult::Win)</code> pois temos mais código
que vai ser executado abaixo dele então estamos forçando um retorno prematuro.</p>
<p>Agora vamos rodar os testes.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: variant `Lose` is never constructed
 --&gt; src/main.rs:7:5
  |
4 | enum GameResult {
  |      ---------- variant in this enum
...
7 |     Lose,
  |     ^^^^
  |
  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
  = note: `#[warn(dead_code)]` on by default

warning: unused `Result` that must be used
  --&gt; src/main.rs:51:5
   |
51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: unused `Result` that must be used
  --&gt; src/main.rs:76:5
   |
76 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
   |
76 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 3 warnings
    Finished test [unoptimized + debuginfo] target(s) in 0.14s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 2 tests
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Ainda temos alguns warnings mas, nossos testes voltaram a passar.</p>
<h2 id="adicionando-condicao-de-derrota">Adicionando condição de derrota</h2>
<p>Bom agora vamos criar uma condição pra nossa função registrar a derrota. Mas, primeiro vamos criar o teste.</p>
<pre><code class="language-rust">#[test]
fn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    == let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==

    // Assert
    assert_eq!(pontuacao, 900)
}

#[test]
fn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 42;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Win));
    assert_eq!(pontuacao, 1000)
}

<mark class="critic">
#[test]
fn test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo() {
    // Arrange
    let mut pontuacao: u16 = 100;
    let numero: u8 = 42;
    let chute: u8 = 1;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Lose));
    assert_eq!(pontuacao, 0)
}
</mark>
</code></pre>
<p>Nesse teste diminuimos a pontuação e erramos pra baixo e ele deve voltar o rusult como Lose e a pontuação como 0. Então vamos testar.</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:54:5
   |
54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.17s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 3 tests
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok
test test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... FAILED

failures:

---- test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo stdout ----
<mark class="critic">
A sua pontuação foi 0, e o número era 42
thread 'test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo' panicked at src/main.rs:119:5:
assertion `left == right` failed
  left: Ok(Gaming)
 right: Ok(Lose)
</mark>
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--bin guessing_game`
</code></pre>
<p>Bom tivemos um erro por que voltou <em>Gaming</em> ao invés de <em>Lose</em>, para arrumarmos isso vamos ajustar nossa função.</p>
<pre><code class="language-rust">fn check_win_coditition(
    pontuacao: &amp;mut u16,
    numero: &amp;u8,
    chute: &amp;u8,
) -&gt; Result&lt;GameResult, GameResult&gt; {
    if chute == numero {
        return Ok(GameResult::Win);
    }
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    <mark class="critic">
    if *pontuacao &lt;= 0 {
        return Ok(GameResult::Lose);
    }
    </mark>
    println!(
        &quot;A sua pontuação foi {}, e o número era {}&quot;,
        pontuacao, numero
    );
    Ok(GameResult::Gaming)
}

</code></pre>
<p>Aqui adicionamos mais uma condição para que se a pontuação for menor ou igual a 0 retornamos <code>GameResult::Lose</code> pra função chamadora, agora vamos testar novamente.</p>
<pre><code class="language-rust">❮ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:54:5
   |
54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 3 tests
test test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Perfeito agora nosso teste passou mas, vamos criar outro teste passando nosso chute sendo um valor maior que o número alvo.</p>
<pre><code class="language-rust">#[test]
== fn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() { ==
    // Arrange
    let mut pontuacao: u16 = 100;
    let numero: u8 = 42;
    let chute: u8 = 1;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Lose));
    assert_eq!(pontuacao, 0)
}
<mark class="critic">
#[test]
fn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {
    // Arrange
    let mut pontuacao: u16 = 100;
    let numero: u8 = 42;
    let chute: u8 = 100;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Lose));
    assert_eq!(pontuacao, 0)
}
</mark>
</code></pre>
<p>Aqui renomeamos o nosso teste anterior pra explicitar que estamos chutando um número baixo e criamos outro explicitando que estamos chutando um número altoi, agora rodando os testes teremos uma falha.</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:54:5
   |
54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.14s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 4 tests
test test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... FAILED
test test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok

failures:

---- test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo stdout ----
<mark class="critic">
A sua pontuação foi 100, e o número era 42
thread 'test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo' panicked at src/main.rs:137:5:
assertion `left == right` failed
  left: Ok(Gaming)
 right: Ok(Lose)
</mark>
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo

test result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--bin guessing_game`

</code></pre>
<p>Como podemos ver ele voltou <em>Gaming</em> ao invés de <em>Lose</em> isso por que não implementamos a condição pra que o valor maior decremente então vamos cria-la.</p>
<pre><code class="language-rust"> check_win_coditition(
    pontuacao: &amp;mut u16,
    numero: &amp;u8,
    chute: &amp;u8,
) -&gt; Result&lt;GameResult, GameResult&gt; {
    <mark class="critic">
    if chute &lt; numero {
        *pontuacao -= 100;
    }
    if chute &gt; numero {
        *pontuacao -= 100;
    }
    </mark>
    if chute == numero {
        return Ok(GameResult::Win);
    }
    if *pontuacao &lt;= 0 {
        return Ok(GameResult::Lose);
    }
    println!(
        &quot;A sua pontuação foi {}, e o número era {}&quot;,
        pontuacao, numero
    );
    Ok(GameResult::Gaming)
}
</code></pre>
<p>Aqui colocamos nossa condição de decrementar a pontuação com um erro como a primeira coisa a ser verificada, para evitar qualquer problema de ser decrementado após verificar a condição de vitória, assim adicionamos mais um <em>if</em> no nosso código e podemos rodar o teste para verificar se está passando.</p>
<pre><code class="language-bash">❯ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:54:5
   |
54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);
   |     +++++++

warning: `guessing_game` (bin &quot;guessing_game&quot; test) generated 1 warning
    Finished test [unoptimized + debuginfo] target(s) in 0.13s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 4 tests
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok
test test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Bom agora conseguimos ter a condição de derrota no nosso jogo.</p>
<h2 id="criando-mais-testes">Criando mais testes</h2>
<p>Bom agora que temos nossa condição para decrementar a pontuação quando erramos pra cima ou pra baixo, precisamos ajustar nosso teste <em>test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral</em> para receber a condição <code>GameResult::Gaming</code> e também criar um novo teste para explicitar o chute pra cima e o outro pra baixo.</p>
<pre><code class="language-rust"> -&gt; () {
    println!(&quot;Por favor digite o número que você acredita ser&quot;);
    let mut pontuacao: u16 = 1000;
    let numero_alvo: u8 = 42;
    let mut chute = String::new();
    io::stdin()
        .read_line(&amp;mut chute)
        .expect(&quot;Erro ao receber o número&quot;);

    let chute: u8 = match chute.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; {
            println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
            0
        }
    };
    ==let _result = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute); ==
    println!(
        &quot;A sua pontuação foi {}, e o número era {}&quot;,
        pontuacao, numero_alvo
    );
}

...
#[test]
<mark class="critic"> fn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() { </mark>
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    == let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==

    // Assert
    assert_eq!(result, Ok(GameResult::Gaming));
    assert_eq!(pontuacao, 900)
}

<mark class="critic">
#[test]
fn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 100;

    // Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(result, Ok(GameResult::Gaming));
    assert_eq!(pontuacao, 900)
}
</mark>
</code></pre>
<p>Aqui mudamos o nome do teste anterior e criamos um novo além de adiconar o result para verificação e também pra nossa função game, o agora se rodarmos os testes os warnings vão desaparecer.</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.12s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 5 tests
test test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok
test test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h2 id="melhorando-nossa-funcao-de-condicao-e-ajustando-a-funcao-game">Melhorando nossa função de condição e ajustando a função game.</h2>
<p>Bom poderiamos agora criar testes de integração pra nossa função game, mas vamos trabalhar isso mais a frente, agora vamos melhorar nossa função game, não importa se acertamos ou ▍erramos nós voltamos ao menu principal, então precisamos só voltar pro loop do menu quando perdemos ou ganharmos o jogo pra isso vamos criar um novo loop no nosso jogo.</p>
<pre><code class="language-rust"><mark class="critic">
fn game() -&gt; () {
    let mut pontuacao: u16 = 1000;
    let numero_alvo: u8 = 42;
    loop {
        println!(&quot;Por favor digite o número que você acredita ser&quot;);
        let mut chute = String::new();
        io::stdin()
            .read_line(&amp;mut chute)
            .expect(&quot;Erro ao receber o número&quot;);

        let chute: u8 = match chute.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; {
                println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
                0
            }
        };
        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {
            Ok(result) =&gt; {
                if result == GameResult::Win {
                    println!(&quot;Parabéns você venceu! Sua pontuação foi {}&quot;, pontuacao);
                    break;
                } else if result == GameResult::Lose {
                    println!(&quot;Que pena você perdeu!&quot;);
                    break;
                }
            }
            Err(_) =&gt; {
                println!(&quot;Ocorreu um erro e o jogo será reiniciado!&quot;);
                break;
            }
        };
        println!(&quot;A sua pontuação está em {}&quot;, pontuacao);
    }
}
</mark>

fn check_win_coditition(
    pontuacao: &amp;mut u16,
    numero: &amp;u8,
    chute: &amp;u8,
) -&gt; Result&lt;GameResult, GameResult&gt; {
    if chute &lt; numero {
        == println!(&quot;O número é maior!&quot;); ==
        *pontuacao -= 100;
    }
    if chute &gt; numero {
        == println!(&quot;O número é menor!&quot;); ==
        *pontuacao -= 100;
    }
    if chute == numero {
        return Ok(GameResult::Win);
    }
    if *pontuacao &lt;= 0 {
        return Ok(GameResult::Lose);
    }
    <mark class="critic"> </mark>
    Ok(GameResult::Gaming)
}
</code></pre>
<p>Aqui criamos um loop dentro da nossa função game e só deixamos o número alvo e a pontuação fora pois sempre que iniciar um jogo vamos reiniciar o placar. Nossa função <em>check_win_condition</em> nos retorna um <code>ResultGame</code>, por conta disso podemos fazer um match para caso entre na condição de vitória ou derrota o jogo é encerrado e volta no menu, também caso tenhamos algum erro de execução ele vai retornar o jogo pro menu.
Também colocamos uma dica pro jogador saber se o número é maior ou menor para facilitar que ele.</p>
<p>Para ter certeza que não quebramos nada vamos rodar nossos testes.</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.16s
     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)

running 5 tests
test test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Com isso agora já temos um jogo bem jogável.</p>
<h2 id="colocando-aleatoriedade-no-nosso-jogo">Colocando aleatoriedade no nosso jogo</h2>
<p>Nosso jogo está bem interessante mas, nesse momento nosso número alvo está fixo e queremos que ele seja aleatório para isso vamos precisar de uma biblioteca que não está no padrão da linguagem rust que é o rand.</p>
<h3 id="introducao-aos-crates">Introdução aos crates</h3>
<p>Rust é uma linguagem de programação que ganhou popularidade devido à sua segurança, desempenho e concorrência. Um dos conceitos fundamentais no ecossistema Rust é o de "crates". Vamos explorar o que são os crates em Rust e como eles funcionam para facilitar o desenvolvimento de software.</p>
<h4 id="o-que-sao-crates">O Que São Crates?</h4>
<p>Em Rust, um "crate" é a unidade de compilação de código. Um crate pode ser uma biblioteca, um aplicativo, um binário ou até mesmo um subconjunto menor de código. A ideia por trás dos crates é promover a modularidade e a reutilização de código, permitindo que você organize seu projeto de forma limpa e eficaz.</p>
<h4 id="tipos-de-crates">Tipos de Crates</h4>
<p>Existem dois tipos principais de crates em Rust: crates binários e crates de biblioteca.</p>
<ul>
<li>
<p><em>Crates Binários:</em> Esses são os crates que criam um executável quando compilados. Eles são destinados a iniciar um programa e geralmente contêm a função main(). Um exemplo de crate binário é um aplicativo de linha de comando ou uma aplicação de servidor.</p>
</li>
<li>
<p><em>Crates de Biblioteca:</em> Esses crates não têm uma função main() e são destinados a serem usados como bibliotecas por outros crates. Os crates de biblioteca podem conter funções, estruturas, enums e muito mais que podem ser usados por outros desenvolvedores para criar seus programas.</p>
</li>
</ul>
<h4 id="estrutura-de-diretorios-de-um-crate">Estrutura de Diretórios de um Crate</h4>
<p>Dentro do diretório do seu crate, você encontrará uma estrutura típica de diretórios:</p>
<ul>
<li>src: Contém o código-fonte do seu crate.</li>
<li>Cargo.toml: Arquivo de configuração do seu crate, onde você especifica dependências e outras informações.</li>
<li>tests: Diretório para escrever testes para o seu crate.</li>
<li>examples: Diretório para incluir exemplos de código para demonstrar o uso do seu crate.</li>
</ul>
<h4 id="gerenciando-dependencias">Gerenciando Dependências</h4>
<p>Rust usa o gerenciador de pacotes Cargo para gerenciar dependências. Você pode especificar as dependências necessárias no arquivo Cargo.toml. Quando você compila seu crate, o Cargo se encarrega de baixar e compilar todas as dependências automaticamente.</p>
<h4 id="usando-crates-de-terceiros">Usando Crates de Terceiros</h4>
<p>Um dos principais benefícios do ecossistema Rust é a facilidade de uso de crates de terceiros. Você pode pesquisar e encontrar uma vasta coleção de crates de alta qualidade no Rust's package registry, crates.io. Para adicionar uma dependência a um crate, basta adicionar a linha apropriada no seu arquivo Cargo.toml.</p>
<pre><code class="language-toml">
[dependencies]
nome_do_pacote = &quot;versao&quot;
</code></pre>
<p>Após adicionar a dependência, execute cargo build para baixar e compilar os crates necessários.</p>
<p>Também podemos instalar diratamente na linha de comando como abaixo:</p>
<pre><code class="language-bash">cargo add lib
</code></pre>
<p>Crates são um componente fundamental do ecossistema Rust, permitindo que você desenvolva, compartilhe e reutilize código de maneira eficaz. A modularidade e a facilidade de gerenciamento de dependências tornam Rust uma linguagem poderosa para o desenvolvimento de software. Compreender o sistema de crates é essencial para qualquer desenvolvedor Rust, pois é uma parte integrante do processo de construção de aplicações robustas e seguras.</p>
<p>Agora vamos entrar no site do <a href="https://crates.io">crates.io</a> vamos buscar a biblioteca rand, aqui no crates.io podemos ver mais sobre a biblioteca, no nosso caso essa biblioteca serve para gerar números aleatório.
Vamos instala-la.</p>
<pre><code class="language-bash">cargo add rand
</code></pre>
<p>Agora vamos implementa-la no nosso código.</p>
<pre><code class="language-rust">== use rand::{thread_rng, Rng}; ==
use std::io;

#[derive(Debug, PartialEq)]
enum GameResult {
    Win,
    Gaming,
    Lose,
}

fn main() {
    loop {
        println!(&quot;Bem vindo ao jogo da adivinhação escolha uma das opções abaixo&quot;);
        println!(&quot;i - Iniciar o jogo&quot;);
        println!(&quot;q - Fechar o jogo&quot;);

        let mut escolha_str = String::new();
        io::stdin()
            .read_line(&amp;mut escolha_str)
            .expect(&quot;Erro ao receber sua escolha&quot;);

        match escolha_str.trim().to_lowercase().as_str() {
            &quot;i&quot; =&gt; {
                game();
                continue;
            }
            &quot;q&quot; =&gt; {
                println!(&quot;Obrigado por jogar&quot;);
                break;
            }
            _ =&gt; {
                println!(&quot;Escolha inválida. Tente novamente.&quot;);
                continue;
            }
        };
    }
}

fn game() -&gt; () {
    let mut pontuacao: u16 = 1000;
    == let numero_alvo: u8 = thread_rng().gen_range(1..100); ==
    loop {
        println!(&quot;Por favor digite o número que você acredita ser&quot;);
        let mut chute = String::new();
        io::stdin()
            .read_line(&amp;mut chute)
            .expect(&quot;Erro ao receber o número&quot;);

        let chute: u8 = match chute.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; {
                println!(&quot;Valor não é válido ou não está entre 0 e 255&quot;);
                0
            }
        };
        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {
            Ok(result) =&gt; {
                if result == GameResult::Win {
                    println!(&quot;Parabéns você venceu! Sua pontuação foi {}&quot;, pontuacao);
                    break;
                } else if result == GameResult::Lose {
                    println!(&quot;Que pena você perdeu!&quot;);
                    break;
                }
            }
            Err(_) =&gt; {
                println!(&quot;Ocorreu um erro e o jogo será reiniciado!&quot;);
                break;
            }
        };
        println!(&quot;A sua pontuação está em {}&quot;, pontuacao);
    }
}

fn check_win_coditition(
    pontuacao: &amp;mut u16,
    numero: &amp;u8,
    chute: &amp;u8,
) -&gt; Result&lt;GameResult, GameResult&gt; {
    if chute &lt; numero {
        println!(&quot;O número é maior!&quot;);
        *pontuacao -= 100;
    }
    if chute &gt; numero {
        println!(&quot;O número é menor!&quot;);
        *pontuacao -= 100;
    }
    if chute == numero {
        return Ok(GameResult::Win);
    }
    if *pontuacao &lt;= 0 {
        return Ok(GameResult::Lose);
    }
    Ok(GameResult::Gaming)
}

#[test]
fn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 1;

    // Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(result, Ok(GameResult::Gaming));
    assert_eq!(pontuacao, 900)
}

#[test]
fn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 100;

    // Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    // Assert
    assert_eq!(result, Ok(GameResult::Gaming));
    assert_eq!(pontuacao, 900)
}

#[test]
fn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {
    // Arrange
    let mut pontuacao: u16 = 1000;
    let numero: u8 = 42;
    let chute: u8 = 42;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Win));
    assert_eq!(pontuacao, 1000)
}

#[test]
fn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() {
    // Arrange
    let mut pontuacao: u16 = 100;
    let numero: u8 = 42;
    let chute: u8 = 1;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Lose));
    assert_eq!(pontuacao, 0)
}

#[test]
fn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {
    // Arrange
    let mut pontuacao: u16 = 100;
    let numero: u8 = 42;
    let chute: u8 = 100;

    //Act
    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);

    //Asert
    assert_eq!(result, Ok(GameResult::Lose));
    assert_eq!(pontuacao, 0)
}
</code></pre>
<p>No caso do rand gerar o número que queremos precisamos usar a função <em>gen_range</em> olhando na documentação precisamos importar <code>use rand::{thread_rng, Rng};</code> que são as funções de base e simplemente removemos o número fixo por essa função na declaração da variável.</p>
<pre><code class="language-rust">    let numero_alvo: u8 = thread_rng().gen_range(1..100);
</code></pre>
<p>Ai colocamos que queremos gerar um valor entre 1 e 100 e agora vamos rodar os testes para ver se nossa alteração quebrou alguma coisa.</p>
<pre><code class="language-bash">➜ cargo test
   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.15s
     Running unittests src/main.rs (target/debug/deps/guessing_game-1e17f810f8775677)

running 5 tests
test test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok
test test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok
test test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok
test test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Certo tudo funcionando.</p>
<h4 id="usando-o-cargo-fmt">Usando o cargo fmt</h4>
<p>Nesse módulo eu usei o editor helix e nele eu configurei para ajustar a formatação do meu código automaticamente, mas, há um comando no <code>cargo</code> que é possível fazer a formatação do seu código que é o fmt podemos roda-lo com o comando abaixo:</p>
<pre><code class="language-bash">cargo fmt
</code></pre>
<p>Com isso pode ajustar nosso código pra já trabalhar com o <code>clippy</code>.</p>
<h4 id="usando-clippy">Usando Clippy</h4>
<p>Clippy é uma ferramenta de análise estática para o Rust, desenvolvida pela comunidade. Ele fornece sugestões e avisos sobre possíveis problemas de código, seguindo as melhores práticas e convenções da linguagem Rust.</p>
<p>Para rodar o cargo clippy é só executar o comando abaixo:</p>
<pre><code class="language-rust">cargo clippy
</code></pre>
<p>Vamos ter uma saída parecida com essa:</p>
<pre><code class="language-bash">guessing_game on  main [?] is 📦 v0.1.0 via 🦀 v1.76.0 on ☁️   (eu-west-2)
➜ cargo clippy
    Checking guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)
warning: unneeded unit return type
  --&gt; src/main.rs:39:10
   |
39 | fn game() -&gt; () {
   |          ^^^^^^ help: remove the `-&gt; ()`
   |
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit
   = note: `#[warn(clippy::unused_unit)]` on by default

error: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false
  --&gt; src/main.rs:91:8
   |
91 |     if *pontuacao &lt;= 0 {
   |        ^^^^^^^^^^^^^^^
   |
   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons
   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
error: could not compile `guessing_game` (bin &quot;guessing_game&quot;) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Primeiro ponto vamos ver esse warning:</p>
<pre><code class="language-bash">warning: unneeded unit return type
  --&gt; src/main.rs:39:10
   |
39 | fn game() -&gt; () {
   |          ^^^^^^ help: remove the `-&gt; ()`
   |
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit
   = note: `#[warn(clippy::unused_unit)]` on by default
</code></pre>
<p>Aqui colocamos nossa saída como uma option vazia <code>-&gt; ()</code> então podemos remover conforme ele está indicando, é importnte ver que também ele coloca uma documentação do clippy informando por que é uma má prática. Caso você queira ignorar o erro você pode colocar a anotação que ele recomenda que no caso é <code>#[warn(clippy::unused_unit)]</code>.</p>
<p>Agora vamos ver o outro warning:</p>
<pre><code class="language-bash">error: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false
  --&gt; src/main.rs:91:8
   |
91 |     if *pontuacao &lt;= 0 {
   |        ^^^^^^^^^^^^^^^
   |
   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons
   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default
</code></pre>
<p>Esse warning fala que estamos querendo ver um valor menor que zero, porém estamos usando na pontuação um tipo <code>u</code> que não aceita sinal, temos duas formas de resolver isso, mudar nosso prametro pra o tipo <code>i</code> que aceita sinal ou ainda como nossa pontuação não deveria nunca ser menor que zero, podemos apenas seguir a instrução do clippy e deixar o sinal de igualdade <code>==</code>.</p>
<p>Rodando agora o clippy novamente temos a saída abaixo:</p>
<pre><code class="language-bash">✦ ➜ cargo clippy
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</code></pre>
<p>Quer dizer que nosso código está sem erros no momento.</p>
<h2 id="update-rust">Update Rust</h2>
<p>O rust vem sendo atualizado com o tempo, no caso do curso começamos com a versão 1.73 então vamos atualizar o nosso código agora simplemente precisamos rodar o comando abaixo:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>Com isso agora vamos pra ultima versão do rust disponível.</p>
<h2 id="conclusao">Conclusão</h2>
<p>Com esse jogo vimos como criar uma função em rust, criar testes para essa função usando a suite nativa de testes do rust, mais algumas funções de manipulação de strings, como
funciona o conceito de borrow and ownership, como funciona o gerenciamento de memória do rust.</p>
<h2 id="exercicios-sugeridos">Exercicíos sugeridos</h2>
<p>Exercício 1: Jogo de Perguntas e Respostas</p>
<p>Crie um jogo de perguntas e respostas em que o jogador deve responder a várias perguntas. O jogo deve incluir as seguintes funcionalidades:</p>
<div class="highlight"><pre><span></span><code>O programa deve conter um conjunto de perguntas e respostas.
O jogador deve receber uma pergunta e fornecer uma resposta.
O programa deve verificar se a resposta está correta e atualizar a pontuação do jogador.
Use funções para organizar o código, armazenar perguntas e respostas, e verificar as respostas do jogador.
Escreva testes para garantir que o jogo funcione corretamente.
</code></pre></div>
<p>Exercício 2: Jogo de Aventura com História Interativa</p>
<p>Crie um jogo de aventura com uma história interativa em que o jogador toma decisões que afetam o desenrolar da história. O jogo deve incluir as seguintes funcionalidades:</p>
<div class="highlight"><pre><span></span><code>Use enumerações para representar as diferentes escolhas e eventos na história.
Use variáveis mutáveis para rastrear o progresso da história e as decisões do jogador.
Use loops para permitir que o jogador faça escolhas ao longo da história.
Use if, if else e match para verificar as escolhas do jogador e os resultados na história.
Use a macro println! para exibir a narrativa da aventura.
</code></pre></div>
<p>Exercício 3: Jogo da Forca</p>
<p>Crie um jogo multiplayer alternativo da forca em que o jogador deve adivinhar uma palavra oculta. O jogo deve incluir as seguintes funcionalidades:</p>
<div class="highlight"><pre><span></span><code>O programa deve receber uma palavra aleatória de um jogador e uma dica.
O outro jogador deve fazer tentativas para adivinhar a palavra escrevendo ela inteira.
O programa deve mostrar uma representação de quantas tentativas faltam.
O jogo deve ser encerrado quando o jogador adivinhar a palavra corretamente ou após um número máximo de tentativas.
Use funções para organizar o código.
Escreva testes para garantir que o jogo funcione corretamente.
</code></pre></div>
<p>Exercício 4: Simulador de Compras com Crate Rust Money</p>
<p>Crie um simulador de compras em que o jogador tem um orçamento limitado e deve fazer compras. Use o crate rust-money para representar valores monetários. O jogo deve incluir as seguintes funcionalidades:</p>
<div class="highlight"><pre><span></span><code>Instale o crate rust-money para lidar com valores monetários.
Use variáveis mutáveis para rastrear o orçamento do jogador e o custo dos itens.
Use loops para permitir que o jogador faça várias compras.
Use if e match para verificar se o jogador pode pagar por um item e atualizar o orçamento.
Use a macro println! para exibir informações sobre as compras.
</code></pre></div>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">April 17, 2024</span>
      
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.220ee61c.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>