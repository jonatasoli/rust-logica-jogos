{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao curso Rust l\u00f3gica com jogos","text":"<p>Esse material est\u00e1 em desenvolvimento ent\u00e3o sugest\u00f5es s\u00e3o sempre bem-vindas.</p>"},{"location":"#o-que-e-rust","title":"O que \u00e9 Rust","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi projetado para oferecer uma experi\u00eancia pr\u00e1tica no ensiono da linguagem Rust, usando desenvolvimento de jogos em ASCII e textual. Durante o curso, o objetivo principal \u00e9 proporcionar aos participantes um entendimento abrangente dos conceitos fundamentais da linguagem Rust, juntamente com a aplica\u00e7\u00e3o pr\u00e1tica desses conhecimentos na cria\u00e7\u00e3o de jogos mesmo n\u00e3o sendo o foco do curso ensinar a fazer jogos profissionalmente.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Durante esse curso voc\u00ea vai aprender o b\u00e1sico de Rust como fluxos condicionais, repeti\u00e7\u00e3o, uso de fun\u00e7\u00f5es, escopo de v\u00e1riaveis at\u00e9 t\u00f3picos avan\u00e7ados como Threads e concorr\u00eancia.</p>"},{"location":"#esse-curso-e-gratuito","title":"Esse curso \u00e9 gratuito?","text":"<p>Essa wiki \u00e9 gratuita assim como os exerc\u00edcios, por\u00e9m ser\u00e1 craido um curso em v\u00eddeo e esse ser\u00e1 pago. E caso o estudando desejar poder\u00e1 me ajudar tamb\u00e9m atrav\u00e9s do github sponsor o valor arrecadado vai me ajudar a me manter durante a produ\u00e7\u00e3o do curso.</p>"},{"location":"#onde-ele-sera-disponibilizado","title":"Onde ele ser\u00e1 disponibilizado?","text":"<p>O curso vai ser disponibilizado atrav\u00e9s da plataforma Udemy.</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9 requisitos","text":"<p>Para fazer esse curso \u00e9 importante ter no\u00e7\u00f5es b\u00e1sicas de inform\u00e1tica como: - Saber usar um navegador - Saber entrar num prompt de comando seja no Windows, Mac ou Linux - J\u00e1 ter conhecimento em outra linguagem \u00e9 desej\u00e1vel mas, n\u00e3o \u00e9 essencial pois vamos trabalhar do zero e contruir projetos</p> <p>Obs: O curso ser\u00e1 desenvolvido totalmente em linux, caso queira usar Windows \u00e9 interessante usar WSL2 devo colocar no curso posteriormente um tutorial para configurar o ubuntu com wsl2 mas, por hora recomendo verem o v\u00eddeo do F\u00e1bio Akita criando um ambiente.</p>"},{"location":"#ementa","title":"Ementa","text":""},{"location":"#apos-esse-curso-vou-estar-capacitado-a-fazer-jogos-profissionalmente","title":"Ap\u00f3s esse curso vou estar capacitado a fazer jogos profissionalmente?","text":"<p>N\u00e3o, mesmo que seja abordados alguns principios do desenvolvimento de jogos, esse curso n\u00e3o tem como objetivo ajudar o aluno a fazer jogos profissionais, nesse caso o instrutor ainda recomenda buscar outros materiais para se aprofundar no tema.</p>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"Quem vai ministrar essas aulas?","text":"<p>Sou um profissional com 17 anos de experi\u00eancia no desenvolvimento de sistemas e websites, meu foco principal est\u00e1 sistemas web. Comecei a aprender Rust em 2020 e estou trabalhando no meu primeiro jogo profissionalmente.</p>"},{"location":"#o-que-voce-precisa-para-acompanhar-o-curso","title":"O que voc\u00ea precisa para acompanhar o curso?","text":"<ul> <li>Editor de texto ou IDE: Recomendo qualquer editor que tenha a capacidade de identicar c\u00f3digo Rust, durante os v\u00eddeos vou usar o nvim mas, voc\u00ea pode usar   qual quiser, se voc\u00ea for iniciante recomendo usar o vscodium.</li> </ul>"},{"location":"#repositorio","title":"Reposit\u00f3rio","text":"<p>Todas os exemplos criados para o curso assim como exercic\u00edos estar\u00e3o no reposit\u00f3rio abaixo.</p>"},{"location":"1_0_introducao/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"1_1_jogo_floresta_misteriosa/","title":"Floresta Misteriosa","text":""},{"location":"1_2_jogo_da_adivinhacao/","title":"Jogo da adivinha\u00e7\u00e3o Raio-x","text":"<p>Vamos come\u00e7ar um novo jogo que \u00e9 o jogo da adivinha\u00e7\u00e3o \"Guessing Game\" o objetivo desse jogo \u00e9 identificar um n\u00famero escolhido aleat\u00f3riamente. O jogo inicia com 1000 pontos para o jogador e cada vez que ele erra o n\u00famero \u00e9 subtraido 100 pontos do placar dele quando o placar chegar a zero o jogo \u00e9 encerrado.</p>"},{"location":"1_2_jogo_da_adivinhacao/#regras","title":"Regras","text":"<p>As regras s\u00e3o as seguintes: - Ao iniciar o jogo o jogador tem a escolha de come\u00e7ar o jogo ou sair do jogo - O jogador vai escolher um n\u00famero entre 0 a 100 - Caso o jogador escolha um n\u00famero fora desse intervalo ser\u00e1 solicitado para ele escolher novamente - Caso o jogador escolha uma letra ou um caractere especial tamb\u00e9m ser\u00e1 solicitado para escolher o novamente - Caso o jogador escolha um n\u00famero menor que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi menor - Caso o jogador escolha um n\u00famero maior que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi maior - Casa escolha que n\u00e3o seja o n\u00famero escolhido pelo jogo dever\u00e1 marcar um contador de erro - O jogador come\u00e7a com 1000 pontos caso aconte\u00e7a um erro cada contador de erro deve subtrair 100 pontos - Caso o jogador perca o jogo dever\u00e1 ter um menu informando pra fechar o jogo ou jogar novamente - Caso o jogador ven\u00e7a dever\u00e1 mostrar o placar que ele obteve o a op\u00e7\u00e3o de sair do jogo ou tentar novamente.</p>"},{"location":"1_2_jogo_da_adivinhacao/#comecando-o-projeto","title":"Come\u00e7ando o projeto","text":"<p>Vamos iniciar um novo projeto em nossa pasta projects</p> <pre><code>cd ~/projects\ncargo new guessing_game\n</code></pre> <p>Agora para iniciar o nosso jogo vamos fazer o loop que j\u00e1 conhecemos e vamos criar o menu recebendo o input do usu\u00e1rio e imprimir na tela o valor escolhido e caso ele escolha iniciar vamos imprimir que o jogo come\u00e7ou e caso ele sair n\u00f3s vamos encerrar o jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        println!(\"A sua escolha foi {}\", escolha_str);\n        break;\n    }\n\n}\n</code></pre> <p>Aqui vamos mudar ao inv\u00e9s de usar n\u00fameros para op\u00e7\u00f5es vamos usar letras pois vamos precisar fazer um tratamento especial no c\u00f3digo, estamos usando a captura que estavamos fazendo anteriormente fazendo um println apenas no item escolhido, no final vamos dar um break apenas pra encerrar o loop. Agora se rodarmos o c\u00f3digo vamos ver que ele pegou a escolha que gostariamos e printou na tela.</p> <pre><code>cargo run\n</code></pre> <p>Certo agora vamos fazer um match com nossa escolha str s\u00f3 que como estamos usando letras vou for\u00e7ar que o que venha de letras senha minuscula ou maiuscula que ele force sempre a ser min\u00fasculo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n        };\n==\n\n    }\n}\n</code></pre> <p>Criamos a nossa linha como <code>match escolha.str.trim().to_lowercase()</code> usando a fun\u00e7\u00e3o <code>trim()</code> para removermos espa\u00e7os em branco e agora usamos uma nova fun\u00e7\u00e3o chamada <code>to_lowercase()</code> que vai transformar nossa string caso tenha letras maiusculas em min\u00fasculas. Outra fun\u00e7\u00e3o que usamomos foi o <code>as_str</code> pois quando usamos o <code>trim</code> e o <code>to_lowercase</code> eles voltam um &amp;str que \u00e9 um tipo diferente do String ent\u00e3o pra comparar vamos precisar reconverter novamente para String e ai usamos o <code>as_str</code>.</p> <p>Assim conseguimos agora colocar a compara\u00e7\u00e3o com a string \"i\" e a string \"q\".</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                println!(\"Iniciar Jogo\");\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n==\n\n    }\n}\n</code></pre> <p>Aqui colocamos o \"i\" para imprimir e usamos o <code>continue</code> para voltar ao inicio do loop. No caso o jogador use \"q\" o programa vai ser encerrado. Tamb\u00e9m usamos o coringa \"_\" caso seja dada outra op\u00e7\u00e3o que n\u00e3o seja \"i\" ou \"q\" n\u00f3s colocamos a mensagem de erro e reiniciamos o loop.</p> <p>Agora podemos testar e verificar se nossa fun\u00e7\u00e3o est\u00e1 correta.</p>"},{"location":"1_2_jogo_da_adivinhacao/#diferenca-entre-str-e-string","title":"Diferen\u00e7a entre &amp;str e String","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o moderna que coloca um forte foco na seguran\u00e7a e no gerenciamento de mem\u00f3ria, permitindo aos desenvolvedores escrever c\u00f3digo seguro e eficiente. Duas estruturas de dados muito importantes em Rust s\u00e3o &amp;str e String. Embora ambas sejam usadas para representar texto, elas t\u00eam diferen\u00e7as fundamentais em termos de propriedades e uso. Vamos explorar as distin\u00e7\u00f5es entre &amp;str e String em Rust.</p> <p>&amp;str - Refer\u00eancia para uma Sequ\u00eancia de Caracteres</p> <p>&amp;str \u00e9 uma fatia (slice) que representa uma sequ\u00eancia de caracteres em Rust. Essa fatia \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres armazenada em outro local da mem\u00f3ria. Aqui est\u00e3o algumas caracter\u00edsticas importantes do &amp;str:</p> <pre><code>Imut\u00e1vel: O &amp;str \u00e9 imut\u00e1vel, o que significa que voc\u00ea n\u00e3o pode modificar o conte\u00fado da sequ\u00eancia de caracteres a que ele faz refer\u00eancia.\n\nAloca\u00e7\u00e3o Zero: O &amp;str em si n\u00e3o aloca mem\u00f3ria para a sequ\u00eancia de caracteres. Ele simplesmente aponta para uma sequ\u00eancia existente.\n\nView (Vis\u00e3o): O &amp;str \u00e9 uma vis\u00e3o de uma sequ\u00eancia de caracteres. Pode ser usado para referenciar substrings de uma String ou literais de string.\n\nLifetime: O &amp;str tem um tempo de vida (lifetime) que est\u00e1 vinculado ao contexto em que \u00e9 criado. Isso garante que a refer\u00eancia seja v\u00e1lida durante o tempo necess\u00e1rio.\n</code></pre> <p>Aqui est\u00e1 um exemplo de &amp;str:</p> <pre><code>fn main() {\n    let texto: &amp;str = \"Ol\u00e1, Mundo!\";\n    println!(\"{}\", texto);\n}\n\n</code></pre> <p>String - Propriedade de uma Sequ\u00eancia de Caracteres</p> <p>String \u00e9 uma estrutura de dados que representa uma sequ\u00eancia de caracteres alocada dinamicamente em Rust. Aqui est\u00e3o algumas caracter\u00edsticas importantes da String:</p> <pre><code>Mut\u00e1vel: A String \u00e9 mut\u00e1vel, o que significa que voc\u00ea pode modificar seu conte\u00fado, adicionando ou removendo caracteres.\n\nAloca\u00e7\u00e3o Din\u00e2mica: A String aloca mem\u00f3ria dinamicamente para armazenar a sequ\u00eancia de caracteres. Isso permite que voc\u00ea ajuste o tamanho conforme necess\u00e1rio.\n\nPropriet\u00e1ria: A String \u00e9 propriet\u00e1ria, o que significa que \u00e9 respons\u00e1vel por gerenciar a mem\u00f3ria da sequ\u00eancia de caracteres que ela cont\u00e9m.\n\nConvers\u00e3o: Voc\u00ea pode converter um &amp;str em uma String usando a fun\u00e7\u00e3o to_string(), ou usar a fun\u00e7\u00e3o String::from().\n</code></pre> <p>Aqui est\u00e1 um exemplo de String:</p> <pre><code>fn main() {\n    let mut texto: String = String::from(\"Ol\u00e1, \");\n    texto.push_str(\"Mundo!\");\n    println!(\"{}\", texto);\n}\n</code></pre> <p>Quando Usar &amp;str e String</p> <p>A escolha entre &amp;str e String depende do contexto e dos requisitos do seu programa:</p> <pre><code>Use &amp;str quando precisar de uma refer\u00eancia imut\u00e1vel a uma sequ\u00eancia de caracteres existente. Por exemplo, ao passar argumentos de fun\u00e7\u00e3o ou realizar opera\u00e7\u00f5es de leitura em uma sequ\u00eancia.\n\nUse String quando precisar de uma sequ\u00eancia de caracteres mut\u00e1vel que pode ser modificada. Por exemplo, para construir uma sequ\u00eancia de caracteres dinamicamente.\n\nLembre-se de que &amp;str e String s\u00e3o intercambi\u00e1veis por meio de convers\u00f5es quando necess\u00e1rio.\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#alocacao-de-memoria-em-rust","title":"Aloca\u00e7\u00e3o de mem\u00f3ria em Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o conhecida por seu controle rigoroso sobre a mem\u00f3ria. Ela oferece diversos tipos de mem\u00f3ria com comportamentos distintos, o que \u00e9 fundamental para garantir a seguran\u00e7a e o desempenho dos programas. Vamos explorar os principais tipos de mem\u00f3ria em Rust e como eles se comportam.</p>"},{"location":"1_2_jogo_da_adivinhacao/#1-stack-pilha","title":"1. Stack (Pilha)","text":"<p>A pilha, ou stack, \u00e9 um local de armazenamento de mem\u00f3ria de curto prazo e \u00e9 usada para alocar vari\u00e1veis locais e controlar a execu\u00e7\u00e3o do programa. Aqui est\u00e3o algumas caracter\u00edsticas da pilha:</p> <ul> <li>Alcance Limitado: As vari\u00e1veis alocadas na pilha t\u00eam um tempo de vida limitado e s\u00e3o desalocadas automaticamente quando saem do escopo.</li> <li>Aloca\u00e7\u00e3o R\u00e1pida: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria na pilha \u00e9 r\u00e1pida, pois segue uma ordem rigorosa de LIFO (\u00faltimo a entrar, primeiro a sair).</li> <li>Tamanho Conhecido em Tempo de Compila\u00e7\u00e3o: O tamanho das vari\u00e1veis alocadas na pilha deve ser conhecido em tempo de compila\u00e7\u00e3o.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o na pilha:</p> <pre><code>fn main() {\n    let x = 42; // Vari\u00e1vel \"x\" alocada na pilha\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#2-heap","title":"2. Heap","text":"<p>O heap \u00e9 um local de armazenamento de mem\u00f3ria de longo prazo, usado para alocar dados cujo tamanho n\u00e3o \u00e9 conhecido em tempo de compila\u00e7\u00e3o e/ou que precisam de tempo de vida mais longo. Aqui est\u00e3o algumas caracter\u00edsticas do heap:</p> <ul> <li>Alcance Mais Amplo: Os dados alocados no heap podem ter um tempo de vida mais longo e persistir al\u00e9m do escopo atual.</li> <li>Aloca\u00e7\u00e3o e Libera\u00e7\u00e3o Controladas: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria no heap s\u00e3o controladas manualmente pelo programador, usando fun\u00e7\u00f5es como Box::new, Vec::new, etc.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o no heap:</p> <pre><code>fn main() {\n    let x = Box::new(42); // Vari\u00e1vel \"x\" alocada no heap\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#3-memoria-estatica","title":"3. Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 usada para armazenar dados que t\u00eam um tempo de vida durante toda a execu\u00e7\u00e3o do programa. Ela \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada durante a execu\u00e7\u00e3o.</p> <ul> <li>Tempo de Vida Global: Os dados est\u00e1ticos t\u00eam um tempo de vida global e existem durante toda a execu\u00e7\u00e3o do programa.</li> <li>Aloca\u00e7\u00e3o em Tempo de Compila\u00e7\u00e3o: A mem\u00f3ria est\u00e1tica \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada ou realocada.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o de mem\u00f3ria est\u00e1tica:</p> <pre><code>static HELLO: &amp;str = \"Hello, World!\";\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#4-string-vs-str","title":"4. String vs &amp;str","text":"<p>Rust distingue entre String e &amp;str. String \u00e9 uma sequ\u00eancia de caracteres alocada no heap, que permite modifica\u00e7\u00f5es. &amp;str \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres (geralmente String ou literal de string) e \u00e9 imut\u00e1vel.</p> <ul> <li>Use String quando precisar de uma sequ\u00eancia de caracteres que pode ser modificada.</li> <li>Use &amp;str para referenciar sequ\u00eancias de caracteres imut\u00e1veis.</li> </ul> <pre><code>fn main() {\n    let s1: String = String::from(\"Hello\");\n    let s2: &amp;str = \"World\";\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#criando-a-funcao-do-jogo","title":"Criando a fun\u00e7\u00e3o do jogo","text":"<p>Agora vamos criar uma fun\u00e7\u00e3o onde vamos manter nossa l\u00f3gica do jogo para isso vamos usar a palavra reservada fn</p> <pre><code>fn game() -&gt; () {\n    println!(\"Iniciar Jogo\");\n}\n</code></pre> <p>Com isso movemos nosso print iniciar jogo para dentro da fun\u00e7\u00e3o e vamos ver que vai continuar funcionando vale notar que na fun\u00e7\u00e3o n\u00f3s anotamos <code>()</code> que quer dizer que a fun\u00e7\u00e3o vai retornar uma Option vazia ou seja se for OK v\u00e3o vai ter valor algum isso faz a fun\u00e7\u00e3o main que chama a fun\u00e7\u00e3o game saber que essa fun\u00e7\u00e3o n\u00e3o tem retorno se n\u00f3s tentarmos receber algum valor de game n\u00f3s vamos receber a Option por\u00e9m ela vai ver sem nenhum valor, com isso n\u00f3s nunca vamos receber um valor Nulo no m\u00e1ximo um Option com um Ok por\u00e9m n\u00e3o existe um valor empty ou None isso \u00e9 uma caracteristica do rust para trabalhar sem usar valores nulos. Agora quero que nosso jogo defina o n\u00famero secreto, nesse momento vamos definir um n\u00famero fixo, mais a frente vamos fazer esse n\u00famero ser aleat\u00f3rio, tamb\u00e9m vamos receber a pontua\u00e7\u00e3o do jogador e vamos j\u00e1 contar um erro e o fim do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                ==\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(pontuacao=_pontuacao, numero=_numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game(pontuacao: u16, numero: u8) -&gt; () {\n    println!(\"Iniciar Jogo\");\n    ==\n    pontuacao = pontuacao - 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n    ==\n}\n</code></pre> <p>Se tentarmos compilar vamos receber o erro abaixo:</p> <pre><code>\u276e cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0384]: cannot assign to immutable argument `pontuacao`\n  --&gt; src/main.rs:35:5\n   |\n33 | fn game(pontuacao: u16, numero: u8) -&gt; () {\n   |         --------- help: consider making this binding mutable: `mut pontuacao`\n34 |     println!(\"Iniciar Jogo\");\n35 |     pontuacao = pontuacao - 100;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to previous error\n</code></pre> <p>Essa mensagem diz que pontua\u00e7\u00e3o dentro de game \u00e9 um atributo imut\u00e1vel ent\u00e3o precisamos deixar nosso parametro mut\u00e1vel. ent\u00e3o simplesmente vamos usar um mut no cabe\u00e7alho da fun\u00e7\u00e3o game.</p> <pre><code>fn game(mut pontuacao: u16, numero: u8) -&gt; () {\n...\n</code></pre> <p>Agora se rodarmos vai voltar o resultado que gostariamos.</p> <pre><code>Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\n...\n</code></pre> <p>Agora vamos mudar um pouco queremos que nosso print do resultado tamb\u00e9m seja impresso depois que o loop do game acabar ent\u00e3o vamos copia-lo pra fora da fun\u00e7\u00e3o.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(_pontuacao, _numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n</code></pre> <p>Agora vamos receber essa saida</p> <pre><code>\u279c cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\n     Running `target/debug/guessing_game`\nBem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n</code></pre> <p>O que aconteceu? Acontece que do jeito que est\u00e1 a fun\u00e7\u00e3o game est\u00e1 recebendo uma c\u00f3pia dos valores de _pontuacao e _numero_alvo ou seja o valor reduzido de 900 s\u00f3 existe dentro da fun\u00e7\u00e3o game quando a fun\u00e7\u00e3o termina o rust limpa as vari\u00e1veis do escopo de game poderiamos facilmente resolver isso fazendo com que game retorne o valor de 900 para nossa vari\u00e1vel _pontuacao mas, podemos resolver isso sem precisar duplicar os valores dentro da fun\u00e7\u00e3o passando a refer\u00eancia delas atrav\u00e9s de Borrowing que \u00e9 o que vamos discutir a seguinte.</p>"},{"location":"1_2_jogo_da_adivinhacao/#ownership-e-borrowing","title":"Ownership e Borrowing","text":"<p>Rust introduz o conceito de \"ownership\" (propriedade) e \"borrowing\" (empr\u00e9stimo) para gerenciar a mem\u00f3ria de forma segura. Isso implica que, em Rust, voc\u00ea precisa seguir regras rigorosas para acessar e modificar a mem\u00f3ria. A ideia principal \u00e9 que um recurso s\u00f3 pode ser possu\u00eddo por uma \u00fanica parte do c\u00f3digo em um determinado momento.</p> <ul> <li>Propriedade (Ownership): Uma vari\u00e1vel \u00e9 a \"dona\" de um recurso e \u00e9 respons\u00e1vel por liber\u00e1-lo quando n\u00e3o for mais necess\u00e1rio.</li> <li>Empr\u00e9stimo (Borrowing): Outras partes do c\u00f3digo podem \"emprestar\" acesso \u00e0 vari\u00e1vel, mas n\u00e3o podem modificar a propriedade.</li> </ul> <p>Assim sendo no nosso caso particular podemos pedir pro rust nos dar as refer\u00eancias das vari\u00e1veis _pontuacao e _numero_alvo assim sendo ele n\u00e3o cria uma nova vari\u00e1vel <code>numero</code> e <code>pontuacao</code> ele vai simplesmente pegar a referencia onde est\u00e1 armazenado os valores de _pontuacao e _numero_alvo e come\u00e7ar a apontar para os parametros que existem na fun\u00e7\u00e3o assim quando a fun\u00e7\u00e3o terminar ela vai devolver as refer\u00eancias para os parametros originais.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                ==\n                game(&amp;mut _pontuacao, &amp;_numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\n==\nfn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n==\n    println!(\"Iniciar Jogo\");\n    ==\n    *pontuacao -= 100;\n    ==\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Aqui fizemos algumas altera\u00e7\u00f5es a primeira \u00e9 que passamos na vari\u00e1vel o simbolo \"&amp;\" que indica que estamos emprestando a refer\u00eancia para a fun\u00e7\u00e3o ou seja ela vai ser tempor\u00e1riamente a dona dos parametros passados e no caso de pontua\u00e7\u00e3o n\u00f3s passamos como &amp;mut que quer dizer que ela pode ser modificada, caso fosse passado apenas om o &amp; comercial a fun\u00e7\u00e3o game s\u00f3 teria a permiss\u00e3o de ler o parametro e n\u00e3o modificalo.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n</code></pre> <p>No cabe\u00e7alho da fun\u00e7\u00e3o mudamos tamb\u00e9m indicando que pontua\u00e7\u00e3o \u00e9 a referencia mutavel de um u16 e a referencia de u8 assim na compila\u00e7\u00e3o ele sabe que a fun\u00e7\u00e3o est\u00e1 trabalhando com refer\u00eancias e n\u00e3o vai criar uma c\u00f3pia da fun\u00e7\u00e3o.</p> <p>Por ultimo vamos fazer uma altera\u00e7\u00e3o na nossa opera\u00e7\u00e3o de subtra\u00e7\u00e3o</p> <pre><code>    *pontuacao -= 100;\n</code></pre> <p>Usamos o simbilo \"*\" para indicar que n\u00e3o queremos mexer na refer\u00eancia onde est\u00e1 pontuacao mas, no valor que ele possui assim o valor que estava em _pontuacao mudou de 1000 para 900.</p> <p>Agora com isso conseguimos compreender as linhas onde capturamos a entrada do teclado do jogador</p> <pre><code>        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>Onde criamos uma vari\u00e1vel escolha_str que \u00e9 uma String vazia e mut\u00e1vel e quando chamamos a fun\u00e7\u00e3o read_line n\u00f3s passamos a refer\u00eancia mut\u00e1vel de escolha_str e enquanto ela est\u00e1 em execu\u00e7\u00e3o ela est\u00e1 alterando o valor do <code>escolha_str</code> para n\u00f3s e quando termina conseguimos usar o valor de escolha_str com os valores modificados pela fun\u00e7\u00e3o <code>read_line</code> sem precisar duplicar a vari\u00e1vel dentro da fun\u00e7\u00e3o.  \u00c9 importante refor\u00e7ar que em muitas linguagens n\u00e3o conseguimos fazer isso n\u00f3s normalmente precisamos receber a copia modificada dentro da fun\u00e7\u00e3o para conseguir trabalhar. Essa caracter\u00edstica do rust \u00e9 muito importante para casos que trabalhamos com pouca mem\u00f3ria ou mesmo um jogo onde quanto menos recursos usarmos mais leve ser\u00e1 nosso jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introducao-sobre-testes-de-software","title":"Introdu\u00e7\u00e3o sobre testes de software","text":"<p>A programa\u00e7\u00e3o \u00e9 uma tarefa complexa que envolve a cria\u00e7\u00e3o de software que seja confi\u00e1vel, eficiente e livre de erros. \u00c0 medida que os projetos de desenvolvimento de software crescem em complexidade, torna-se cada vez mais cr\u00edtico garantir a qualidade do c\u00f3digo. Uma das abordagens mais eficazes para assegurar a qualidade do software \u00e9 a pr\u00e1tica de testes, especialmente o Desenvolvimento Orientado a Testes (TDD).</p> <p>Ent\u00e3o vamos agora explorar sobre a import\u00e2ncia dos testes na programa\u00e7\u00e3o e como o TDD pode ser uma ferramenta valiosa para alcan\u00e7ar um c\u00f3digo mais robusto e confi\u00e1vel. Vamos mergulhar no mundo dos testes e entender por que eles s\u00e3o essenciais para qualquer desenvolvedor de software.</p> <p>Os testes desempenham um papel fundamental no processo de desenvolvimento de software por v\u00e1rias raz\u00f5es:</p> <ul> <li>Detec\u00e7\u00e3o Precoce de Erros: Os testes permitem que os desenvolvedores identifiquem e corrijam erros em um est\u00e1gio inicial do desenvolvimento, economizando tempo e recursos no longo prazo.</li> <li>Manuten\u00e7\u00e3o Simplificada: Um c\u00f3digo bem testado \u00e9 mais f\u00e1cil de manter. Quando novos recursos s\u00e3o adicionados ou modifica\u00e7\u00f5es s\u00e3o feitas, os testes garantem que as funcionalidades existentes continuem funcionando conforme o esperado.</li> <li>Redu\u00e7\u00e3o de Bugs em Produ\u00e7\u00e3o: Testar seu c\u00f3digo ajuda a evitar que bugs cheguem aos usu\u00e1rios finais, resultando em uma melhor experi\u00eancia do cliente e economizando custos associados \u00e0 corre\u00e7\u00e3o de problemas em produ\u00e7\u00e3o.</li> <li>Documenta\u00e7\u00e3o Autom\u00e1tica: Testes bem escritos funcionam como documenta\u00e7\u00e3o viva do seu c\u00f3digo. Eles descrevem como as diferentes partes do software devem se comportar.</li> <li>Confian\u00e7a no C\u00f3digo: Testar seu c\u00f3digo cria confian\u00e7a tanto para os desenvolvedores quanto para os usu\u00e1rios. Saber que o software passou em uma bateria de testes proporciona tranquilidade.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#desenvolvimento-orientado-a-testes-tdd","title":"Desenvolvimento Orientado a Testes (TDD)","text":"<p>O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem de desenvolvimento que enfatiza a escrita de testes antes de escrever o c\u00f3digo real. O ciclo TDD segue tr\u00eas passos simples: \"Red-Green-Refactor.\"</p> <ul> <li>Red (Vermelho): Neste est\u00e1gio, voc\u00ea escreve um teste que descreve a funcionalidade que deseja implementar. Como voc\u00ea ainda n\u00e3o escreveu o c\u00f3digo, o teste falhar\u00e1.</li> <li>Green (Verde): Agora, voc\u00ea escreve o c\u00f3digo m\u00ednimo necess\u00e1rio para fazer o teste passar. O objetivo \u00e9 fazer o teste passar o mais r\u00e1pido poss\u00edvel.</li> <li>Refactor (Refatorar): Com o teste passando, voc\u00ea pode refatorar o c\u00f3digo para torn\u00e1-lo mais limpo, eficiente e leg\u00edvel.</li> </ul> <p>O TDD oferece in\u00fameras vantagens, incluindo:</p> <ul> <li>Maior Qualidade do C\u00f3digo: TDD incentiva a escrita de c\u00f3digo de alta qualidade desde o in\u00edcio.</li> <li>Projeto Centrado no Usu\u00e1rio: Testes escritos com base nos requisitos do usu\u00e1rio garantem que o software atenda \u00e0s expectativas.</li> <li>Facilidade de Manuten\u00e7\u00e3o: O c\u00f3digo resultante do TDD \u00e9 mais f\u00e1cil de manter, pois as mudan\u00e7as n\u00e3o quebram as funcionalidades existentes.</li> <li>Confian\u00e7a nas Mudan\u00e7as: TDD permite que os desenvolvedores fa\u00e7am altera\u00e7\u00f5es no c\u00f3digo com confian\u00e7a, sabendo que os testes ir\u00e3o detectar problemas.</li> <li>Feedback R\u00e1pido: TDD fornece feedback imediato, acelerando o processo de desenvolvimento.</li> </ul> <p>A import\u00e2ncia dos testes na programa\u00e7\u00e3o n\u00e3o pode ser subestimada. Eles desempenham um papel cr\u00edtico na cria\u00e7\u00e3o de software de alta qualidade, confi\u00e1vel e seguro. O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem valiosa que torna os testes uma parte integrante do processo de desenvolvimento, resultando em um c\u00f3digo mais robusto e confi\u00e1vel.</p> <p>Para os desenvolvedores, a pr\u00e1tica de testes e o uso do TDD representam um investimento que se traduz em economia de tempo, redu\u00e7\u00e3o de custos e satisfa\u00e7\u00e3o do cliente. \u00c0 medida que a ind\u00fastria de software continua a evoluir, a cultura de testes se torna cada vez mais fundamental para o sucesso de projetos de desenvolvimento de software.</p> <p>Portanto, da pr\u00f3xima vez que voc\u00ea come\u00e7ar a escrever c\u00f3digo, lembre-se da import\u00e2ncia dos testes e considere adotar o Desenvolvimento Orientado a Testes como parte integrante do seu processo de desenvolvimento. A qualidade do seu software agradecer\u00e1.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introduzindo-testes-ao-nosso-codigo","title":"Introduzindo testes ao nosso c\u00f3digo","text":"<p>Agora vamos abrir nosso arquivo test_game_loop.rs, esse teste vai ser usado para testarmos nossas condi\u00e7\u00f5es do jogo ent\u00e3o vamos criar um primeiro teste para validar a condi\u00e7\u00e3o que est\u00e1 fixa hoje. Vamos adicionar o c\u00f3digo abaixo no final do nosso main.rs</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero)\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Inicialmente precisamos adicionar uma anota\u00e7\u00e3o annotattion <code>#[test]</code> as anota\u00e7\u00f5es s\u00e3o colocadas no inicio de uma fun\u00e7\u00e3o/m\u00f3dulo/trait para adicionar alguma funcionalidade aquele bloco de c\u00f3digo. NO nosso caso estamos adicionando uma funcionalidade de teste para nossa fun\u00e7\u00e3o de teste <code>test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral</code> assim podemos rodar o comando de teste <code>cargo test</code>. Nossa estrutura de testes \u00e9 divida em 3 partes: - Arrange -&gt; que \u00e9 os dados que precisamos preparar para o teste - Act -&gt; Execu\u00e7\u00e3o do c\u00f3digo que queremos testas - Assert -&gt; Que \u00e9 o que esperamos que aconte\u00e7a depois do c\u00f3digo sendo executado.</p> <p>No caso do assert executamos uma macro nova que \u00e9 o <code>assert_eq!</code> sua fun\u00e7\u00e3o \u00e9 comprar dois valores caso sejam iguais ele termina corretamente, caso sejam diferentes ele vai voltar um erro no nosso teste, vamos primeiro rodar o teste do jeito que est\u00e1.</p> <pre><code>cargo test\n</code></pre> <p>Voc\u00ea deve ter um retorno parecido com esse:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Vale destacar alguns pontos:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n    \n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n     \n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Aqui mostra onde foi compilado o teste</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\n    \nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n     \n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Nessas linhas mostram quantos testes rodaram, o nome do teste que rodou e se foi ok ou n\u00e3o</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\n    \ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n     \n</code></pre> <p>Nessa linha temos um pequeno relat\u00f3rio dos testes quando passaram quantos derram erro e por ai vai, al\u00e9m de tudo mostra o tempo que demorou pra rodar os testes.</p> <p>Agora vamos mudar nosso teste para ele falhar</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    ==assert_eq!(pontuacao, 0)==\n}\n</code></pre> <p>Agora temos uma sa\u00edda diferente</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.12s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral stdout ----\n\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral' panicked at src/main.rs:51:5:\nassertion `left == right` failed\n  left: 900\n right: 0\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\n\nfailures:\n    test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\nerror: test failed, to rerun pass `--bin guessing_game`\n\n</code></pre> <p>\u00c9 importante n\u00e3o ter medo de ler toda a mensagem mesmo que seja grande pois com ela podemos ver o problema.</p> <p>Veja que agora ele mostra a saida da execu\u00e7\u00e3o de game, no caso ele vai mostrar os dois prints que criamos depois ele vai mostrar o erro do assertion mostrando que o valor de pontua\u00e7\u00e3o foi 900 e o valor da direita foi 0 ent\u00e3o sabemos quanto nossa variavel retornou e o valor da compara\u00e7\u00e3o.</p> <p>Tamb\u00e9m podemos ver que agora no nosso relat\u00f3rio temos um teste como failed pois o teste falhou.</p> <p>Vamos agora voltar nosso teste para passar novamente e rodar os testes.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo agora podemos continuar trabalhando no jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-o-chute-do-jogador","title":"Adicionando o chute do jogador","text":"<p>Agora vamos adicionar a captura da entrada do jogador para e vamos passar o valor para nossa fun\u00e7\u00e3o game.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    \n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n    \n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos nosso teste ele ainda vai passar.</p> <pre><code>\u279c  cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos fazer algumas altera\u00e7\u00f5es vamos criar uma nova fun\u00e7\u00e3o que vai atualizar a pontua\u00e7\u00e3o. Mas primeiro vamos mudar nosso teste para verificar com a fun\u00e7\u00e3o check_win_condition e passar mais um parametro chamado chute que vai ser um inteiro tamb\u00e9m.</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_conditition(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Vamos receber agora um erro de compila\u00e7\u00e3o</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0425]: cannot find function `check_win_conditition` in this scope\n  --&gt; src/main.rs:55:5\n   |\n55 |     check_win_conditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n</code></pre> <p>\u00c9 importante sempre ler a mensagem de erro e tentar entender tamb\u00e9m sempre que quiser poder rodar o <code>--explain</code> para ver a descri\u00e7\u00e3o do erro.</p> <pre><code>rustc --explain E0425\n</code></pre> <p>Nesse caso o erro \u00e9 que check_win_conditition n\u00e3o existe dentro  do escopo isso por que ele n\u00e3o foi criado, vamos ent\u00e3o cria-lo e mover o c\u00f3digo respons\u00e1vel por diminuir a pontua\u00e7\u00e3o.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos o teste ele vai funcionar com um warning que logo vamos remove-lo.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `pontuacao`\n  --&gt; src/main.rs:33:9\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pontuacao`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `numero`\n  --&gt; src/main.rs:33:30\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_numero`\n\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:39:59\n   |\n39 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings (run `cargo fix --bin \"guessing_game\" --tests` to apply 3 suggestions)\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>O principal ponto desse warnings \u00e9 que n\u00e3o estamos usando v\u00e1rias variaveis vamos ajusta-las. Primeiro precisamos converter nossa variavel chute para int.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Temos algumas mudan\u00e7as aqui, precisamos mover pontuacao e numero_alvo para dentro da fun\u00e7\u00e3o game, pois n\u00e3o podemos reimprestar  pontuacao para verify_win_conditition essa \u00e9 uma caracteristica do rust ent\u00e3o jogamos tudo para a fun\u00e7\u00e3o game deixando a main apenas para menu. Tamb\u00e9m fizemos o match abaixo para converter a entrada  string para u8 e com isso temos um efeito colateral que precisamos voltar um n\u00famero que no caso \u00e9 0.</p> <pre><code>    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n</code></pre> <p>Agora vamos rodar nosso teste.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:48:59\n   |\n48 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning (run `cargo fix --bin \"guessing_game\" --tests` to apply 1 suggestion)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Vamos agora remover o ultimo warning e vamos come\u00e7ar a usar nosso parametro chute.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    \n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Assim agora apenas se o n\u00famero for menor que o n\u00famero a pontua\u00e7\u00e3o vai mudar. Vamos rodar o teste.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos alterar nossa entrada para n\u00e3o receber o parametro \"_\", pois h\u00e1 uma forma melhor de fazer isso.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        \n        io::stdin().read_line(&amp;mut escolha_str).expect(\"Erro ao receber sua escolha\");\n        \n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    \n    io::stdin().read_line(&amp;mut chute).expect(\"Erro ao receber o n\u00famero\");\n    \n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Aqui retiramos o parametro n\u00e3o usado e colocamo no final um expect isso \u00e9 uma captura de erro, vamos detalhar isso mais a frente mas, se pense que agora caso a option que esteja com algum dado \u00e9 a <code>Err</code> ele vai printar no nosso console as mensagens que colocamos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-vitoria","title":"Adicionando condi\u00e7\u00e3o de vit\u00f3ria","text":""},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-derrota","title":"Adicionando condi\u00e7\u00e3o de derrota","text":""},{"location":"1_2_jogo_da_adivinhacao/#seguranca-de-memoria","title":"Seguran\u00e7a de Mem\u00f3ria","text":"<p>Rust fornece uma s\u00e9rie de garantias de seguran\u00e7a de mem\u00f3ria durante o tempo de compila\u00e7\u00e3o. Essas garantias s\u00e3o fundamentais para evitar erros comuns, como vazamentos de mem\u00f3ria, refer\u00eancias nulas e acessos inv\u00e1lidos.</p> <ul> <li>Sem Refer\u00eancias Nulas: Rust garante que as refer\u00eancias n\u00e3o sejam nulas, eliminando muitos erros de acesso nulo.</li> <li>Sem Vazamentos de Mem\u00f3ria: Rust controla rigorosamente o ciclo de vida dos recursos, o que impede vazamentos de mem\u00f3ria.</li> <li>Sem Concorr\u00eancia de Dados Mut\u00e1veis: Rust imp\u00f5e regras rigorosas para evitar a concorr\u00eancia de dados mut\u00e1veis, garantindo a seguran\u00e7a em threads.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#conclusao","title":"Conclus\u00e3o","text":"<p>Com esse jogo vimos como criar uma fun\u00e7\u00e3o em rust, criar testes para essa fun\u00e7\u00e3o usando a suite nativa de testes do rust, mais algumas fun\u00e7\u00f5es de manipula\u00e7\u00e3o de strings, como funciona o conceito de borrow and ownership, como funciona o gerenciamento de mem\u00f3ria do rust.</p>"},{"location":"1_3_jogo_labirinto/","title":"Jogo do labirinto","text":""},{"location":"INDICE/","title":"Summary","text":""},{"location":"INDICE/#ementa-desenvolvimento-de-jogos-em-ascii-com-rust","title":"Ementa: Desenvolvimento de Jogos em ASCII com Rust","text":""},{"location":"INDICE/#topico-1-conceitos-basicos-de-rust","title":"T\u00f3pico 1: Conceitos B\u00e1sicos de Rust","text":"<ul> <li>Introdu\u00e7\u00e3o</li> <li>Jogo a Floresta Misteriosa</li> <li>Tipos de Dados e Fun\u00e7\u00f5es</li> <li>Controle de Fluxo e Propriedade (Ownership)</li> </ul>"},{"location":"INDICE/#topico-2-introducao-a-arte-ascii","title":"T\u00f3pico 2: Introdu\u00e7\u00e3o \u00e0 Arte ASCII","text":"<ul> <li>[Manipula\u00e7\u00e3o de Strings e Caracteres ASCII]</li> <li>[Sa\u00edda para o Terminal e Interface do Usu\u00e1rio]</li> </ul>"},{"location":"INDICE/#topico-3-implementando-a-logica-de-jogos","title":"T\u00f3pico 3: Implementando a L\u00f3gica de Jogos","text":"<ul> <li>[Vetores e Matrizes]</li> <li>[Algoritmos de Busca e Ordena\u00e7\u00e3o]</li> </ul>"},{"location":"INDICE/#topico-4-gerenciamento-de-tela-e-interface-do-usuario","title":"T\u00f3pico 4: Gerenciamento de Tela e Interface do Usu\u00e1rio","text":"<ul> <li>[Manipula\u00e7\u00e3o de Tela e Terminal (ANSI escape codes)]</li> <li>[Entrada do Usu\u00e1rio (stdin) e Gerenciamento de Eventos]</li> </ul>"},{"location":"INDICE/#topico-5-mecanica-de-jogo","title":"T\u00f3pico 5: Mec\u00e2nica de Jogo","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto State]</li> </ul>"},{"location":"INDICE/#topico-6-tratamento-de-eventos","title":"T\u00f3pico 6: Tratamento de Eventos","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto Observer]</li> </ul>"},{"location":"INDICE/#topico-7-controle-de-estado-e-salvamento-do-jogo","title":"T\u00f3pico 7: Controle de Estado e Salvamento do Jogo","text":"<ul> <li>[Serializa\u00e7\u00e3o e Desserializa\u00e7\u00e3o de Dados]</li> </ul>"},{"location":"INDICE/#topico-8-desafios-e-recursos-avancados","title":"T\u00f3pico 8: Desafios e Recursos Avan\u00e7ados","text":"<ul> <li>[Threads e Concorr\u00eancia]</li> <li>[Gerenciamento de Mem\u00f3ria Avan\u00e7ado (Rc, Arc, Mutex)]</li> </ul>"},{"location":"INDICE/#topico-9-desenvolvimento-de-jogos-completos-em-ascii","title":"T\u00f3pico 9: Desenvolvimento de Jogos Completos em ASCII","text":"<ul> <li>[Estrutura de Projeto e Organiza\u00e7\u00e3o de Arquivos]</li> <li>[Tratamento de Erros (Result, Option)]</li> <li>[Documenta\u00e7\u00e3o do C\u00f3digo]</li> </ul>"},{"location":"INDICE/#topico-10-projeto-final-jogo-completo-em-ascii","title":"T\u00f3pico 10: Projeto Final: Jogo Completo em ASCII","text":"<ul> <li>[Aplica\u00e7\u00e3o de todos os conceitos aprendidos para criar um jogo completo e original em ASCII.]</li> </ul>"}]}