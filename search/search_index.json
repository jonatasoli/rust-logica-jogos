{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao curso Rust l\u00f3gica com jogos","text":"<p>Esse material est\u00e1 em desenvolvimento ent\u00e3o sugest\u00f5es s\u00e3o sempre bem-vindas.</p>"},{"location":"#o-que-e-rust","title":"O que \u00e9 Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o compulada que se destaca por oferecer um alto desempenho, controle de mem\u00f3ria sem a necessidade de um coletor de lixo e garantias de seguran\u00e7a. Ela foi desenvolvida pela Mozilla Research e \u00e9 projetada para ser eficiente, segura e pr\u00e1tica.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi projetado para oferecer uma experi\u00eancia pr\u00e1tica no ensiono da linguagem Rust, usando desenvolvimento de jogos em ASCII e textual. Durante o curso, o objetivo principal \u00e9 proporcionar aos participantes um entendimento abrangente dos conceitos fundamentais da linguagem Rust, juntamente com a aplica\u00e7\u00e3o pr\u00e1tica desses conhecimentos na cria\u00e7\u00e3o de jogos mesmo n\u00e3o sendo o foco do curso ensinar a fazer jogos profissionalmente.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Durante esse curso voc\u00ea vai aprender o b\u00e1sico de Rust como fluxos condicionais, repeti\u00e7\u00e3o, uso de fun\u00e7\u00f5es, escopo de v\u00e1riaveis at\u00e9 t\u00f3picos avan\u00e7ados como Threads e concorr\u00eancia.</p>"},{"location":"#esse-curso-e-gratuito","title":"Esse curso \u00e9 gratuito?","text":"<p>Essa wiki \u00e9 gratuita assim como os exerc\u00edcios, por\u00e9m tamb\u00e9m h\u00e1 um curso em v\u00eddeo que no momento est\u00e1 em pre\u00e7o promocional e esse ser\u00e1 pago.</p>"},{"location":"#onde-ele-sera-disponibilizado","title":"Onde ele ser\u00e1 disponibilizado?","text":"<p>O curso vai ser disponibilizado atrav\u00e9s da plataforma Udemy.</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9 requisitos","text":"<p>Para fazer esse curso \u00e9 importante ter no\u00e7\u00f5es b\u00e1sicas de inform\u00e1tica como: - Saber usar um navegador - Saber entrar num prompt de comando seja no Windows, Mac ou Linux - J\u00e1 ter conhecimento em outra linguagem \u00e9 desej\u00e1vel mas, n\u00e3o \u00e9 essencial pois vamos trabalhar do zero e contruir projetos</p> <p>Obs: O curso ser\u00e1 desenvolvido totalmente em linux, caso queira usar Windows \u00e9 interessante usar WSL2 devo colocar no curso posteriormente um tutorial para configurar o ubuntu com wsl2 mas, por hora recomendo verem o v\u00eddeo do F\u00e1bio Akita criando um ambiente.</p>"},{"location":"#ementa","title":"Ementa","text":""},{"location":"#jogos","title":"Jogos","text":""},{"location":"#apos-esse-curso-vou-estar-capacitado-a-fazer-jogos-profissionalmente","title":"Ap\u00f3s esse curso vou estar capacitado a fazer jogos profissionalmente?","text":"<p>N\u00e3o, mesmo que seja abordados alguns principios do desenvolvimento de jogos, esse curso n\u00e3o tem como objetivo ajudar o aluno a fazer jogos profissionais, nesse caso o instrutor ainda recomenda buscar outros materiais para se aprofundar no tema.</p>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"Quem vai ministrar essas aulas?","text":"<p>Ol\u00e1 eu sou o J\u00f4natas sou um profissional com 17 anos de experi\u00eancia no desenvolvimento de sistemas e websites, meu foco principal est\u00e1 sistemas web. Comecei a aprender Rust em 2020 e estou trabalhando no meu primeiro jogo profissionalmente. Tamb\u00e9m tenho um canal no Youtube Fa\u00e7o lives na Twitch</p>"},{"location":"#o-que-voce-precisa-para-acompanhar-o-curso","title":"O que voc\u00ea precisa para acompanhar o curso?","text":"<ul> <li>Editor de texto ou IDE: Recomendo qualquer editor que tenha a capacidade de identicar c\u00f3digo Rust, durante os v\u00eddeos vou usar o nvim ou helix mas, voc\u00ea pode usar qual quiser, se voc\u00ea for iniciante recomendo usar o vscodium.</li> </ul>"},{"location":"#repositorio","title":"Reposit\u00f3rio","text":"<p>Todas os exemplos criados para o curso assim como exercic\u00edos estar\u00e3o no reposit\u00f3rio abaixo. https://github.com/jonatasoli/rust-logica-jogos--exercicios</p>"},{"location":"#como-posso-ajudar","title":"Como posso ajudar?","text":"<p>Em primeiro lugar fazendo o curso e dando feedback do que gostou e o que n\u00e3o gostou me ajuda muito. Sugest\u00f5es de melhoria e corre\u00e7\u00f5es s\u00e3o sempre bem vindas.</p> <p>Caso desejar poder\u00e1 me ajudar tamb\u00e9m atrav\u00e9s do github sponsor ou por pix <code>contact@jonatasoliveira.dev</code> valor arrecadado vai me ajudar a me manter durante a produ\u00e7\u00e3o do curso.</p>"},{"location":"1_0_introducao/","title":"Introdu\u00e7\u00e3o","text":"<p>Bem vindo ao curso de Rust l\u00f3gica com jogos, voc\u00ea vai aprender: - Como fazer esse curso? - O que \u00e9 Rust? - Principais caracter\u00edsticas do Rust - Instala\u00e7\u00e3o do Rust - Configura\u00e7\u00e3o do editor - Principios b\u00e1sicos de um jogo eletr\u00f4nico - O que \u00e9 GDD? WIP</p>"},{"location":"1_0_introducao/#como-fazer-esse-curso","title":"Como fazer esse curso?","text":"<p>Para inicio voc\u00ea pode assistir um v\u00eddeo meu sobre meu m\u00e9todo de estudo mas, resumidamente: - Monte um cronograma - Veja o conte\u00fado - Fa\u00e7a os exercicios sugeridos - Use os exerc\u00edcios sugeridos como uma revis\u00e3o do conte\u00fado</p>"},{"location":"1_0_introducao/#o-que-e-rust","title":"O que \u00e9 Rust?","text":"<p>Nos \u00faltimos anos, a linguagem de programa\u00e7\u00e3o Rust tem ganhado destaque no cen\u00e1rio de desenvolvimento de software. Criada pela Mozilla Research e lan\u00e7ada em 2010, Rust \u00e9 uma linguagem de programa\u00e7\u00e3o de sistema que se destaca por sua seguran\u00e7a, performance e facilidade de uso.</p>"},{"location":"1_0_introducao/#principais-caracteristicas-do-rust","title":"Principais caracter\u00edsticas do Rust","text":""},{"location":"1_0_introducao/#seguranca","title":"Seguran\u00e7a","text":"<p>Um dos principais atrativos de Rust \u00e9 sua forte \u00eanfase na seguran\u00e7a. Ao combinar uma rigorosa verifica\u00e7\u00e3o de tipos em tempo de compila\u00e7\u00e3o com um sistema de gerenciamento de mem\u00f3ria sem garbage collector, Rust elimina muitas das classes comuns de bugs que assolam outras linguagens, como corrup\u00e7\u00e3o de mem\u00f3ria, vazamentos de mem\u00f3ria e race conditions.</p> <p>O sistema de tipos de Rust \u00e9 projetado para capturar erros em tempo de compila\u00e7\u00e3o que poderiam levar a falhas de seguran\u00e7a em tempo de execu\u00e7\u00e3o, como acessos inv\u00e1lidos \u00e0 mem\u00f3ria ou uso indevido de ponteiros. Isso \u00e9 poss\u00edvel gra\u00e7as a recursos exclusivos, como o conceito de propriedade (ownership) e empr\u00e9stimos (borrowing), que garantem que os recursos de mem\u00f3ria sejam gerenciados de forma segura durante toda a vida \u00fatil do programa.</p>"},{"location":"1_0_introducao/#performance","title":"Performance","text":"<p>Al\u00e9m de sua forte \u00eanfase na seguran\u00e7a, Rust tamb\u00e9m \u00e9 conhecida por sua excelente performance. Ao fornecer controle de baixo n\u00edvel sobre os recursos de hardware, como gerenciamento de mem\u00f3ria e concorr\u00eancia, Rust permite que os desenvolvedores escrevam c\u00f3digo altamente eficiente que rivaliza com linguagens de sistema tradicionais, como C e C++, sem sacrificar a seguran\u00e7a.</p> <p>A abordagem \u00fanica de Rust para a concorr\u00eancia, baseada em suas garantias de seguran\u00e7a em tempo de compila\u00e7\u00e3o, tamb\u00e9m torna mais f\u00e1cil escrever c\u00f3digo concorrente que \u00e9 livre de race conditions e deadlock, enquanto ainda aproveita ao m\u00e1ximo o poder do hardware moderno.</p>"},{"location":"1_0_introducao/#instalacao-do-rust","title":"Instala\u00e7\u00e3o do Rust","text":"<p>Para instalar o rust simplesmente abra seu terminal ou prompt de commando e cole o c\u00f3digo abaixo:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Para windows <code>chocolatey</code>:</p> <pre><code>choco install rust\n\n</code></pre> <p>Para mac (Homebrew):</p> <pre><code>brew install rustup\n</code></pre>"},{"location":"1_0_introducao/#configuracao-do-editor","title":"Configura\u00e7\u00e3o do editor","text":"<p>Isso varia de acordo com o editor que voc\u00ea quer usar vou por aqui algumas sugest\u00f5es: - NeoVim (WIP) - Helix - Emacs</p>"},{"location":"1_0_introducao/#principios-basicos-de-um-jogo-eletronico","title":"Principios b\u00e1sicos de um jogo eletr\u00f4nico","text":"<p>Os jogos eletr\u00f4nicos s\u00e3o formas de entretenimento interativo que envolvem os jogadores em experi\u00eancias virtuais atrav\u00e9s de dispositivos eletr\u00f4nicos, como consoles de videogame, computadores e dispositivos m\u00f3veis. Eles abrangem uma ampla variedade de g\u00eaneros, desde jogos de a\u00e7\u00e3o e aventura at\u00e9 quebra-cabe\u00e7as e jogos de simula\u00e7\u00e3o.</p>"},{"location":"1_0_introducao/#principios-basicos-dos-jogos-eletronicos","title":"Princ\u00edpios B\u00e1sicos dos Jogos Eletr\u00f4nicos","text":"<ol> <li> <p>Objetivo Todos os jogos t\u00eam um objetivo ou um conjunto de objetivos que os jogadores devem alcan\u00e7ar para progredir ou vencer o jogo. Isso pode incluir coletar itens, derrotar inimigos, resolver quebra-cabe\u00e7as ou alcan\u00e7ar uma pontua\u00e7\u00e3o espec\u00edfica.</p> </li> <li> <p>Regras Os jogos tamb\u00e9m t\u00eam regras que definem o funcionamento do jogo e o que os jogadores podem e n\u00e3o podem fazer. Essas regras podem incluir limites de tempo, restri\u00e7\u00f5es de movimento, condi\u00e7\u00f5es de vit\u00f3ria e derrota, entre outras.</p> </li> <li> <p>Interatividade Um dos aspectos mais distintivos dos jogos eletr\u00f4nicos \u00e9 sua interatividade. Os jogadores t\u00eam a capacidade de interagir com o mundo do jogo de v\u00e1rias maneiras, como mover personagens, tomar decis\u00f5es, resolver quebra-cabe\u00e7as e muito mais.</p> </li> <li> <p>Feedback Os jogos fornecem feedback aos jogadores para inform\u00e1-los sobre seu desempenho e progresso no jogo. Isso pode incluir efeitos visuais, sons, pontua\u00e7\u00f5es e mensagens na tela que indicam se uma a\u00e7\u00e3o foi bem-sucedida ou n\u00e3o.</p> </li> <li> <p>Desafio Os jogos s\u00e3o projetados para desafiar os jogadores e oferecer uma experi\u00eancia gratificante \u00e0 medida que eles superam obst\u00e1culos e alcan\u00e7am seus objetivos. O equil\u00edbrio entre desafio e habilidade \u00e9 fundamental para manter os jogadores envolvidos e motivados.</p> </li> <li> <p>Imers\u00e3o A imers\u00e3o \u00e9 a capacidade dos jogos de envolver os jogadores em um mundo virtual convincente. Isso pode ser alcan\u00e7ado por meio de gr\u00e1ficos realistas, trilha sonora envolvente, narrativa cativante e mec\u00e2nicas de jogo envolventes.</p> </li> <li> <p>Progress\u00e3o Os jogos geralmente apresentam um sistema de progress\u00e3o que permite aos jogadores avan\u00e7ar no jogo e desbloquear novos conte\u00fados, como n\u00edveis, personagens, habilidades e itens, \u00e0 medida que progridem.</p> </li> </ol>"},{"location":"1_0_introducao/#o-que-e-gdd","title":"O que \u00e9 GDD?","text":"<p>O Guia de Design de Jogo (GDD) \u00e9 um documento crucial no desenvolvimento de jogos, servindo como um mapa do tesouro para os criadores de jogos.</p> <p>Um Guia de Design de Jogo (GDD) \u00e9 um documento detalhado que descreve todos os aspectos de um jogo, desde sua concep\u00e7\u00e3o inicial at\u00e9 sua implementa\u00e7\u00e3o final. Ele serve como um guia abrangente para todos os membros da equipe de desenvolvimento de jogos, fornecendo uma vis\u00e3o clara e coesa do que o jogo ser\u00e1 e como ele ser\u00e1 criado.</p> <p>O GDD pode ser super detalhado ou apenas com os pontos principais do jogo, o importante que usamos ele como guia.</p>"},{"location":"1_1_jogo_floresta_misteriosa/","title":"Floresta Misteriosa","text":"<p>Para iniciar vamos dar um raio-x sobre nosso primeiro jogo, em a floresta misteriosa o jogador assume um papel de um aventureiro corajoso  que se aventura por uma floresta misteriosa. A cada escolha que o jogador faz v\u00e3o influenciar a sua jornada, dependendo da sua decis\u00e3o voc\u00ea vai ganhar ou perder pontos se voc\u00ea alcan\u00e7ar 100 pontos voc\u00ea vence o jogo.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#regras","title":"Regras","text":"<p>Nosso jogo apresentar\u00e1 um menu ao nosso jogador com as op\u00e7\u00f5es que ele pode escolher. Como nosso escopo \u00e9 pequeno vamos limitar em 4 escolhas.</p> <ul> <li>Ele pode beber agua no rio onde o jogador vai ganhar 10 pontos.</li> <li>Ele pode passar pela ponte fr\u00e1gil onde ele vai perder 20 pontos.</li> <li>Ele pode querer entrar na caverna escura ele vai ganhar 50 pontos.</li> <li>Ele pode passar pelo caminho iluminado onde vai perder 20 pontos.</li> </ul> <p>Essas escolhas v\u00e3o aparecendo toda vez que o jogador faz uma escolha at\u00e9 ele ganhar ou perder o jogo. Caso ele consiga 100 pontos o jogador ganha e se o jogador chegar a 0 ele perde.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#criando-o-projeto","title":"Criando o projeto","text":"<p>Bom primeiro vamos criar um diret\u00f3rio onde vamos armazenar nossos projetos do curso, minha sugest\u00e3o \u00e9 criar um diret\u00f3rio chamado projects. Ent\u00e3o vamos abrir um terminal primeiro vamos usar o comando <code>cd</code> para ir at\u00e9 o diret\u00f3rio <code>Home</code> do seu computador e depois vamos usar o comando <code>mkdir</code> para criar um diret\u00f3rio.</p> <pre><code>cd\nmkdir projects\n</code></pre> <p>Caso queria se aprofundar sobre os comandos via terminal minha sugest\u00e3o \u00e9 dar uma conferida no guia focalinux ele vai lhe ajudar a ter um entendimento melhor do funcionando dos comandos posix mas, vou explicando cada comando no terminal que vamos usar ao decorrer do curso.</p> <p>Bom agora vamos acessar o diret\u00f3rio que criamos.</p> <pre><code>cd projects\n</code></pre> <p>Agora que acessamos o diret\u00f3rio que vamos trabalho, o pr\u00f3ximo passo \u00e9 criarmos nosso projeto em rust, para criar um projeto em rust vamos usar o comando <code>cargo new</code> e o nome do nosso projeto \u00e9 chamado <code>mysterious_forest</code>. Assim ele vai criar um diret\u00f3rio chamado <code>mysterious_forest</code> para confirmar-mos se a pasta foi criada vamos usar o comando <code>ls -la</code> onde o <code>-la</code> \u00e9 um parametro apenas para listarmos tamb\u00e9m os arquivos ocultos.</p> <pre><code>cargo new mysterious_forest\nls -la\n</code></pre> <p>Agora vamos acessar o direorio que criamos no qual podemos acessa-lo atrav\u00e9s do comando <code>cd mysterious_forest</code>.</p> <pre><code>cd mysterious_forest\n</code></pre> <p>Agora podemos usar novamente o comando <code>ls -la</code> para vermos o que o comando cargo criou no nosso projeto.</p> <pre><code>.git\n.gitignore\nCargo.toml\nsrc\n</code></pre> <p>Uma observa\u00e7\u00e3o os arquivos com o <code>.</code> na frente como o <code>.git</code> e o <code>.gitignore</code> s\u00e3o arquivos ocultos no linux.</p> <p>Bom agora vou dar o comando <code>cargo run</code> para executar meu projeto.</p> <p>Assim vamos ter a sa\u00edda.</p> <pre><code>\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nHello, world!\n</code></pre> <p>Uma coisa interessante de notar quando executamos um projeto rust \u00e9 que na primeira linha: <code>Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)</code> N\u00f3s temos o nome do nosso execut\u00e1vel, no caso <code>mysterious_forest</code> e a vers\u00e3o do nosso execut\u00e1vel no caso <code>v0.1.0</code>.</p> <p>Na segunda linha temos: <code>Finished dev [unoptimized + debuginfo] target(s) in 0.12s</code> Aqui temos a informa\u00e7\u00e3o que nosso execut\u00e1vel foi compilado em modo dev e o tempo de compila\u00e7\u00e3o no caso <code>0.12</code></p> <p>Na terceira linha temos: <code>Running target/debug/mysterious_forest</code> Essa linha nos mostra onde fica nosso execut\u00e1vel ele que vamos dar a para que as pessoas possam jogar nosso jogo.</p> <p>Certo agora vamos entrar no projeto no arquivo no caminho <code>src/main.rs</code></p> <pre><code>fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre> <p>Isso \u00e9 um \"Hello, world!\" padr\u00e3o de um projeto rust, ent\u00e3o nesse caso n\u00e3o come\u00e7amos com um \"Hello, world!\" no projeto pois ele j\u00e1 vem no momento da cria\u00e7\u00e3o.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#falando-de-tipagem","title":"Falando de tipagem","text":"<p>A tipagem em programa\u00e7\u00e3o se refere \u00e0 maneira como as linguagens de programa\u00e7\u00e3o tratam os tipos de dados, ou seja, como elas definem e gerenciam os diferentes tipos de valores que podem ser usados em um programa. Rust \u00e9 uma linguagem de programa\u00e7\u00e3o que utiliza um sistema de tipagem est\u00e1tica, o que significa que os tipos de dados s\u00e3o verificados em tempo de compila\u00e7\u00e3o, tornando o c\u00f3digo mais seguro e eficiente. Tipagem Est\u00e1tica</p> <p>Em Rust, voc\u00ea precisa declarar explicitamente o tipo de dado que uma vari\u00e1vel pode armazenar. Isso \u00e9 feito durante a declara\u00e7\u00e3o da vari\u00e1vel, permitindo que o compilador verifique se o valor atribu\u00eddo \u00e0 vari\u00e1vel \u00e9 compat\u00edvel com o tipo declarado. Se houver uma incompatibilidade de tipos, o c\u00f3digo n\u00e3o ser\u00e1 compilado, o que ajuda a evitar erros em tempo de execu\u00e7\u00e3o. Tipos Primitivos em Rust</p> <p>Rust possui uma s\u00e9rie de tipos primitivos que podem ser usados para representar diferentes tipos de dados. Vamos dar uma olhada nos tipos primitivos mais comuns em Rust: 1. Integer Types (Tipos Inteiros)</p> <p>Os tipos inteiros em Rust representam n\u00fameros inteiros sem parte fracion\u00e1ria. Aqui est\u00e3o alguns dos tipos inteiros mais comuns, junto com sua faixa de valores:</p> <pre><code>i8: Intervalo de -128 a 127.\n\ni16: Intervalo de -32,768 a 32,767.\n\ni32: Intervalo de -2,147,483,648 a 2,147,483,647.\n\ni64: Intervalo de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807.\n\ni128: Intervalo extremamente grande de n\u00fameros inteiros com sinal.\n</code></pre> <p>Por exemplo, voc\u00ea pode declarar uma vari\u00e1vel inteira em Rust da seguinte forma:</p> <pre><code>rust\n\nlet numero: i32 = 42;\n</code></pre> <p>Os tipos inteiros sem sinal, representados com u, t\u00eam os mesmos tamanhos que os tipos inteiros com sinal e representam apenas valores n\u00e3o negativos. Por exemplo, u8 varia de 0 a 255, u16 varia de 0 a 65,535 e assim por diante. 2. Floating-Point Types (Tipos de Ponto Flutuante)</p> <p>Os tipos de ponto flutuante em Rust representam n\u00fameros com parte fracion\u00e1ria. Os tipos mais comuns s\u00e3o:</p> <pre><code>f32: Representa n\u00fameros de ponto flutuante de precis\u00e3o simples.\n\nf64: Representa n\u00fameros de ponto flutuante de dupla precis\u00e3o (mais precisos).\n</code></pre> <p>Exemplo:</p> <pre><code>rust\n\nlet pi: f64 = 3.14159;\n</code></pre> <ol> <li>Boolean Type (Tipo Booleano)</li> </ol> <p>O tipo booleano em Rust \u00e9 usado para representar valores verdadeiro (true) ou falso (false). \u00c9 frequentemente usado em express\u00f5es condicionais e l\u00f3gicas.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet esta_chovendo: bool = true;\n</code></pre> <ol> <li>Character Type (Tipo de Caractere)</li> </ol> <p>Rust tamb\u00e9m possui um tipo de caractere chamado char, que representa um \u00fanico caractere Unicode. Isso \u00e9 \u00fatil para lidar com texto e caracteres especiais.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet letra: char = 'A';\n</code></pre> <ol> <li>String Type (Tipo de Texto)</li> </ol> <p>Rust diferencia entre dois tipos relacionados: str e String.</p> <pre><code>str: Representa uma sequ\u00eancia de caracteres imut\u00e1vel (n\u00e3o pode ser modificada ap\u00f3s a cria\u00e7\u00e3o) e \u00e9 frequentemente usado com refer\u00eancias (&amp;str) para manipula\u00e7\u00e3o de texto eficiente.\n\nString: Representa uma sequ\u00eancia de caracteres mut\u00e1vel (pode ser modificada) e \u00e9 mais flex\u00edvel, geralmente alocada na mem\u00f3ria de forma din\u00e2mica.\n</code></pre> <p>Exemplo:</p> <pre><code>rust\n\nlet texto_estatico: &amp;str = \"Isso \u00e9 um texto imut\u00e1vel\";\nlet mut texto_mutavel: String = String::from(\"Isso \u00e9 um texto mut\u00e1vel\");\n</code></pre> <p>Essa \u00e9 uma explica\u00e7\u00e3o mais abrangente sobre a tipagem em Rust, os tipos primitivos mais comuns e a diferen\u00e7a entre str e String. \u00c0 medida que voc\u00ea se familiariza mais com Rust, poder\u00e1 explorar tipos compostos, structs, enums e outros recursos poderosos que a linguagem oferece para lidar com problemas espec\u00edficos de programa\u00e7\u00e3o.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#variaveis","title":"Variaveis","text":"<p>Bom para come\u00e7ar nosso jogo precisamos definir algumas estruturas de dados que v\u00e3o armazenar a pontua\u00e7\u00e3o do nosso jogador e o qual escolha ele vai fazer em seguida, pra isso vamos precisar criar vari\u00e1veis.</p> <p>As vari\u00e1veis em rust s\u00e3o declarados usando a palavra reservada <code>let</code> o nome da vari\u00e1vel e o tipo dela al\u00e9m do seu valor de inicializa\u00e7\u00e3o. Uma v\u00e1riavel em rust \u00e9 diferente de outras linguagens pois ela \u00e9 imut\u00e1vel ou seja quando inicializamos ela, a mesma n\u00e3o altera seu valor, h\u00e1 uma forma de informar explicitamente que queremos que a vari\u00e1vel receba valores dinamicamente mas, vamos ver mais a frente.</p> <p>Ent\u00e3o agora dentro do nosso main vamos declarar a primeira vari\u00e1vel do nosso projeto.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n}\n ```\n\nVamos da uma olhada mais de perto no nosso c\u00f3digo:\n`fn` \u00e9 a palavra reservada para declarar uma fun\u00e7\u00e3o\n`main` \u00e9 o nome da nossa fun\u00e7\u00e3o e os parenteses `()` \u00e9 a estrutura que usamos para declarar os parametros da nossa fun\u00e7\u00e3o que no caso n\u00e3o temos nenhum ent\u00e3o ela est\u00e1 vazia.\nPara simplificar um pouco as coisas parametros nada mais \u00e9 que as vari\u00e1veis que uma fun\u00e7\u00e3o vai receber quando ela for executada, mas n\u00e3o tema em um outor momento vamos falar mais de fun\u00e7\u00f5es e parametros.\n`{}` determina um bloco de c\u00f3digo ent\u00e3o o que estiver ali dentro vai ser o c\u00f3digo que ser\u00e1 executado pela nossa fun\u00e7\u00e3o main.\n`let pontuacao: i32 = 0;` aqui declaramos nossa vari\u00e1vel come\u00e7ando com a palavra reservada `let` depois o nome da vari\u00e1vel que no caso \u00e9 `pontuacao` o tipo dela que no nosso caso \u00e9 um `i32` ai temos o `=` que o nosso simbulo de atribui\u00e7\u00e3o ou seja, que `pontuacao` vai receber um valor, na sequencia temos o valor que estamos inicializando que no caso \u00e9 o valor `0` e finalmente temos o simbulo `;` que indica pro compilador que a linha de execu\u00e7\u00e3o foi encerrada finalizando a instru\u00e7\u00e3o.\n\nCom isso podemos criar nossa segunda vari\u00e1vel:\n\n```rust\nfn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n}\n</code></pre> <p>Ent\u00e3o criamos uma variavel escolha que tamb\u00e9m \u00e9 uma <code>i32</code> s\u00f3 que agora colocamos como valor incial <code>1</code>.</p> <p>Para dar sequ\u00eancia no nosso projeto vamos criar uma mensagem de boas-vindas, pra isso vamos usar uma macro no rust que nada mais \u00e9 que uma sequ\u00eancia de instru\u00e7\u00f5es que v\u00e3o rodar internamente quando ela for executada que no nosso caso \u00e9 o <code>println!</code> o  <code>!</code> no final nos indica que ela \u00e9 uma macro.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    ==println!(\"Bem-vindo \u00e0 floresta misteriosa\")==\n}\n\n</code></pre> <p>Um ponto importante pra se observar n\u00f3s n\u00e3o usamos o simbolo <code>;</code> no final da nossa macro <code>println!</code> isso por que em rust dentro de um bloco de c\u00f3digo a ultima linha n\u00e3o precisa ter esse simbolo pois ele interpreta essa \u00faltima linha como o valor a se retornar da fun\u00e7\u00e3o no nosso caso por\u00e9m estamos executando uma macro que vai imprimir valores na tela ent\u00e3o ele basicamente n\u00e3o est\u00e1 retornando nada. Voc\u00ea pode observar que dentro dos parenteses da nossa macro temos os simbolos de aspas <code>\"\"</code> e dentro delas colocamos nosso texto com acentos. Como o rust usa o padr\u00e3o unicode para caracteres podemos usar qualquer simbolo ou diagrama representado pela tabela unicode. Mas, no nosso c\u00f3digo em si n\u00f3s evitamos usar acentos e caracteres especiais.</p> <p>Agora vamos imprimir na tela o valor da nossa escolha e a pontua\u00e7\u00e3o pra isso vamos usar novamente a macro <code>println!</code>.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n    ==\n    println!(\"A sua escolha foi {}\", escolha);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}\", pontuacao)\n    ==\n}\n\n</code></pre> <p>Observe que s\u00f3 deixamos sem o <code>;</code> a ultima linha por isso no nosso primeiro <code>println!</code> agora tem a pontua\u00e7\u00e3o. Outra coisa \u00e9 que nosso c\u00f3digo est\u00e1 usando a macro de uma forma diferente. Temos o simbolo das chaves <code>{}</code> dentro das aspas, isso indica que queremos imprimir o valor de uma vari\u00e1vel que no nosso caso s\u00e3o as vari\u00e1veis <code>escolha</code> e <code>pontuacao</code>. No caso se quisermos colocar mais vari\u00e1veis dentro de uma string que \u00e9 o caso do nosso <code>println!</code> podemos usar mais chaves que ele vai entender.</p> <p>Agora podemos rodar novamente  o <code>cargo run</code> para ver o retorno da nossa fun\u00e7\u00e3o.</p> <pre><code>\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 0\n</code></pre> <p>Perfeito tudo funcionando!</p>"},{"location":"1_1_jogo_floresta_misteriosa/#controle-de-fluxo-condicional-com-if","title":"Controle de fluxo condicional com if","text":"<p>Vamos da uma olhada agora em como dar escolhas para nosso jogador. Primeiro vamos colocar um <code>println!</code> pedindo a escolha e 4 op\u00e7\u00f5es n\u00famericas para ele escolher.</p> <pre><code>\\\\ c\u00f3digo\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\\\\c\u00f3digo\n</code></pre> <p>Agora precisamos de um recurso que nos mostre que quando digitarmos no teclado a op\u00e7\u00e3o 1 ele fa\u00e7a a a\u00e7\u00e3o <code>Entrar na caverna escura</code> e assim com as demais op\u00e7\u00f5es e quando ele escolher a op\u00e7\u00e3o fa\u00e7a a soma ou a subtra\u00e7\u00e3o dos pontos. Pra isso vamos usar o <code>if</code> ele \u00e9 nosso primeiro condicional e com ele podemos fazer que com determinada escolha ele fa\u00e7a uma sequencia de a\u00e7\u00f5es no nosso caso se o jogador escolher a op\u00e7\u00e3o 1 precisa realizar a a\u00e7\u00e3o de somar 50 pontos na pontua\u00e7\u00e3o atual.</p> <pre><code>\\\\c\u00f3digo\n    println!(\"4 - Descansar na beira do riacho\");\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    }\n\\\\c\u00f3digo\n</code></pre> <p>Vamos ter um erro mas, vamos ignora-lo por enquanto, agora precisamos colocar as outras condi\u00e7\u00f5es ent\u00e3o usamos a palavra reservada <code>if</code> e poderiamos ficar usando ela para as demais op\u00e7\u00f5es mas, h\u00e1 um problema, nosso c\u00f3digo usando 4 <code>if's</code> nesse caso ele vai verificar todas 4 vezes em todos os casos. Ent\u00e3o podemos usar um outro recurso que \u00e9 o sen\u00e3o se  que basicamente vai verificar a primeira condi\u00e7\u00e3o e se ela n\u00e3o for verdade e vai verificar a pr\u00f3xima condi\u00e7\u00e3o e assim sucessivamente. O c\u00f3digo ficaria assim:</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n==\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n==\n\n    println!(\"A sua escolha foi {}\", escolha);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}\", pontuacao)\n}\n</code></pre> <p>Agora vamos rodar nosso c\u00f3digo ele vai receber um erro igual o abaixo:</p> <pre><code>error[E0384]: cannot assign twice to immutable variable `pontuacao`\n  --&gt; src/main.rs:20:9\n   |\n2  |     let pontuacao: i32 = 0;\n   |         ---------\n   |         |\n   |         first assignment to `pontuacao`\n   |         help: consider making this binding mutable: `mut pontuacao`\n...\n20 |         pontuacao = pontuacao + 10;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\n</code></pre> <p>Aqui ele est\u00e1 dizendo que n\u00e3o pode mudar uma vari\u00e1vel imut\u00e1vel e \u00e9 isso que vamos explorar a seguinte.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#introducao-a-variaveis-e-imutabilidade","title":"Introdu\u00e7\u00e3o a v\u00e1riaveis e imutabilidade","text":"<p>Se voc\u00ea est\u00e1 come\u00e7ando a aprender sobre programa\u00e7\u00e3o, \u00e9 importante entender o que s\u00e3o vari\u00e1veis e constantes em Rust, uma linguagem de programa\u00e7\u00e3o moderna e segura. Vamos explorar esses conceitos e suas implica\u00e7\u00f5es, incluindo exemplos de constantes. Vari\u00e1veis em Rust</p> <p>Uma vari\u00e1vel em Rust \u00e9 uma forma de armazenar e manipular dados em um programa. \u00c9 como uma caixa que voc\u00ea pode usar para guardar informa\u00e7\u00f5es temporariamente. No entanto, Rust difere de muitas outras linguagens de programa\u00e7\u00e3o em um aspecto fundamental: por padr\u00e3o, as vari\u00e1veis s\u00e3o imut\u00e1veis, o que significa que n\u00e3o podem ser alteradas ap\u00f3s a primeira atribui\u00e7\u00e3o.</p> <p>Por exemplo, considere o seguinte c\u00f3digo:</p> <pre><code>rust\n\nlet nome = \"Alice\";\nnome = \"Bob\"; // Isso geraria um erro de compila\u00e7\u00e3o!\n</code></pre> <p>Neste exemplo, a tentativa de mudar o valor de nome para \"Bob\" resultaria em um erro de compila\u00e7\u00e3o. Isso ocorre porque, por padr\u00e3o, Rust preza pela seguran\u00e7a e evita que voc\u00ea modifique dados acidentalmente. A Palavra Reservada mut</p> <p>Mas e se voc\u00ea quiser que uma vari\u00e1vel seja mut\u00e1vel, ou seja, que possa ser alterada? \u00c9 a\u00ed que entra a palavra reservada mut. Quando voc\u00ea declara uma vari\u00e1vel com a palavra-chave mut, voc\u00ea est\u00e1 indicando explicitamente que a vari\u00e1vel pode ser modificada.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet mut contador = 0;\ncontador = contador + 1; // Isso \u00e9 permitido, pois 'contador' \u00e9 mut\u00e1vel\n</code></pre> <p>Neste caso, contador \u00e9 uma vari\u00e1vel mut\u00e1vel, e voc\u00ea pode aumentar seu valor sem problemas. Constantes em Rust</p> <p>Al\u00e9m de vari\u00e1veis, Rust tamb\u00e9m oferece o conceito de constantes. As constantes s\u00e3o valores imut\u00e1veis que s\u00e3o definidos em tempo de compila\u00e7\u00e3o. Elas s\u00e3o declaradas usando a palavra-chave const e sempre devem ter um tipo de dado espec\u00edfico.</p> <p>Exemplo:</p> <pre><code>rust\n\nconst PI: f64 = 3.14159;\n</code></pre> <p>Aqui, PI \u00e9 uma constante que representa o valor de \u03c0 (pi) com uma precis\u00e3o de ponto flutuante de dupla precis\u00e3o (f64). Essa constante n\u00e3o pode ser alterada ap\u00f3s sua defini\u00e7\u00e3o e \u00e9 acess\u00edvel em todo o escopo em que est\u00e1 definida. Vantagens e Desvantagens da Imutabilidade por Padr\u00e3o</p> <p>A abordagem de imutabilidade por padr\u00e3o em Rust oferece algumas vantagens importantes: 1. Seguran\u00e7a:</p> <pre><code>Evita erros comuns relacionados \u00e0 muta\u00e7\u00e3o de dados, como condi\u00e7\u00f5es de corrida (race conditions) em programas concorrentes.\n\nFacilita a previsibilidade do c\u00f3digo, uma vez que voc\u00ea n\u00e3o precisa se preocupar com efeitos colaterais inesperados.\n</code></pre> <ol> <li> <p>Melhora a Legibilidade:</p> <p>Torna o c\u00f3digo mais f\u00e1cil de entender, uma vez que voc\u00ea sabe que uma vari\u00e1vel n\u00e3o ser\u00e1 alterada em lugares inesperados.</p> </li> <li> <p>Facilita a Concorr\u00eancia:</p> <p>Permite que Rust garanta a seguran\u00e7a na concorr\u00eancia, pois a imutabilidade reduz o risco de acesso concorrente a dados mut\u00e1veis.</p> </li> </ol> <p>No entanto, essa abordagem tamb\u00e9m pode ter desvantagens, como: 1. Mais Digita\u00e7\u00e3o:</p> <pre><code>Pode ser necess\u00e1rio digitar mais c\u00f3digo para criar vari\u00e1veis mut\u00e1veis quando necess\u00e1rio.\n</code></pre> <ol> <li> <p>Curva de Aprendizado:</p> <p>Pode levar algum tempo para se acostumar com a imutabilidade por padr\u00e3o, especialmente se voc\u00ea est\u00e1 familiarizado com linguagens que n\u00e3o a adotam.</p> </li> </ol> <p>Outras Linguagens com Caracter\u00edsticas Semelhantes</p> <p>Algumas outras linguagens de programa\u00e7\u00e3o tamb\u00e9m adotam a imutabilidade por padr\u00e3o ou oferecem suporte a vari\u00e1veis imut\u00e1veis:</p> <pre><code>Haskell\n\nElm\n\nClojure\n</code></pre> <p>Em resumo, vari\u00e1veis e constantes em Rust t\u00eam a caracter\u00edstica \u00fanica de serem imut\u00e1veis por padr\u00e3o, proporcionando seguran\u00e7a e legibilidade. A palavra-chave mut permite que voc\u00ea torne vari\u00e1veis mut\u00e1veis quando necess\u00e1rio, mantendo o controle sobre a mutabilidade dos dados em seu c\u00f3digo. Rust tamb\u00e9m suporta constantes, que s\u00e3o valores imut\u00e1veis definidos em tempo de compila\u00e7\u00e3o. Essa abordagem pode ser diferente de outras linguagens, mas traz benef\u00edcios significativos em termos de seguran\u00e7a e concorr\u00eancia.</p> <p>\u00c9 importante refor\u00e7ar que com isso voc\u00ea pode usar uma vari\u00e1vel imut\u00e1vel durante a maior parte da execu\u00e7\u00e3o e quando ela precisar ser alterada redeclarar ela como mut\u00e1vel mais a frente vamos falar do conceito de como funciona o gerenciamente de mem\u00f3ria do rust e isso vai acabar ficando mais claro.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#variaveis-e-mutabilidade","title":"Vari\u00e1veis e mutabilidade","text":"<p>Bom conforme vimos anteriormente nosso c\u00f3digo estava dando erro pois o rust acusava que estavamos tentando mudar uma vari\u00e1vel imut\u00e1vel. Isso acontece por que em rust todas as vari\u00e1veis por padr\u00e3o s\u00e3o imut\u00e1veis, ent\u00e3o n\u00e3o podemos modifica-la depois inicializar ela. Para isso vamos precisamos indicar pro rust que nossa vari\u00e1vel \u00e9 mut\u00e1vel usando a palavra reservada <code>mut</code> depois do <code>let</code>.</p> <pre><code>fn main() {\n    ==let mut pontuacao: i32 = 0;== \n    let escolha: i32 = 1;\n\n    // c\u00f3digo\n}\n\n</code></pre> <p>Agora voc\u00ea pode ver que seu editor deve parar de dar algum aviso de erro. Vamos tentar rodar nosso c\u00f3digo.</p> <pre><code>mysterious_forest on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.73.0 on \u2601\ufe0f  (eu-west-2) took 4m4s\n\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 50\n\n</code></pre> <p>Certo agora nosso c\u00f3digo foi executado com sucesso mostrando que nossa pontua\u00e7\u00e3o foi 50.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#recebendo-parametros-do-jogador-e-usando-a-condicional-match","title":"Recebendo parametros do jogador e usando a condicional match","text":"<p>Bom nosso jogo est\u00e1 nos devolvendo a pontua\u00e7\u00e3o da nossa escolha, mas nosso jogador ainda n\u00e3o consegue nos passar a op\u00e7\u00e3o que ele quer, ent\u00e3o pra isso vamos precisar receber os dados do usu\u00e1rio isso quer dizer que precisamos pedir pro rust pedir o input do teclado do usu\u00e1rio. Pra isso vamos importar uma biblioteca que existe dentro do built in do rust ou seja uma biblioteca que ele j\u00e1 nos fornece por padr\u00e3o pra ser usada.</p> <p>Para importa-la precisamos usar a palavra reservada <code>use</code> chamar a biblioteca que queremos que no caso \u00e9 a <code>std</code> que \u00e1 biblioteca standard do rust, e no caso eu quero um m\u00f3dulo especifico da biblioteca e n\u00e3o ela toda pra chamar o m\u00f3dulo precisamos usar o simbolo <code>::</code> para indicar que vamos selecionar um m\u00f3dulo e escolhe-lo que no caso \u00e9 o m\u00f3dulo <code>io</code>.</p> <p>Nosso c\u00f3digo ficaria assim:</p> <pre><code>use std::io;\n</code></pre> <p>Agora vamos precisar criar uma vari\u00e1vel mutavel para receber a escolha do nosso usu\u00e1rio, no caso a escolha de um usu\u00e1rio sempre ser\u00e1 uma sequencia de caracteres no caso podemos incializa-la com uma <code>String</code> vazia conforme abaixo:</p> <pre><code>    //c\u00f3digo\n    println!(\"4 - Descansar na beira do riacho\");\n\n    ==let mut escolha_str: String = String::new();==\n\n    if escolha == 1 {\n    //c\u00f3digo\n</code></pre> <p>Aqui usamos o simbolo <code>::</code> para chamar um m\u00e9todo associado chamado <code>new</code> dentro da <code>Struct</code> chamada <code>String</code> que \u00e9 uma sequ\u00eancia de caracteres.</p> <p>Agora vamos usar o m\u00f3dulo <code>io</code> e chamar duas fun\u00e7\u00f5es a <code>stdin</code> e a <code>read_line</code>, nesse primeiro momento n\u00e3o precisa se preocupar muito com a chamada que vou fazer, mas atente-se que vou colocar como parametro de <code>read_line</code> nossa vari\u00e1vel <code>escolha_str</code> mais a frente vamos explicar com mais detalhes como funciona essa chamada que vamos fazer.</p> <pre><code>    // c\u00f3digo\n    let mut escolha_str: String = String::new();\n\n    ==io::stdin().read_line(&amp;mut escolha_str);==\n\n    if escolha == 1 {\n    // c\u00f3digo\n\n</code></pre> <p>Agora vamos fazer um <code>println!</code> para imprimir o que o usu\u00e1rio escolheu no meu caso vou escolha a op\u00e7\u00e3o <code>4</code>.</p> <pre><code>    // c\u00f3digo\n    io::stdin().read_line(&amp;mut escolha_str);\n\n    ==println!(\"Escolha str \u00e9 {}\", escolha_str);==\n\n    if escolha == 1 {\n    // c\u00f3digo\n</code></pre> <p>Com a sa\u00edda:</p> <pre><code>warning: `mysterious_forest` (bin \"mysterious_forest\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.13s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n5\nEscolha str \u00e9 4\n\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 50\n</code></pre> <p>Atente-se que a escolha \u00e9 ainda 1 mas, a escolha str foi 4.</p> <p>Agora quero que meu escolha receba o valor de escolha_str, por\u00e9m o escolha_str \u00e9 uma <code>String</code> e o escolha \u00e9 um <code>i32</code>. Ent\u00e3o pra conseguir fazer o que quero vou mudar minha vari\u00e1vel escolha para <code>u32</code> para n\u00e3o receber n\u00famero negativos e vou converter minha <code>String</code> para isso preciso remover espa\u00e7os e quebras de linha e pra isso uso a fun\u00e7\u00e3o <code>trim</code> e depois chamo a fun\u00e7\u00e3o <code>parse</code> que vai tentar converter pro tipo da vari\u00e1vel que quero.</p> <p>\u00c9 importante ressalta que a fun\u00e7\u00e3o <code>parse</code> vai me voltar um <code>Rusult</code> que \u00e9 uma estrutura no formato abaixo:</p> <pre><code>    (OK, Err)\n</code></pre> <p>Onde <code>OK</code> vai ter o valor do parse caso de certo e em <code>Err</code> vai voltar o erro caso ocorra um erro. Essa estrutura nunca vai voltar os dois valores. Pois ele ou vai retornar um valor do tipo <code>OK</code> ou um valor do tipo <code>Err</code> assim n\u00e3o precisando ter recursos como o null de algumas linguagens.</p> <p>Ent\u00e3o vamos mover nosso escolha para abaixo de escolha_str e fazer o parse.</p> <pre><code>    println!(\"Escolha str \u00e9 {}\", escolha_str);\n    ==let escolha: i32 = escolha_str.trim().parse();==\n\n    if escolha == 1 {\n\n</code></pre> <p>No caso como o <code>parse</code> vai nos retornar ou <code>OK</code> ou <code>Err</code> eu quero que quando vier um erro nossa escolha receba o valor <code>0</code>. Poderiamos fazer isso com um <code>if</code> que nossa estrutura condicional que j\u00e1 conhecemos, mas, nesse momento quero lhe mostrar outra estrutura que no caso \u00e9 o <code>match</code>.</p> <pre><code>    //c\u00f3digo\n    println!(\"Escolha str \u00e9 {}\", escolha_str);\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n</code></pre> <p>Sua estrutura \u00e9:</p> <pre><code>    match &lt;condi\u00e7\u00e3o&gt; {\n        possivel retorno =&gt; retorno do c\u00f3digo,\n        possivel retorno 2 =&gt; retorno do c\u00f3digo,\n        ...\n        poss\u00edvel retorno n =&gt; retorno do c\u00f3digo\n    }\n</code></pre> <p>Outro ponto \u00e9 o simbolo <code>_</code> que \u00e9 um coringa o que quer dizer que n\u00e3o importa o valor que vir ele vai considerar ele um valor v\u00e1lido \u00e9 como uma condi\u00e7\u00e3o \"Se tudo que foi verificado antes n\u00e3o deu certo me use\". Tudo certo agora vamos rodar nosso c\u00f3digo.</p> <p>Agora nossa sa\u00edda fica assim:  <code>``bash warning:</code>mysterious_forest<code>(bin \"mysterious_forest\") generated 1 warning     Finished dev [unoptimized + debuginfo] target(s) in 0.14s      Running</code>target/debug/mysterious_forest` Bem-vindo \u00e0 floresta misteriosa Por favor escolha uma op\u00e7\u00e3o: 1 - Entrar na caverna escura 2 - Seguir no caminho iluminado 3 - Cruzar a ponte fr\u00e1gil 4 - Descansar na beira do riacho 4 Escolha str \u00e9 4</p> <p>A sua escolha foi 4 A sua pontua\u00e7\u00e3o foi 10</p> <pre><code>\n## Trabalhando com loop\n\nBom agora a primeira coisa que quero fazer \u00e9 parar de dar o warning na linha onde capturamos a entrada do jogador pra isso vamos fazer uma altera\u00e7\u00e3o no c\u00f3digo:\n\n```rust\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>H\u00e1 outras formas de resolver isso mas, nesse momento vamos fazer esse que \u00e9 o mais simples. Agora vamos fazer nossa condi\u00e7\u00e3o de vit\u00f3ria e derrota.</p> <p>// main.rs</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 0;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n    let mut escolha_str: String = String::new();\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n    ==\n    if pontuacao &gt;= 100 {\n        println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n    } else if pontuacao &lt;= 0 {\n        println!(\"Que pena voc\u00ea perdeu\");\n    }\n\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n    ==\n}\n\n</code></pre> <p>Aqui eu fiz um if verificando se a pontua\u00e7\u00e3o \u00e9 maior ou igual a 100 coloco um print parabenizando pela vit\u00f3ria ou se a pontua\u00e7\u00e3o for menor ou igual a zero informando a derrota. H\u00e1 tamb\u00e9m mais um print para informar o fim do jogo al\u00e9m de ter tirado nosso println! para escolha str.</p> <p>Agora podemos rodar nosso jogo e ver a condi\u00e7\u00e3o de derrota j\u00e1 que a de vit\u00f3ria ainda n\u00e3o vamos conseguir por conta da pontua\u00e7\u00e3o.</p> <pre><code>\u2726 \u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n3\nObrigado por jogar 'A floresta misteriosa!'\n\n</code></pre> <p>[!info] Condicionais</p> <p>Vale ressaltar que podemos usar <code>==</code> para verificar igualdades, <code>!=</code> para verificar &gt;diferen\u00e7as, <code>&lt;=</code> para verificar se \u00e9 menor ou igual, <code>&gt;=</code> para verificar se \u00e9 maior ou igual assim como <code>&lt;</code> e <code>&gt;</code> para verificar se \u00e9 menor e igual respectivamente. </p> <p>Agora vamos por 100 na ultima op\u00e7\u00e3o para conseguirmos testar nossa condi\u00e7\u00e3o de vit\u00f3ria.</p> <pre><code>    } else if escolha == 4 {\n        pontuacao = pontuacao + 100;\n    }\n\n</code></pre> <p>Agora podemos testar.</p> <pre><code>mysterious_forest on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.76.0 on \u2601\ufe0f   (eu-west-2) took 11s\n\u2726 \u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n4\nParab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\nObrigado por jogar 'A floresta misteriosa!'\n\n</code></pre> <p>Certo agora temos nossa condi\u00e7\u00e3o de vit\u00f3ria e derrota funcionando, mas basicamente nosso jogo por enquanto s\u00f3 podemos escolher uma op\u00e7\u00e3o e o jogo acaba. Ent\u00e3o precisamos de uma forma de pode escolher repetidas vezes.  Primeiro vamos ajustar nossa pontua\u00e7\u00e3o inicial e o ganho e perda da pontua\u00e7\u00e3o do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 50;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n    let mut escolha_str: String = String::new();\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n        pontuacao = pontuacao + 30;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n\n    if pontuacao &gt;= 100 {\n        println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n    } else if pontuacao &lt;= 0 {\n        println!(\"Que pena voc\u00ea perdeu\");\n    }\n\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n}\n\n</code></pre> <p>Agora n\u00e3o conseguimos chegar nem a 100 e nem a 0 na primeira escolha, agora precisamos de algo que ajude nosso jogo a se repetir para isso vamos usar uma estrutura chamada <code>loop</code>.</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 50;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    ==loop \n        println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n        println!(\"1 - Entrar na caverna escura\");\n        println!(\"2 - Seguir no caminho iluminado\");\n        println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n        println!(\"4 - Descansar na beira do riacho\");\n\n        let mut escolha_str: String = String::new();\n\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        let escolha: i32 = match escolha_str.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; 0,\n        };\n\n        if escolha == 1 {\n            pontuacao = pontuacao + 30;\n        } else if escolha == 2 {\n            pontuacao = pontuacao - 20;\n        } else if escolha == 3 {\n            pontuacao = pontuacao - 20;\n        } else if escolha == 4 {\n            pontuacao = pontuacao + 10;\n        }\n\n        if pontuacao &gt;= 100 {\n            println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n            ==break;==\n        } else if pontuacao &lt;= 0 {\n            println!(\"Que pena voc\u00ea perdeu\");\n            ==break;==\n        }\n    ==\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n}\n</code></pre> <p>No c\u00f3digo acima envolvelmos a l\u00f3gica do nosso jogo dentro do <code>loop</code> com o bloco de c\u00f3digo <code>{}</code> evitando as mensagens de vit\u00f3ria e derrota. Se deixarmos s\u00f3 o <code>loop</code> nosso c\u00f3digo iria rodar infinitamente, ent\u00e3o precisamos definir uam condi\u00e7\u00e3o para ele parar e no nosso caso podemos usar nossa condi\u00e7\u00e3o de vit\u00f3ria/derrota, para isso depois da mensagens usamos a palavra reservada <code>break</code>.</p> <p>Agora se rodarmos nosso jogo com <code>cargo run</code> nosso jogo j\u00e1 est\u00e1 funcionando perfeitamente.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#alguns-ajustes","title":"Alguns ajustes","text":"<p>Vamos fazer algumas melhorias no c\u00f3digo, primeiro vou simplicicar a soma e subtra\u00e7\u00e3o da nossa pontua\u00e7\u00e3o usando a express\u00e3o <code>+=</code> e <code>-=</code>.</p> <pre><code>        if escolha == 1 {\n            pontuacao += 30;\n        } else if escolha == 2 {\n            pontuacao -= 20;\n        } else if escolha == 3 {\n            pontuacao += 20;\n        } else if escolha == 4 {\n            pontuacao += 10;\n        }\n\n</code></pre> <p>Agora vamos por alguma mensagem de feedback pro jogador saber se ele est\u00e1 fazendo uma a\u00e7\u00e3o correta ou n\u00e3o.</p> <pre><code>        if escolha == 1 {\n            ==println!(\"Voc\u00ea entrou na caverna escura e econtrou um tesouro parab\u00e9ns!\");==\n            pontuacao += 30;\n        } else if escolha == 2 {\n            ==println!(\"Voc\u00ea encontrou um Ogro poderoso, mas com sorte conseguiu escapar!\");==\n            pontuacao -= 20;\n        } else if escolha == 3 {\n            ==println!(\"A ponte se quebrou com sorte voc\u00ea conseguiu nadar de volta para a margem!\");==\n            pontuacao += 20;\n        } else if escolha == 4 {\n            ==println!(\"Voc\u00ea conseguiu recuperar um pouco das suas for\u00e7as!\");==\n            pontuacao += 10;\n        }\n\n</code></pre> <p>Agora se rodarmos o feedback ficou muito mais f\u00e1cil pro jogador.</p> <p>Como desafio tente colocar uma op\u00e7\u00e3o de jogar novamente o jogo com a op\u00e7\u00e3o S/N.</p> <p>Com isso finalizamos nosso primeiro jogo em Rust, agora voc\u00ea pode tentar fazer os desafios abaixo.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#exercicios-sugeridos","title":"Exercic\u00edos sugeridos","text":"<p>Aqui vou colocar os projetos para voc\u00ea fazer suas revis\u00f5es, muitas vezes os desafios poder\u00e3o n\u00e3o ser jogos infelizmente, mas estarei dispon\u00edvel no forum ou no Revolt para tirar d\u00favidas.</p> <p>Revis\u00e3o 1</p> <ul> <li>Crie um programa em Rust que simule o controle de estoque de uma loja, fa\u00e7a simples s\u00f3 com um unico produto utilizando vari\u00e1veis para armazenar a quantidade do produto e permitindo a atualiza\u00e7\u00e3o dos valores de estoque de forma mut\u00e1vel.</li> </ul> <p>Revis\u00e3o 2</p> <ul> <li>Desenvolva um programa que calcule o fatorial de um n\u00famero inserido pelo usu\u00e1rio. Utilize uma vari\u00e1vel mut\u00e1vel para armazenar o resultado parcial do c\u00e1lculo.</li> </ul> <p>Revis\u00e3o 3</p> <ul> <li>Crie um programa que simule uma calculadora simples em Rust, permitindo que o usu\u00e1rio realize opera\u00e7\u00f5es de adi\u00e7\u00e3o, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o e divis\u00e3o. Utilize vari\u00e1veis mut\u00e1veis para armazenar os valores inseridos pelo usu\u00e1rio e o resultado das opera\u00e7\u00f5es.</li> </ul> <p>Revis\u00e3o 4 - Implemente um programa em Rust que converta temperaturas entre Celsius e Fahrenheit. Utilize vari\u00e1veis mut\u00e1veis para armazenar os valores e permitir que o usu\u00e1rio escolha a convers\u00e3o desejada.</p>"},{"location":"1_2_jogo_da_adivinhacao/","title":"Jogo da adivinha\u00e7\u00e3o","text":"<p>Vamos come\u00e7ar um novo jogo que \u00e9 o jogo da adivinha\u00e7\u00e3o \"Guessing Game\" o objetivo desse jogo \u00e9 identificar um n\u00famero escolhido aleat\u00f3riamente. O jogo inicia com 1000 pontos para o jogador e cada vez que ele erra o n\u00famero \u00e9 subtraido 100 pontos do placar dele quando o placar chegar a zero o jogo \u00e9 encerrado.</p>"},{"location":"1_2_jogo_da_adivinhacao/#regras","title":"Regras","text":"<p>As regras s\u00e3o as seguintes: - Ao iniciar o jogo o jogador tem a escolha de come\u00e7ar o jogo ou sair do jogo - O jogador vai escolher um n\u00famero entre 0 a 100 - Caso o jogador escolha um n\u00famero fora desse intervalo ser\u00e1 solicitado para ele escolher novamente - Caso o jogador escolha uma letra ou um caractere especial tamb\u00e9m ser\u00e1 solicitado para escolher o novamente - Caso o jogador escolha um n\u00famero menor que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi menor - Caso o jogador escolha um n\u00famero maior que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi maior - Casa escolha que n\u00e3o seja o n\u00famero escolhido pelo jogo dever\u00e1 marcar um contador de erro - O jogador come\u00e7a com 1000 pontos caso aconte\u00e7a um erro cada contador de erro deve subtrair 100 pontos - Caso o jogador perca o jogo dever\u00e1 ter um menu informando pra fechar o jogo ou jogar novamente - Caso o jogador ven\u00e7a dever\u00e1 mostrar o placar que ele obteve o a op\u00e7\u00e3o de sair do jogo ou tentar novamente.</p>"},{"location":"1_2_jogo_da_adivinhacao/#comecando-o-projeto","title":"Come\u00e7ando o projeto","text":"<p>Vamos iniciar um novo projeto em nossa pasta projects</p> <pre><code>cd ~/projects\ncargo new guessing_game\n</code></pre> <p>Agora para iniciar o nosso jogo vamos fazer o loop que j\u00e1 conhecemos e vamos criar o menu recebendo o input do usu\u00e1rio e imprimir na tela o valor escolhido e caso ele escolha iniciar vamos imprimir que o jogo come\u00e7ou e caso ele sair n\u00f3s vamos encerrar o jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        println!(\"A sua escolha foi {}\", escolha_str);\n        break;\n    }\n\n}\n</code></pre> <p>Aqui vamos mudar ao inv\u00e9s de usar n\u00fameros para op\u00e7\u00f5es vamos usar letras pois vamos precisar fazer um tratamento especial no c\u00f3digo, estamos usando a captura que estavamos fazendo anteriormente fazendo um println apenas no item escolhido, no final vamos dar um break apenas pra encerrar o loop. Agora se rodarmos o c\u00f3digo vamos ver que ele pegou a escolha que gostariamos e printou na tela.</p> <pre><code>cargo run\n</code></pre> <p>Certo agora vamos fazer um match com nossa escolha str s\u00f3 que como estamos usando letras vou for\u00e7ar que o que venha de letras senha minuscula ou maiuscula que ele force sempre a ser min\u00fasculo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n        };\n==\n\n    }\n}\n</code></pre> <p>Criamos a nossa linha como <code>match escolha.str.trim().to_lowercase()</code> usando a fun\u00e7\u00e3o <code>trim()</code> para removermos espa\u00e7os em branco e agora usamos uma nova fun\u00e7\u00e3o chamada <code>to_lowercase()</code> que vai transformar nossa string caso tenha letras maiusculas em min\u00fasculas. Outra fun\u00e7\u00e3o que usamos foi o <code>as_str</code> pois quando usamos o <code>trim</code> e o <code>to_lowercase</code> eles voltam uma String que \u00e9 um tipo diferente do str, e nesse caso vamos comparar com \"i\" e \"q\" e quando passamos esses valores com aspas eles s\u00e3o do tipo str ent\u00e3o pra comparar vamos precisar reconverter novamente para str e ai usamos o <code>as_str</code>.</p> <p>Assim conseguimos agora colocar a compara\u00e7\u00e3o com a string \"i\" e a string \"q\".</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                println!(\"Iniciar Jogo\");\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n==\n\n    }\n}\n</code></pre> <p>Aqui colocamos o \"i\" para imprimir e usamos o <code>continue</code> para voltar ao inicio do loop. No caso o jogador use \"q\" o programa vai ser encerrado. Tamb\u00e9m usamos o coringa \"_\" caso seja dada outra op\u00e7\u00e3o que n\u00e3o seja \"i\" ou \"q\" n\u00f3s colocamos a mensagem de erro e reiniciamos o loop.</p> <p>Agora podemos testar e verificar se nossa fun\u00e7\u00e3o est\u00e1 correta.</p>"},{"location":"1_2_jogo_da_adivinhacao/#seguranca-de-memoria","title":"Seguran\u00e7a de Mem\u00f3ria","text":"<p>Rust fornece uma s\u00e9rie de garantias de seguran\u00e7a de mem\u00f3ria durante o tempo de compila\u00e7\u00e3o. Essas garantias s\u00e3o fundamentais para evitar erros comuns, como vazamentos de mem\u00f3ria, refer\u00eancias nulas e acessos inv\u00e1lidos.</p> <ul> <li>Sem Refer\u00eancias Nulas: Rust garante que as refer\u00eancias n\u00e3o sejam nulas, eliminando muitos erros de acesso nulo.</li> <li>Sem Vazamentos de Mem\u00f3ria: Rust controla rigorosamente o ciclo de vida dos recursos, o que impede vazamentos de mem\u00f3ria.</li> <li>Sem Concorr\u00eancia de Dados Mut\u00e1veis: Rust imp\u00f5e regras rigorosas para evitar a concorr\u00eancia de dados mut\u00e1veis, garantindo a seguran\u00e7a em threads.</li> </ul> <p>Exitem 3 locais de mem\u00f3ria que trabalhamos com rust que \u00e9 a mem\u00f3ria est\u00e1tica, stack e heap.</p> <p></p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-estatica","title":"Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 onde fica o bin\u00e1rio do nosso programa, vari\u00e1veis est\u00e1ticas, strings literais. N\u00f3s conhecemos ela em tempo de compila\u00e7\u00e3o pois o rust vai reservar a mem\u00f3ria necess\u00e1ria para acomodar os recursos criados aqui. Ela possui um tamanho fixo e essa mem\u00f3ria existe durante o tempo de aloca\u00e7\u00e3o do programa e \u00e9 liberada assim que o programa \u00e9 encerrado e a forma mais r\u00e1pida de acessar um recurso.</p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-stack","title":"Mem\u00f3ria Stack","text":"<p>A mem\u00f3ria stack armazena argumentos de fun\u00e7\u00f5es e variaveis locais ou seja recursos dentro de um bloco de fun\u00e7\u00e3o quando trabalhamos com v\u00e1rias threads cada thread vai ter uma stack especifica e ele \u00e9 conhecido em tempo de compila\u00e7\u00e3o por\u00e9m ele tem um tamanho din\u00e2mico dentro de um limite especifico, quando esse limite \u00e9 estourado recebemos o famoso erro stack overflow. Como \u00e9 uma mem\u00f3ria din\u00e2mica o gatilho pra liberar a mem\u00f3ria \u00e9 quando uma fun\u00e7\u00e3o \u00e9 encerrada.</p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-heap","title":"Mem\u00f3ria Heap","text":"<p>A mem\u00f3ria heap \u00e9 um tipo de mem\u00f3ria onde armazenamos valores din\u00e2micos ou seja que durante a execu\u00e7\u00e3o de um programa pode variar, por exemplo num jogo onde recebemos o nome do jogador n\u00f3s n\u00e3o vamos saber previamente o tamanho do nome do mesmo ent\u00e3o ele ser\u00e1 armazenado na mem\u00f3ria heap. Ele \u00e9 usado sempre que tivermos vari\u00e1veis que s\u00e3o muito grandes ou qual eu n\u00e3o conhe\u00e7a o valor previamente. Quanto trabalhamos com threads esse valor \u00e9 compartilhado e n\u00e3o sabemos em tempo de compila\u00e7\u00e3o onde o valor dispon\u00edvel normalmente \u00e9 fornecido pelo sistema operacional. O tempo de vida dessas vari\u00e1veis ser\u00e3o determinados pelo programador ou pela linguagem usada e no caso do Rust ela \u00e9 liberada usando RAII.</p>"},{"location":"1_2_jogo_da_adivinhacao/#o-que-e-raii","title":"O que \u00e9 RAII?","text":"<p>RAII significa \"Resource Acquisition Is Initialization\". \u00c9 um princ\u00edpio de programa\u00e7\u00e3o utilizado em linguagens como C++ e Rust. A ideia principal por tr\u00e1s do RAII \u00e9 associar a aquisi\u00e7\u00e3o de recursos \u00e0 inicializa\u00e7\u00e3o de objetos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#diferenca-entre-str-e-string","title":"Diferen\u00e7a entre &amp;str e String","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o moderna que coloca um forte foco na seguran\u00e7a e no gerenciamento de mem\u00f3ria, permitindo aos desenvolvedores escrever c\u00f3digo seguro e eficiente. Duas estruturas de dados muito importantes em Rust s\u00e3o &amp;str e String. Embora ambas sejam usadas para representar texto, elas t\u00eam diferen\u00e7as fundamentais em termos de propriedades e uso. Vamos explorar as distin\u00e7\u00f5es entre &amp;str e String em Rust.</p> <p>&amp;str - Refer\u00eancia para uma Sequ\u00eancia de Caracteres</p> <p>\u00c9 importante refor\u00e7ar que caratere representa um simbolo em Rust e ele \u00e9 um tipo primitivo que acabamos n\u00e3o vendo ainda, o tipo str \u00e9 uma sequ\u00eancia de caracteres que \u00e9 o tipo primitivo. &amp;str \u00e9 uma fatia (slice) que representa uma sequ\u00eancia de caracteres em Rust. Essa fatia \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres armazenada em outro local da mem\u00f3ria. Aqui est\u00e3o algumas caracter\u00edsticas importantes do &amp;str:</p> <pre><code>Imut\u00e1vel: O &amp;str \u00e9 imut\u00e1vel, o que significa que voc\u00ea n\u00e3o pode modificar o conte\u00fado da sequ\u00eancia de caracteres a que ele faz refer\u00eancia.\n\nAloca\u00e7\u00e3o Zero: O &amp;str em si n\u00e3o aloca mem\u00f3ria para a sequ\u00eancia de caracteres. Ele simplesmente aponta para uma sequ\u00eancia existente.\n\nView (Vis\u00e3o): O &amp;str \u00e9 uma vis\u00e3o de uma sequ\u00eancia de caracteres (tipo primitivo). Pode ser usado para referenciar substrings de uma String ou literais de string.\n\nLifetime: O &amp;str \u00e9 um tipo est\u00e1tico ou seja ele vai alocar a mem\u00f3ria quando o programa \u00e9 compilado e vai existir durante todo o tempo em que o programa for executado.\n</code></pre> <p>Aqui est\u00e1 um exemplo de &amp;str:</p> <pre><code>fn main() {\n    let texto: &amp;str = \"Ol\u00e1, Mundo!\";\n    println!(\"{}\", texto);\n}\n\n</code></pre> <p>String - Propriedade de uma Sequ\u00eancia de Caracteres</p> <p>String \u00e9 uma estrutura de dados que representa uma sequ\u00eancia de caracteres alocada dinamicamente em Rust. Aqui est\u00e3o algumas caracter\u00edsticas importantes da String:</p> <pre><code>Mut\u00e1vel: A String \u00e9 mut\u00e1vel, o que significa que voc\u00ea pode modificar seu conte\u00fado, adicionando ou removendo caracteres.\n\nAloca\u00e7\u00e3o Din\u00e2mica: A String aloca mem\u00f3ria dinamicamente para armazenar a sequ\u00eancia de caracteres. Isso permite que voc\u00ea ajuste o tamanho conforme necess\u00e1rio.\n\nPropriet\u00e1ria: A String \u00e9 propriet\u00e1ria, o que significa que \u00e9 respons\u00e1vel por gerenciar a mem\u00f3ria da sequ\u00eancia de caracteres que ela cont\u00e9m.\n\nConvers\u00e3o: Voc\u00ea pode converter um &amp;str em uma String usando a fun\u00e7\u00e3o to_string(), ou usar a fun\u00e7\u00e3o String::from().\n</code></pre> <p>Aqui est\u00e1 um exemplo de String:</p> <pre><code>fn main() {\n    let mut texto: String = String::from(\"Ol\u00e1, \");\n    texto.push_str(\"Mundo!\");\n    println!(\"{}\", texto);\n}\n</code></pre> <p>Quando Usar &amp;str e String</p> <p>A escolha entre &amp;str e String depende do contexto e dos requisitos do seu programa:</p> <pre><code>Use &amp;str quando precisar de uma refer\u00eancia imut\u00e1vel a uma sequ\u00eancia de caracteres existente. Por exemplo, ao passar argumentos de fun\u00e7\u00e3o ou realizar opera\u00e7\u00f5es de leitura em uma sequ\u00eancia.\n\nUse String quando precisar de uma sequ\u00eancia de caracteres mut\u00e1vel que pode ser modificada. Por exemplo, para construir uma sequ\u00eancia de caracteres dinamicamente.\n\nLembre-se de que &amp;str e String s\u00e3o intercambi\u00e1veis por meio de convers\u00f5es quando necess\u00e1rio.\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#alocacao-de-memoria-em-rust","title":"Aloca\u00e7\u00e3o de mem\u00f3ria em Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o conhecida por seu controle rigoroso sobre a mem\u00f3ria. Ela oferece diversos tipos de mem\u00f3ria com comportamentos distintos, o que \u00e9 fundamental para garantir a seguran\u00e7a e o desempenho dos programas. Vamos explorar os principais tipos de mem\u00f3ria em Rust e como eles se comportam.</p>"},{"location":"1_2_jogo_da_adivinhacao/#1-stack-pilha","title":"1. Stack (Pilha)","text":"<p>A pilha, ou stack, \u00e9 um local de armazenamento de mem\u00f3ria de curto prazo e \u00e9 usada para alocar vari\u00e1veis locais e controlar a execu\u00e7\u00e3o do programa. Aqui est\u00e3o algumas caracter\u00edsticas da pilha:</p> <ul> <li>Alcance Limitado: As vari\u00e1veis alocadas na pilha t\u00eam um tempo de vida limitado e s\u00e3o desalocadas automaticamente quando saem do escopo.</li> <li>Aloca\u00e7\u00e3o R\u00e1pida: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria na pilha \u00e9 r\u00e1pida, pois segue uma ordem rigorosa de LIFO (\u00faltimo a entrar, primeiro a sair).</li> <li>Tamanho Conhecido em Tempo de Compila\u00e7\u00e3o: O tamanho das vari\u00e1veis alocadas na pilha deve ser conhecido em tempo de compila\u00e7\u00e3o.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o na pilha:</p> <pre><code>fn main() {\n    let x = 42; // Vari\u00e1vel \"x\" alocada na pilha\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#2-heap","title":"2. Heap","text":"<p>O heap \u00e9 um local de armazenamento de mem\u00f3ria de longo prazo, usado para alocar dados cujo tamanho n\u00e3o \u00e9 conhecido em tempo de compila\u00e7\u00e3o e/ou que precisam de tempo de vida mais longo. Aqui est\u00e3o algumas caracter\u00edsticas do heap:</p> <ul> <li>Alcance Mais Amplo: Os dados alocados no heap podem ter um tempo de vida mais longo e persistir al\u00e9m do escopo atual.</li> <li>Aloca\u00e7\u00e3o e Libera\u00e7\u00e3o Controladas: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria no heap s\u00e3o controladas manualmente pelo programador, usando fun\u00e7\u00f5es como Box::new, Vec::new, etc.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o no heap:</p> <pre><code>fn main() {\n    let x = Box::new(42); // Vari\u00e1vel \"x\" alocada no heap\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#3-memoria-estatica","title":"3. Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 usada para armazenar dados que t\u00eam um tempo de vida durante toda a execu\u00e7\u00e3o do programa. Ela \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada durante a execu\u00e7\u00e3o.</p> <ul> <li>Tempo de Vida Global: Os dados est\u00e1ticos t\u00eam um tempo de vida global e existem durante toda a execu\u00e7\u00e3o do programa.</li> <li>Aloca\u00e7\u00e3o em Tempo de Compila\u00e7\u00e3o: A mem\u00f3ria est\u00e1tica \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada ou realocada.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o de mem\u00f3ria est\u00e1tica:</p> <pre><code>static HELLO: &amp;str = \"Hello, World!\";\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#4-string-vs-str","title":"4. String vs &amp;str","text":"<p>Rust distingue entre String e &amp;str. String \u00e9 uma sequ\u00eancia de caracteres alocada no heap, que permite modifica\u00e7\u00f5es. &amp;str \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres (geralmente String ou literal de string) e \u00e9 imut\u00e1vel.</p> <ul> <li>Use String quando precisar de uma sequ\u00eancia de caracteres que pode ser modificada.</li> <li>Use &amp;str para referenciar sequ\u00eancias de caracteres imut\u00e1veis.</li> </ul> <pre><code>fn main() {\n    let s1: String = String::from(\"Hello\");\n    let s2: &amp;str = \"World\";\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#criando-a-funcao-do-jogo","title":"Criando a fun\u00e7\u00e3o do jogo","text":"<p>Agora vamos criar uma fun\u00e7\u00e3o onde vamos manter nossa l\u00f3gica do jogo para isso vamos usar a palavra reservada fn</p> <pre><code>fn game() -&gt; () {\n    println!(\"Iniciar Jogo\");\n}\n</code></pre> <p>Com isso movemos nosso print iniciar jogo para dentro da fun\u00e7\u00e3o e vamos ver que vai continuar funcionando vale notar que na fun\u00e7\u00e3o n\u00f3s anotamos <code>()</code> que quer dizer que a fun\u00e7\u00e3o vai retornar uma Option vazia ou seja se for OK v\u00e3o vai ter valor algum isso faz a fun\u00e7\u00e3o main que chama a fun\u00e7\u00e3o game saber que essa fun\u00e7\u00e3o n\u00e3o tem retorno se n\u00f3s tentarmos receber algum valor de game n\u00f3s vamos receber a Option por\u00e9m ela vai ver sem nenhum valor, com isso n\u00f3s nunca vamos receber um valor Nulo no m\u00e1ximo um Option com um Ok por\u00e9m n\u00e3o existe um valor empty ou None isso \u00e9 uma caracteristica do rust para trabalhar sem usar valores nulos. Agora quero que nosso jogo defina o n\u00famero secreto, nesse momento vamos definir um n\u00famero fixo, mais a frente vamos fazer esse n\u00famero ser aleat\u00f3rio, tamb\u00e9m vamos receber a pontua\u00e7\u00e3o do jogador e vamos j\u00e1 contar um erro e o fim do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                ==\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(pontuacao=_pontuacao, numero=_numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game(pontuacao: u16, numero: u8) -&gt; () {\n    println!(\"Iniciar Jogo\");\n    ==\n    pontuacao = pontuacao - 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n    ==\n}\n</code></pre> <p>Se tentarmos compilar vamos receber o erro abaixo:</p> <pre><code>\u276e cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0384]: cannot assign to immutable argument `pontuacao`\n  --&gt; src/main.rs:35:5\n   |\n33 | fn game(pontuacao: u16, numero: u8) -&gt; () {\n   |         --------- help: consider making this binding mutable: `mut pontuacao`\n34 |     println!(\"Iniciar Jogo\");\n35 |     pontuacao = pontuacao - 100;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to previous error\n</code></pre> <p>Essa mensagem diz que pontua\u00e7\u00e3o dentro de game \u00e9 um atributo imut\u00e1vel ent\u00e3o precisamos deixar nosso parametro mut\u00e1vel. ent\u00e3o simplesmente vamos usar um mut no cabe\u00e7alho da fun\u00e7\u00e3o game.</p> <pre><code>fn game(mut pontuacao: u16, numero: u8) -&gt; () {\n...\n</code></pre> <p>Agora se rodarmos vai voltar o resultado que gostariamos.</p> <pre><code>Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\n...\n</code></pre> <p>Agora vamos mudar um pouco queremos que nosso print do resultado tamb\u00e9m seja impresso depois que o loop do game acabar ent\u00e3o vamos copia-lo pra fora da fun\u00e7\u00e3o.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(_pontuacao, _numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n</code></pre> <p>Agora vamos receber essa saida</p> <pre><code>\u279c cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\n     Running `target/debug/guessing_game`\nBem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n</code></pre> <p>O que aconteceu? Acontece que do jeito que est\u00e1 a fun\u00e7\u00e3o game est\u00e1 recebendo uma c\u00f3pia dos valores de _pontuacao e _numero_alvo ou seja o valor reduzido de 900 s\u00f3 existe dentro da fun\u00e7\u00e3o game quando a fun\u00e7\u00e3o termina o rust limpa as vari\u00e1veis do escopo de game poderiamos facilmente resolver isso fazendo com que game retorne o valor de 900 para nossa vari\u00e1vel _pontuacao mas, podemos resolver isso sem precisar duplicar os valores dentro da fun\u00e7\u00e3o passando a refer\u00eancia delas atrav\u00e9s de Borrowing que \u00e9 o que vamos discutir a seguinte.</p>"},{"location":"1_2_jogo_da_adivinhacao/#ownership-e-borrowing","title":"Ownership e Borrowing","text":"<p>Rust introduz o conceito de \"ownership\" (propriedade) e \"borrowing\" (empr\u00e9stimo) para gerenciar a mem\u00f3ria de forma segura. Isso implica que, em Rust, voc\u00ea precisa seguir regras rigorosas para acessar e modificar a mem\u00f3ria. A ideia principal \u00e9 que um recurso s\u00f3 pode ser possu\u00eddo por uma \u00fanica parte do c\u00f3digo em um determinado momento.</p> <ul> <li>Propriedade (Ownership): Uma vari\u00e1vel \u00e9 a \"dona\" de um recurso e \u00e9 respons\u00e1vel por liber\u00e1-lo quando n\u00e3o for mais necess\u00e1rio.</li> <li>Empr\u00e9stimo (Borrowing): Outras partes do c\u00f3digo podem \"emprestar\" acesso \u00e0 vari\u00e1vel, mas n\u00e3o podem modificar a propriedade.</li> </ul> <p>Assim sendo no nosso caso particular podemos pedir pro rust nos dar as refer\u00eancias das vari\u00e1veis _pontuacao e _numero_alvo assim sendo ele n\u00e3o cria uma nova vari\u00e1vel <code>numero</code> e <code>pontuacao</code> ele vai simplesmente pegar a referencia onde est\u00e1 armazenado os valores de _pontuacao e _numero_alvo e come\u00e7ar a apontar para os parametros que existem na fun\u00e7\u00e3o assim quando a fun\u00e7\u00e3o terminar ela vai devolver as refer\u00eancias para os parametros originais.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                ==\n                game(&amp;mut _pontuacao, &amp;_numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\n==\nfn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n==\n    println!(\"Iniciar Jogo\");\n    ==\n    *pontuacao -= 100;\n    ==\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Aqui fizemos algumas altera\u00e7\u00f5es a primeira \u00e9 que passamos na vari\u00e1vel o simbolo \"&amp;\" que indica que estamos emprestando a refer\u00eancia para a fun\u00e7\u00e3o ou seja ela vai ser tempor\u00e1riamente a dona dos parametros passados e no caso de pontua\u00e7\u00e3o n\u00f3s passamos como &amp;mut que quer dizer que ela pode ser modificada, caso fosse passado apenas om o &amp; comercial a fun\u00e7\u00e3o game s\u00f3 teria a permiss\u00e3o de ler o parametro e n\u00e3o modificalo.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n</code></pre> <p>No cabe\u00e7alho da fun\u00e7\u00e3o mudamos tamb\u00e9m indicando que pontua\u00e7\u00e3o \u00e9 a referencia mutavel de um u16 e a referencia de u8 assim na compila\u00e7\u00e3o ele sabe que a fun\u00e7\u00e3o est\u00e1 trabalhando com refer\u00eancias e n\u00e3o vai criar uma c\u00f3pia da fun\u00e7\u00e3o.</p> <p>Por ultimo vamos fazer uma altera\u00e7\u00e3o na nossa opera\u00e7\u00e3o de subtra\u00e7\u00e3o</p> <pre><code>    *pontuacao -= 100;\n</code></pre> <p>Usamos o simbilo \"*\" para indicar que n\u00e3o queremos mexer na refer\u00eancia onde est\u00e1 pontuacao mas, no valor que ele possui assim o valor que estava em _pontuacao mudou de 1000 para 900.</p> <p>Agora com isso conseguimos compreender as linhas onde capturamos a entrada do teclado do jogador</p> <pre><code>        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>Onde criamos uma vari\u00e1vel escolha_str que \u00e9 uma String vazia e mut\u00e1vel e quando chamamos a fun\u00e7\u00e3o read_line n\u00f3s passamos a refer\u00eancia mut\u00e1vel de escolha_str e enquanto ela est\u00e1 em execu\u00e7\u00e3o ela est\u00e1 alterando o valor do <code>escolha_str</code> para n\u00f3s e quando termina conseguimos usar o valor de escolha_str com os valores modificados pela fun\u00e7\u00e3o <code>read_line</code> sem precisar duplicar a vari\u00e1vel dentro da fun\u00e7\u00e3o.  \u00c9 importante refor\u00e7ar que em muitas linguagens n\u00e3o conseguimos fazer isso n\u00f3s normalmente precisamos receber a copia modificada dentro da fun\u00e7\u00e3o para conseguir trabalhar. Essa caracter\u00edstica do rust \u00e9 muito importante para casos que trabalhamos com pouca mem\u00f3ria ou mesmo um jogo onde quanto menos recursos usarmos mais leve ser\u00e1 nosso jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introducao-sobre-testes-de-software","title":"Introdu\u00e7\u00e3o sobre testes de software","text":"<p>A programa\u00e7\u00e3o \u00e9 uma tarefa complexa que envolve a cria\u00e7\u00e3o de software que seja confi\u00e1vel, eficiente e livre de erros. \u00c0 medida que os projetos de desenvolvimento de software crescem em complexidade, torna-se cada vez mais cr\u00edtico garantir a qualidade do c\u00f3digo. Uma das abordagens mais eficazes para assegurar a qualidade do software \u00e9 a pr\u00e1tica de testes, especialmente o Desenvolvimento Orientado a Testes (TDD).</p> <p>Ent\u00e3o vamos agora explorar sobre a import\u00e2ncia dos testes na programa\u00e7\u00e3o e como o TDD pode ser uma ferramenta valiosa para alcan\u00e7ar um c\u00f3digo mais robusto e confi\u00e1vel. Vamos mergulhar no mundo dos testes e entender por que eles s\u00e3o essenciais para qualquer desenvolvedor de software.</p> <p>Os testes desempenham um papel fundamental no processo de desenvolvimento de software por v\u00e1rias raz\u00f5es:</p> <ul> <li>Detec\u00e7\u00e3o Precoce de Erros: Os testes permitem que os desenvolvedores identifiquem e corrijam erros em um est\u00e1gio inicial do desenvolvimento, economizando tempo e recursos no longo prazo.</li> <li>Manuten\u00e7\u00e3o Simplificada: Um c\u00f3digo bem testado \u00e9 mais f\u00e1cil de manter. Quando novos recursos s\u00e3o adicionados ou modifica\u00e7\u00f5es s\u00e3o feitas, os testes garantem que as funcionalidades existentes continuem funcionando conforme o esperado.</li> <li>Redu\u00e7\u00e3o de Bugs em Produ\u00e7\u00e3o: Testar seu c\u00f3digo ajuda a evitar que bugs cheguem aos usu\u00e1rios finais, resultando em uma melhor experi\u00eancia do cliente e economizando custos associados \u00e0 corre\u00e7\u00e3o de problemas em produ\u00e7\u00e3o.</li> <li>Documenta\u00e7\u00e3o Autom\u00e1tica: Testes bem escritos funcionam como documenta\u00e7\u00e3o viva do seu c\u00f3digo. Eles descrevem como as diferentes partes do software devem se comportar.</li> <li>Confian\u00e7a no C\u00f3digo: Testar seu c\u00f3digo cria confian\u00e7a tanto para os desenvolvedores quanto para os usu\u00e1rios. Saber que o software passou em uma bateria de testes proporciona tranquilidade.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#desenvolvimento-orientado-a-testes-tdd","title":"Desenvolvimento Orientado a Testes (TDD)","text":"<p>O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem de desenvolvimento que enfatiza a escrita de testes antes de escrever o c\u00f3digo real. O ciclo TDD segue tr\u00eas passos simples: \"Red-Green-Refactor.\"</p> <ul> <li>Red (Vermelho): Neste est\u00e1gio, voc\u00ea escreve um teste que descreve a funcionalidade que deseja implementar. Como voc\u00ea ainda n\u00e3o escreveu o c\u00f3digo, o teste falhar\u00e1.</li> <li>Green (Verde): Agora, voc\u00ea escreve o c\u00f3digo m\u00ednimo necess\u00e1rio para fazer o teste passar. O objetivo \u00e9 fazer o teste passar o mais r\u00e1pido poss\u00edvel.</li> <li>Refactor (Refatorar): Com o teste passando, voc\u00ea pode refatorar o c\u00f3digo para torn\u00e1-lo mais limpo, eficiente e leg\u00edvel.</li> </ul> <p>O TDD oferece in\u00fameras vantagens, incluindo:</p> <ul> <li>Maior Qualidade do C\u00f3digo: TDD incentiva a escrita de c\u00f3digo de alta qualidade desde o in\u00edcio.</li> <li>Projeto Centrado no Usu\u00e1rio: Testes escritos com base nos requisitos do usu\u00e1rio garantem que o software atenda \u00e0s expectativas.</li> <li>Facilidade de Manuten\u00e7\u00e3o: O c\u00f3digo resultante do TDD \u00e9 mais f\u00e1cil de manter, pois as mudan\u00e7as n\u00e3o quebram as funcionalidades existentes.</li> <li>Confian\u00e7a nas Mudan\u00e7as: TDD permite que os desenvolvedores fa\u00e7am altera\u00e7\u00f5es no c\u00f3digo com confian\u00e7a, sabendo que os testes ir\u00e3o detectar problemas.</li> <li>Feedback R\u00e1pido: TDD fornece feedback imediato, acelerando o processo de desenvolvimento.</li> </ul> <p>A import\u00e2ncia dos testes na programa\u00e7\u00e3o n\u00e3o pode ser subestimada. Eles desempenham um papel cr\u00edtico na cria\u00e7\u00e3o de software de alta qualidade, confi\u00e1vel e seguro. O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem valiosa que torna os testes uma parte integrante do processo de desenvolvimento, resultando em um c\u00f3digo mais robusto e confi\u00e1vel.</p> <p>Para os desenvolvedores, a pr\u00e1tica de testes e o uso do TDD representam um investimento que se traduz em economia de tempo, redu\u00e7\u00e3o de custos e satisfa\u00e7\u00e3o do cliente. \u00c0 medida que a ind\u00fastria de software continua a evoluir, a cultura de testes se torna cada vez mais fundamental para o sucesso de projetos de desenvolvimento de software.</p> <p>Portanto, da pr\u00f3xima vez que voc\u00ea come\u00e7ar a escrever c\u00f3digo, lembre-se da import\u00e2ncia dos testes e considere adotar o Desenvolvimento Orientado a Testes como parte integrante do seu processo de desenvolvimento. A qualidade do seu software agradecer\u00e1.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introduzindo-testes-ao-nosso-codigo","title":"Introduzindo testes ao nosso c\u00f3digo","text":"<p>Agora vamos abrir nosso arquivo test_game_loop.rs, esse teste vai ser usado para testarmos nossas condi\u00e7\u00f5es do jogo ent\u00e3o vamos criar um primeiro teste para validar a condi\u00e7\u00e3o que est\u00e1 fixa hoje. Vamos adicionar o c\u00f3digo abaixo no final do nosso main.rs</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero)\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Inicialmente precisamos adicionar uma anota\u00e7\u00e3o annotattion <code>#[test]</code> as anota\u00e7\u00f5es s\u00e3o colocadas no inicio de uma fun\u00e7\u00e3o/m\u00f3dulo/trait para adicionar alguma funcionalidade aquele bloco de c\u00f3digo. NO nosso caso estamos adicionando uma funcionalidade de teste para nossa fun\u00e7\u00e3o de teste <code>test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral</code> assim podemos rodar o comando de teste <code>cargo test</code>. Nossa estrutura de testes \u00e9 divida em 3 partes: - Arrange -&gt; que \u00e9 os dados que precisamos preparar para o teste - Act -&gt; Execu\u00e7\u00e3o do c\u00f3digo que queremos testas - Assert -&gt; Que \u00e9 o que esperamos que aconte\u00e7a depois do c\u00f3digo sendo executado.</p> <p>No caso do assert executamos uma macro nova que \u00e9 o <code>assert_eq!</code> sua fun\u00e7\u00e3o \u00e9 comprar dois valores caso sejam iguais ele termina corretamente, caso sejam diferentes ele vai voltar um erro no nosso teste, vamos primeiro rodar o teste do jeito que est\u00e1.</p> <pre><code>cargo test\n</code></pre> <p>Voc\u00ea deve ter um retorno parecido com esse:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Vale destacar alguns pontos:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n    \n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n     \n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Aqui mostra onde foi compilado o teste</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\n    \nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n     \n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Nessas linhas mostram quantos testes rodaram, o nome do teste que rodou e se foi ok ou n\u00e3o</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\n    \ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n     \n</code></pre> <p>Nessa linha temos um pequeno relat\u00f3rio dos testes quando passaram quantos derram erro e por ai vai, al\u00e9m de tudo mostra o tempo que demorou pra rodar os testes.</p> <p>Agora vamos mudar nosso teste para ele falhar</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    ==assert_eq!(pontuacao, 0)==\n}\n</code></pre> <p>Agora temos uma sa\u00edda diferente</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.12s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral stdout ----\n\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral' panicked at src/main.rs:51:5:\nassertion `left == right` failed\n  left: 900\n right: 0\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\n\nfailures:\n    test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\nerror: test failed, to rerun pass `--bin guessing_game`\n\n</code></pre> <p>\u00c9 importante n\u00e3o ter medo de ler toda a mensagem mesmo que seja grande pois com ela podemos ver o problema.</p> <p>Veja que agora ele mostra a saida da execu\u00e7\u00e3o de game, no caso ele vai mostrar os dois prints que criamos depois ele vai mostrar o erro do assertion mostrando que o valor de pontua\u00e7\u00e3o foi 900 e o valor da direita foi 0 ent\u00e3o sabemos quanto nossa variavel retornou e o valor da compara\u00e7\u00e3o.</p> <p>Tamb\u00e9m podemos ver que agora no nosso relat\u00f3rio temos um teste como failed pois o teste falhou.</p> <p>Vamos agora voltar nosso teste para passar novamente e rodar os testes.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo agora podemos continuar trabalhando no jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-o-chute-do-jogador","title":"Adicionando o chute do jogador","text":"<p>Agora vamos adicionar a captura da entrada do jogador para e vamos passar o valor para nossa fun\u00e7\u00e3o game.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    \n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n    \n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos nosso teste ele ainda vai passar.</p> <pre><code>\u279c  cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos fazer algumas altera\u00e7\u00f5es vamos criar uma nova fun\u00e7\u00e3o que vai atualizar a pontua\u00e7\u00e3o. Mas primeiro vamos mudar nosso teste para verificar com a fun\u00e7\u00e3o check_win_condition e passar mais um parametro chamado chute que vai ser um inteiro tamb\u00e9m.</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_conditition(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Vamos receber agora um erro de compila\u00e7\u00e3o</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0425]: cannot find function `check_win_conditition` in this scope\n  --&gt; src/main.rs:55:5\n   |\n55 |     check_win_conditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n</code></pre> <p>\u00c9 importante sempre ler a mensagem de erro e tentar entender tamb\u00e9m sempre que quiser poder rodar o <code>--explain</code> para ver a descri\u00e7\u00e3o do erro.</p> <pre><code>rustc --explain E0425\n</code></pre> <p>Nesse caso o erro \u00e9 que check_win_conditition n\u00e3o existe dentro  do escopo isso por que ele n\u00e3o foi criado, vamos ent\u00e3o cria-lo e mover o c\u00f3digo respons\u00e1vel por diminuir a pontua\u00e7\u00e3o.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos o teste ele vai funcionar com um warning que logo vamos remove-lo.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `pontuacao`\n  --&gt; src/main.rs:33:9\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pontuacao`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `numero`\n  --&gt; src/main.rs:33:30\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_numero`\n\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:39:59\n   |\n39 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings (run `cargo fix --bin \"guessing_game\" --tests` to apply 3 suggestions)\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>O principal ponto desse warnings \u00e9 que n\u00e3o estamos usando v\u00e1rias variaveis vamos ajusta-las. Primeiro precisamos converter nossa variavel chute para int.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Temos algumas mudan\u00e7as aqui, precisamos mover pontuacao e numero_alvo para dentro da fun\u00e7\u00e3o game, pois n\u00e3o podemos reimprestar  pontuacao para verify_win_conditition essa \u00e9 uma caracteristica do rust ent\u00e3o jogamos tudo para a fun\u00e7\u00e3o game deixando a main apenas para menu. Tamb\u00e9m fizemos o match abaixo para converter a entrada  string para u8 e com isso temos um efeito colateral que precisamos voltar um n\u00famero que no caso \u00e9 0.</p> <pre><code>    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n</code></pre> <p>Agora vamos rodar nosso teste.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:48:59\n   |\n48 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning (run `cargo fix --bin \"guessing_game\" --tests` to apply 1 suggestion)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Vamos agora remover o ultimo warning e vamos come\u00e7ar a usar nosso parametro chute.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    \n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Assim agora apenas se o n\u00famero for menor que o n\u00famero a pontua\u00e7\u00e3o vai mudar. Vamos rodar o teste.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos alterar nossa entrada para n\u00e3o receber o parametro \"_\", pois h\u00e1 uma forma melhor de fazer isso.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        \n        io::stdin().read_line(&amp;mut escolha_str).expect(\"Erro ao receber sua escolha\");\n        \n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    \n    io::stdin().read_line(&amp;mut chute).expect(\"Erro ao receber o n\u00famero\");\n    \n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Aqui retiramos o parametro n\u00e3o usado e colocamo no final um expect isso \u00e9 uma captura de erro, vamos detalhar isso mais a frente mas, se pense que agora caso a option que esteja com algum dado \u00e9 a <code>Err</code> ele vai printar no nosso console as mensagens que colocamos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-vitoria","title":"Adicionando condi\u00e7\u00e3o de vit\u00f3ria","text":"<p>Primeiro passo que vamos fazer \u00e9 criar um teste para a condi\u00e7\u00e3o de vit\u00f3ria:</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(pontuacao, 1000)\n}\n\n</code></pre> <p>Aqui criamos uma fun\u00e7\u00e3o de teste test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao onde simplesmente passamos o n\u00famero correto e ele deve voltar a com a pontua\u00e7\u00e3o exata que passamos. Vamos rodar o teste:</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo o teste est\u00e1 passando vamos fazer com que nossa fun\u00e7\u00e3o retorne que o jogador ganhou, normalmente em muitas linguagens trabalhariamos com um valor de verdadeiro ou falso poderiamos fazer isso aqui tamb\u00e9m, por\u00e9m como o rust nos da a ferramenta do result vamos voltar um tipo Result::Win para dizer que o jogador ganhou, mas como vamos ter outras condi\u00e7\u00f5es vamos criar uma estrutura de enumerador para representar os estados que jogo pode retornar:</p> <pre><code>#[derive(Debug, PartialEq)]\nenum GameResult {\n    Win,\n    Gaming,\n    Lose,\n}\n</code></pre> <p>Vamos primeiro entender o que \u00e9 um enum:</p> <p>! Enum Enum \u00e9 um tipo de dado que representa um conjunto de valores que voc\u00ea quer relacionar no nosso caso estamos criando um conjunto relacionado com os estados que podemos representar sobre a nossa condi\u00e7\u00e3o de vit\u00f3ria \"WIN\" para dizer que o jogador venceu, \"GAMING\" para dizer que o jogador continua jogando, \"LOSE\" para dizer que o jogador perdeu, nosso caso essa representa\u00e7\u00e3o \u00e9 um enum por isso precisamos passar o tipo de dado e o nome desse enum que no nosso caso \u00e9 GameResult. Alguns pontos importantes sobre enums: * Valores Variantes: Em uma enumera\u00e7\u00e3o, voc\u00ea define os valores poss\u00edveis, chamados de \"variantes\". Cada variante representa um valor espec\u00edfico que o tipo de enumera\u00e7\u00e3o pode ter. * Tipos Personalizados: Enums permitem que voc\u00ea crie tipos personalizados com valores limitados. Por exemplo, voc\u00ea pode criar uma enumera\u00e7\u00e3o para representar os dias da semana ou os estados de um jogo. * Padr\u00e3o de Correspond\u00eancia: Enums s\u00e3o frequentemente usadas em combina\u00e7\u00e3o com o padr\u00e3o de correspond\u00eancia (match) para fazer escolhas com base no valor da enumera\u00e7\u00e3o. Isso torna as enums \u00fateis para expressar a l\u00f3gica condicional. * Seguran\u00e7a de Tipos: Enums ajudam a garantir a seguran\u00e7a de tipos, pois o compilador verifica se todas as variantes s\u00e3o tratadas nos padr\u00f5es de correspond\u00eancia. Isso evita erros em tempo de execu\u00e7\u00e3o. * Enumera\u00e7\u00f5es com Dados: Enums podem ter dados associados a suas variantes. Isso permite que voc\u00ea armazene informa\u00e7\u00f5es adicionais com uma variante. Por exemplo, uma enumera\u00e7\u00e3o de formas geom\u00e9tricas pode ter uma variante \"C\u00edrculo\" com um raio associado. * Enums Gen\u00e9ricas: Enums podem ser gen\u00e9ricas, o que significa que voc\u00ea pode parametriz\u00e1-las com tipos de dados, tornando-as vers\u00e1teis e reutiliz\u00e1veis.</p> <p>Enuns podem ter uma chave e um valor como no exemplo abaixo:</p> <pre><code>enum DiaDaSemana {\n    Segunda(u32),\n    Terca(u32),\n    Quarta(u32),\n    Quinta(u32),\n    Sexta(u32),\n    Sabado(u32),\n    Domingo(u32),\n}\n</code></pre> <p>Ou com multiplos valores para representar uma chave como abaixo:</p> <pre><code>enum Cor {\n    RGB(u8, u8, u8),\n    Nome(String),\n}\n</code></pre> <p>H\u00e1 outras formas mas, vamos nos fixar em usa-lo apenas para que a chave e o valor sejam os mesmos que no caso \u00e9 forma que criamos nosso enum sem passar nenhum tipo.</p> <p>Agora usamos uma anota\u00e7\u00e3o nova que \u00e9 o  `#[derive(...)] A anota\u00e7\u00e3o #[derive(...)] em Rust \u00e9 uma caracter\u00edstica poderosa que gera automaticamente a implementa\u00e7\u00e3o de certos tra\u00e7os (traits) para tipos de dados personalizados, como structs e enums. Isso ajuda a evitar a escrita repetitiva de c\u00f3digo ao criar tipos de dados personalizados.</p>"},{"location":"1_2_jogo_da_adivinhacao/#trait","title":"Trait","text":"<p>Em Rust, um trait \u00e9 como um contrato ou um conjunto de regras que um tipo de dado deve seguir. \u00c9 uma maneira de definir comportamentos que tipos diferentes podem compartilhar.</p> <p>Um trait especifica m\u00e9todos que um tipo deve implementar, e outros tipos podem aderir a esse trait, implementando esses m\u00e9todos. Isso permite que diferentes tipos de dados compartilhem funcionalidades comuns.</p> <p>Por exemplo, voc\u00ea pode ter um trait chamado \"Imprim\u00edvel\" que especifica um m\u00e9todo imprimir, e v\u00e1rias estruturas diferentes podem implementar esse trait para que possam ser impressas de maneira semelhante, mesmo que sejam tipos diferentes. Isso torna o c\u00f3digo mais gen\u00e9rico e reutiliz\u00e1vel.</p> <p>Traits usam conceito de polimorfismo.</p> <p>Polimorfismo permite que objetos de diferentes tipos sejam tratados de maneira uniforme, permitindo o uso de m\u00e9todos ou fun\u00e7\u00f5es comuns a esses objetos, independentemente de seus tipos espec\u00edficos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#derive","title":"Derive","text":"<p>A atribui\u00e7\u00e3o #[derive] em Rust permite que os programadores gerem automaticamente a implementa\u00e7\u00e3o de certos tra\u00e7os para suas estruturas de dados, enums ou uni\u00f5es. Ele \u00e9 usado para derivar a implementa\u00e7\u00e3o de tra\u00e7os comuns, como Clone, Debug, Eq, PartialEq, Hash, entre outros, com base na estrutura da sua estrutura de dados.</p> <p>Elas podem ser implementadas diretamente no c\u00f3digo caso precise de um c\u00f3digo mais complexo.</p> <ul> <li>Traits de compara\u00e7\u00e3o: Eq, PartialEq, Ord, PartialOrd.</li> <li>Clone, para criar um novo objeto a partir de outro via copia.</li> <li>Copy, para copiar o elemento ao inv\u00e9s de mover.</li> <li>Hash, para computar um hast a partir &amp;T.</li> <li>Default, para criar um objeto padr\u00e3o do tipo especificado.</li> <li>Debug, para formatar a partir de {:?} formatter.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#vantagens-do-derive","title":"Vantagens do Derive","text":"<p>Facilita a implementa\u00e7\u00e3o de tra\u00e7os comuns para tipos de dados personalizados. Reduz a necessidade de escrever c\u00f3digo manualmente para cada tra\u00e7o. Permite que o compilador Rust gere automaticamente c\u00f3digo de implementa\u00e7\u00e3o eficiente para os tra\u00e7os derivados. Simplifica a manuten\u00e7\u00e3o e o desenvolvimento de c\u00f3digo, tornando-o mais conciso e leg\u00edvel. Voc\u00ea pode criar um c\u00f3digo com <code>#[derive]</code> usando <code>procedural macros</code></p>"},{"location":"1_2_jogo_da_adivinhacao/#procedural-macros","title":"Procedural macros","text":"<p>As macros procedurais s\u00e3o uma caracter\u00edstica avan\u00e7ada do Rust que permite que os desenvolvedores escrevam c\u00f3digo que manipula a representa\u00e7\u00e3o de c\u00f3digo Rust em tempo de compila\u00e7\u00e3o. Essas macros permitem que voc\u00ea escreva c\u00f3digo que gera c\u00f3digo, o que pode ser \u00fatil para automatizar tarefas repetitivas, criar DSLs espec\u00edficas do dom\u00ednio ou realizar transforma\u00e7\u00f5es complexas no c\u00f3digo Rust.</p> <ul> <li>Permitem a gera\u00e7\u00e3o de c\u00f3digo personalizado em tempo de compila\u00e7\u00e3o.</li> <li>Podem ser usadas para automatizar tarefas tediosas ou repetitivas.</li> <li>Permitem a cria\u00e7\u00e3o de DSLs espec\u00edficas do dom\u00ednio para tornar o c\u00f3digo mais expressivo e leg\u00edvel.</li> <li>Podem ser usadas para realizar transforma\u00e7\u00f5es complexas no c\u00f3digo, como otimiza\u00e7\u00f5es de desempenho ou an\u00e1lise est\u00e1tica avan\u00e7ada.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#no-nosso-caso-vamos-passar-algumas-implementacoes-basicas-no-derive","title":"No nosso caso vamos passar algumas implementa\u00e7\u00f5es b\u00e1sicas no derive","text":"<p>Debug <code>derive</code> (#[derive(Debug)]): Ao usar #[derive(Debug)] em uma estrutura ou enumera\u00e7\u00e3o, Rust gera automaticamente a implementa\u00e7\u00e3o do Debug para esse tipo. O <code>derive</code> Debug permite que voc\u00ea formate o valor do tipo de forma leg\u00edvel por humanos quando voc\u00ea imprime um objeto desse tipo usando a fun\u00e7\u00e3o println!(\"{:?}\", objeto). Isso \u00e9 particularmente \u00fatil para fins de depura\u00e7\u00e3o, pois fornece informa\u00e7\u00f5es detalhadas sobre o estado do objeto.</p> <p>PartialEq derive (#[derive(PartialEq)]): Usando #[derive(PartialEq)], Rust gera a implementa\u00e7\u00e3o do trait PartialEq para o tipo. O PartialEq permite que voc\u00ea compare objetos do tipo com operadores de igualdade (==) e desigualdade (!=). Isso significa que voc\u00ea pode verificar se dois objetos s\u00e3o iguais ou diferentes com facilidade, simplificando a l\u00f3gica de compara\u00e7\u00e3o.</p> <p>Certo agora vamos ajustar o teste para nossa fun\u00e7\u00e3o:</p> <pre><code>#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    ==let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);==\n\n    //Assert\n    ==assert_eq!(result, Ok(GameResult::Win));==\n    assert_eq!(pontuacao, 1000)\n}\n</code></pre> <p>Ali colocamos uma variavel para receber o retorno da nossa fun\u00e7\u00e3o chamado result e tamb\u00e9m verificamos se essa variav\u00e9l result retorna no seu ResultSet o valor do enum GameResult como Win que \u00e9 o valor do enum que criamos. Agora vamos rodar o teste.</p> <pre><code>cargo test\n</code></pre> <p>Com o seguinte resultado</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:89:24\n   |\n89 |     assert_eq!(result, Ok(GameResult::Win));\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `()`, found `Result&lt;GameResult, _&gt;`\n   |\n   = note: expected unit type `()`\n                   found enum `Result&lt;GameResult, _&gt;`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n</code></pre> <p>Isso ocorreu por que estamos voltando um ResultSet vazio e ele esperava um ResultSet com um GameResult, ent\u00e3o vamos mudar o retorno da nossa fun\u00e7\u00e3o.</p> <pre><code>...\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n...\n</code></pre> <p>Aqui falamos que o result tem o OK como  um <code>GameResult</code> e o Erro tamb\u00e9m como um <code>GameResult</code> vamos rodar o teste.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:59:5\n   |\n59 |     println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;GameResult, ...&gt;`, found `()`\n   |\n   = note:   expected enum `Result&lt;GameResult, GameResult&gt;`\n           found unit type `()`\n   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n\n</code></pre> <p>Aqui fala que o problema \u00e9 que temos um print no final da fun\u00e7\u00e3o vamos colocar no final um <code>GameResult::Gaming</code> para mostrar a condi\u00e7\u00e3o que o jogo ainda n\u00e3o terminou.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero);\n    ==Ok(GameResult::Gaming)==\n}\n</code></pre> <p>Aqui colocamos de maneira explicita no final ele vai retornar um result do tipo <code>OK</code> com o valor Gaming do nosso enum. Vale atentar que precisamos agora colocar um  \";\" no nosso print. Agora vamos rodar os testes:</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: variant `Lose` is never constructed\n --&gt; src/main.rs:7:5\n  |\n4 | enum GameResult {\n  |      ---------- variant in this enum\n...\n7 |     Lose,\n  |     ^^^^\n  |\n  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:51:5\n   |\n51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:73:5\n   |\n73 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n73 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao stdout ----\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n\nthread 'test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao' panicked at src/main.rs:90:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Win)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\n\nfailures:\n    test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n</code></pre> <p>Aqui vamos ter alguns warnings, mas no ponto de destaque mostra ainha que deu erro, no meu caso ainha 90 e mostra que ele espearava um <code>Ok(Win)</code> mas, recebeu um <code>Ok(Gaming)</code>. Ent\u00e3o finalmente  podemos agora colocar nosso bloco de c\u00f3digo que determina que o usu\u00e1rio venceu que nesse caso ser\u00e1 um if.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n    \n    if chute == numero {\n        return Ok(GameResult::Win)\n    }\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero);\n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui comparamos que o chute \u00e9 igual ao n\u00famero e caso essa compara\u00e7\u00e3o seja verdadeira precisamos colocar a palavra chave return com o  <code>Ok(GameResult::Win)</code> pois temos mais c\u00f3digo que vai ser executado abaixo dele ent\u00e3o estamos for\u00e7ando um retorno prematuro.</p> <p>Agora vamos rodar os testes.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: variant `Lose` is never constructed\n --&gt; src/main.rs:7:5\n  |\n4 | enum GameResult {\n  |      ---------- variant in this enum\n...\n7 |     Lose,\n  |     ^^^^\n  |\n  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:51:5\n   |\n51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:76:5\n   |\n76 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n76 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings\n    Finished test [unoptimized + debuginfo] target(s) in 0.14s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Ainda temos alguns warnings mas, nossos testes voltaram a passar.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-derrota","title":"Adicionando condi\u00e7\u00e3o de derrota","text":"<p>Bom agora vamos criar uma condi\u00e7\u00e3o pra nossa fun\u00e7\u00e3o registrar a derrota. Mas, primeiro vamos criar o teste.</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    == let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Win));\n    assert_eq!(pontuacao, 1000)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n</code></pre> <p>Nesse teste diminuimos a pontua\u00e7\u00e3o e erramos pra baixo e ele deve voltar o rusult como Lose e a pontua\u00e7\u00e3o como 0. Ent\u00e3o vamos testar.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.17s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 3 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo stdout ----\n\nA sua pontua\u00e7\u00e3o foi 0, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo' panicked at src/main.rs:119:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Lose)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo\n\ntest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n</code></pre> <p>Bom tivemos um erro por que voltou Gaming ao inv\u00e9s de Lose, para arrumarmos isso vamos ajustar nossa fun\u00e7\u00e3o.</p> <pre><code>fn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    \n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    \n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero\n    );\n    Ok(GameResult::Gaming)\n}\n\n</code></pre> <p>Aqui adicionamos mais uma condi\u00e7\u00e3o para que se a pontua\u00e7\u00e3o for menor ou igual a 0 retornamos <code>GameResult::Lose</code> pra fun\u00e7\u00e3o chamadora, agora vamos testar novamente.</p> <pre><code>\u276e cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 3 tests\ntest test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Perfeito agora nosso teste passou mas, vamos criar outro teste passando nosso chute sendo um valor maior que o n\u00famero alvo.</p> <pre><code>#[test]\n== fn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() { ==\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n</code></pre> <p>Aqui renomeamos o nosso teste anterior pra explicitar que estamos chutando um n\u00famero baixo e criamos outro explicitando que estamos chutando um n\u00famero altoi, agora rodando os testes teremos uma falha.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.14s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 4 tests\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... FAILED\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\nfailures:\n\n---- test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo stdout ----\n\nA sua pontua\u00e7\u00e3o foi 100, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo' panicked at src/main.rs:137:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Lose)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo\n\ntest result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n\n</code></pre> <p>Como podemos ver ele voltou Gaming ao inv\u00e9s de Lose isso por que n\u00e3o implementamos a condi\u00e7\u00e3o pra que o valor maior decremente ent\u00e3o vamos cria-la.</p> <pre><code> check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        *pontuacao -= 100;\n    }\n    \n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero\n    );\n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui colocamos nossa condi\u00e7\u00e3o de decrementar a pontua\u00e7\u00e3o com um erro como a primeira coisa a ser verificada, para evitar qualquer problema de ser decrementado ap\u00f3s verificar a condi\u00e7\u00e3o de vit\u00f3ria, assim adicionamos mais um if no nosso c\u00f3digo e podemos rodar o teste para verificar se est\u00e1 passando.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 4 tests\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Bom agora conseguimos ter a condi\u00e7\u00e3o de derrota no nosso jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#criando-mais-testes","title":"Criando mais testes","text":"<p>Bom agora que temos nossa condi\u00e7\u00e3o para decrementar a pontua\u00e7\u00e3o quando erramos pra cima ou pra baixo, precisamos ajustar nosso teste test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral para receber a condi\u00e7\u00e3o <code>GameResult::Gaming</code> e tamb\u00e9m criar um novo teste para explicitar o chute pra cima e o outro pra baixo.</p> <pre><code> -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    io::stdin()\n        .read_line(&amp;mut chute)\n        .expect(\"Erro ao receber o n\u00famero\");\n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; {\n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    ==let _result = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute); ==\n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero_alvo\n    );\n}\n\n...\n#[test]\n fn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() { \n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    == let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Aqui mudamos o nome do teste anterior e criamos um novo al\u00e9m de adiconar o result para verifica\u00e7\u00e3o e tamb\u00e9m pra nossa fun\u00e7\u00e3o game, o agora se rodarmos os testes os warnings v\u00e3o desaparecer.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.12s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#melhorando-nossa-funcao-de-condicao-e-ajustando-a-funcao-game","title":"Melhorando nossa fun\u00e7\u00e3o de condi\u00e7\u00e3o e ajustando a fun\u00e7\u00e3o game.","text":"<p>Bom poderiamos agora criar testes de integra\u00e7\u00e3o pra nossa fun\u00e7\u00e3o game, mas vamos trabalhar isso mais a frente, agora vamos melhorar nossa fun\u00e7\u00e3o game, n\u00e3o importa se acertamos ou \u258derramos n\u00f3s voltamos ao menu principal, ent\u00e3o precisamos s\u00f3 voltar pro loop do menu quando perdemos ou ganharmos o jogo pra isso vamos criar um novo loop no nosso jogo.</p> <pre><code>\nfn game() -&gt; () {\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    loop {\n        println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n        let mut chute = String::new();\n        io::stdin()\n            .read_line(&amp;mut chute)\n            .expect(\"Erro ao receber o n\u00famero\");\n\n        let chute: u8 = match chute.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n                0\n            }\n        };\n        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {\n            Ok(result) =&gt; {\n                if result == GameResult::Win {\n                    println!(\"Parab\u00e9ns voc\u00ea venceu! Sua pontua\u00e7\u00e3o foi {}\", pontuacao);\n                    break;\n                } else if result == GameResult::Lose {\n                    println!(\"Que pena voc\u00ea perdeu!\");\n                    break;\n                }\n            }\n            Err(_) =&gt; {\n                println!(\"Ocorreu um erro e o jogo ser\u00e1 reiniciado!\");\n                break;\n            }\n        };\n        println!(\"A sua pontua\u00e7\u00e3o est\u00e1 em {}\", pontuacao);\n    }\n}\n\n\nfn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        == println!(\"O n\u00famero \u00e9 maior!\"); ==\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        == println!(\"O n\u00famero \u00e9 menor!\"); ==\n        *pontuacao -= 100;\n    }\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n     \n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui criamos um loop dentro da nossa fun\u00e7\u00e3o game e s\u00f3 deixamos o n\u00famero alvo e a pontua\u00e7\u00e3o fora pois sempre que iniciar um jogo vamos reiniciar o placar. Nossa fun\u00e7\u00e3o check_win_condition nos retorna um <code>ResultGame</code>, por conta disso podemos fazer um match para caso entre na condi\u00e7\u00e3o de vit\u00f3ria ou derrota o jogo \u00e9 encerrado e volta no menu, tamb\u00e9m caso tenhamos algum erro de execu\u00e7\u00e3o ele vai retornar o jogo pro menu. Tamb\u00e9m colocamos uma dica pro jogador saber se o n\u00famero \u00e9 maior ou menor para facilitar que ele.</p> <p>Para ter certeza que n\u00e3o quebramos nada vamos rodar nossos testes.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.16s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Com isso agora j\u00e1 temos um jogo bem jog\u00e1vel.</p>"},{"location":"1_2_jogo_da_adivinhacao/#colocando-aleatoriedade-no-nosso-jogo","title":"Colocando aleatoriedade no nosso jogo","text":"<p>Nosso jogo est\u00e1 bem interessante mas, nesse momento nosso n\u00famero alvo est\u00e1 fixo e queremos que ele seja aleat\u00f3rio para isso vamos precisar de uma biblioteca que n\u00e3o est\u00e1 no padr\u00e3o da linguagem rust que \u00e9 o rand.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introducao-aos-crates","title":"Introdu\u00e7\u00e3o aos crates","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o que ganhou popularidade devido \u00e0 sua seguran\u00e7a, desempenho e concorr\u00eancia. Um dos conceitos fundamentais no ecossistema Rust \u00e9 o de \"crates\". Vamos explorar o que s\u00e3o os crates em Rust e como eles funcionam para facilitar o desenvolvimento de software.</p>"},{"location":"1_2_jogo_da_adivinhacao/#o-que-sao-crates","title":"O Que S\u00e3o Crates?","text":"<p>Em Rust, um \"crate\" \u00e9 a unidade de compila\u00e7\u00e3o de c\u00f3digo. Um crate pode ser uma biblioteca, um aplicativo, um bin\u00e1rio ou at\u00e9 mesmo um subconjunto menor de c\u00f3digo. A ideia por tr\u00e1s dos crates \u00e9 promover a modularidade e a reutiliza\u00e7\u00e3o de c\u00f3digo, permitindo que voc\u00ea organize seu projeto de forma limpa e eficaz.</p>"},{"location":"1_2_jogo_da_adivinhacao/#tipos-de-crates","title":"Tipos de Crates","text":"<p>Existem dois tipos principais de crates em Rust: crates bin\u00e1rios e crates de biblioteca.</p> <ul> <li> <p>Crates Bin\u00e1rios: Esses s\u00e3o os crates que criam um execut\u00e1vel quando compilados. Eles s\u00e3o destinados a iniciar um programa e geralmente cont\u00eam a fun\u00e7\u00e3o main(). Um exemplo de crate bin\u00e1rio \u00e9 um aplicativo de linha de comando ou uma aplica\u00e7\u00e3o de servidor.</p> </li> <li> <p>Crates de Biblioteca: Esses crates n\u00e3o t\u00eam uma fun\u00e7\u00e3o main() e s\u00e3o destinados a serem usados como bibliotecas por outros crates. Os crates de biblioteca podem conter fun\u00e7\u00f5es, estruturas, enums e muito mais que podem ser usados por outros desenvolvedores para criar seus programas.</p> </li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#estrutura-de-diretorios-de-um-crate","title":"Estrutura de Diret\u00f3rios de um Crate","text":"<p>Dentro do diret\u00f3rio do seu crate, voc\u00ea encontrar\u00e1 uma estrutura t\u00edpica de diret\u00f3rios:</p> <ul> <li>src: Cont\u00e9m o c\u00f3digo-fonte do seu crate.</li> <li>Cargo.toml: Arquivo de configura\u00e7\u00e3o do seu crate, onde voc\u00ea especifica depend\u00eancias e outras informa\u00e7\u00f5es.</li> <li>tests: Diret\u00f3rio para escrever testes para o seu crate.</li> <li>examples: Diret\u00f3rio para incluir exemplos de c\u00f3digo para demonstrar o uso do seu crate.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#gerenciando-dependencias","title":"Gerenciando Depend\u00eancias","text":"<p>Rust usa o gerenciador de pacotes Cargo para gerenciar depend\u00eancias. Voc\u00ea pode especificar as depend\u00eancias necess\u00e1rias no arquivo Cargo.toml. Quando voc\u00ea compila seu crate, o Cargo se encarrega de baixar e compilar todas as depend\u00eancias automaticamente.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-crates-de-terceiros","title":"Usando Crates de Terceiros","text":"<p>Um dos principais benef\u00edcios do ecossistema Rust \u00e9 a facilidade de uso de crates de terceiros. Voc\u00ea pode pesquisar e encontrar uma vasta cole\u00e7\u00e3o de crates de alta qualidade no Rust's package registry, crates.io. Para adicionar uma depend\u00eancia a um crate, basta adicionar a linha apropriada no seu arquivo Cargo.toml.</p> <pre><code>\n[dependencies]\nnome_do_pacote = \"versao\"\n</code></pre> <p>Ap\u00f3s adicionar a depend\u00eancia, execute cargo build para baixar e compilar os crates necess\u00e1rios.</p> <p>Tamb\u00e9m podemos instalar diratamente na linha de comando como abaixo:</p> <pre><code>cargo add lib\n</code></pre> <p>Crates s\u00e3o um componente fundamental do ecossistema Rust, permitindo que voc\u00ea desenvolva, compartilhe e reutilize c\u00f3digo de maneira eficaz. A modularidade e a facilidade de gerenciamento de depend\u00eancias tornam Rust uma linguagem poderosa para o desenvolvimento de software. Compreender o sistema de crates \u00e9 essencial para qualquer desenvolvedor Rust, pois \u00e9 uma parte integrante do processo de constru\u00e7\u00e3o de aplica\u00e7\u00f5es robustas e seguras.</p> <p>Agora vamos entrar no site do crates.io vamos buscar a biblioteca rand, aqui no crates.io podemos ver mais sobre a biblioteca, no nosso caso essa biblioteca serve para gerar n\u00fameros aleat\u00f3rio. Vamos instala-la.</p> <pre><code>cargo add rand\n</code></pre> <p>Agora vamos implementa-la no nosso c\u00f3digo.</p> <pre><code>== use rand::{thread_rng, Rng}; ==\nuse std::io;\n\n#[derive(Debug, PartialEq)]\nenum GameResult {\n    Win,\n    Gaming,\n    Lose,\n}\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        io::stdin()\n            .read_line(&amp;mut escolha_str)\n            .expect(\"Erro ao receber sua escolha\");\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n    }\n}\n\nfn game() -&gt; () {\n    let mut pontuacao: u16 = 1000;\n    == let numero_alvo: u8 = thread_rng().gen_range(1..100); ==\n    loop {\n        println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n        let mut chute = String::new();\n        io::stdin()\n            .read_line(&amp;mut chute)\n            .expect(\"Erro ao receber o n\u00famero\");\n\n        let chute: u8 = match chute.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n                0\n            }\n        };\n        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {\n            Ok(result) =&gt; {\n                if result == GameResult::Win {\n                    println!(\"Parab\u00e9ns voc\u00ea venceu! Sua pontua\u00e7\u00e3o foi {}\", pontuacao);\n                    break;\n                } else if result == GameResult::Lose {\n                    println!(\"Que pena voc\u00ea perdeu!\");\n                    break;\n                }\n            }\n            Err(_) =&gt; {\n                println!(\"Ocorreu um erro e o jogo ser\u00e1 reiniciado!\");\n                break;\n            }\n        };\n        println!(\"A sua pontua\u00e7\u00e3o est\u00e1 em {}\", pontuacao);\n    }\n}\n\nfn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        println!(\"O n\u00famero \u00e9 maior!\");\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        println!(\"O n\u00famero \u00e9 menor!\");\n        *pontuacao -= 100;\n    }\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    Ok(GameResult::Gaming)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Win));\n    assert_eq!(pontuacao, 1000)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n</code></pre> <p>No caso do rand gerar o n\u00famero que queremos precisamos usar a fun\u00e7\u00e3o gen_range olhando na documenta\u00e7\u00e3o precisamos importar <code>use rand::{thread_rng, Rng};</code> que s\u00e3o as fun\u00e7\u00f5es de base e simplemente removemos o n\u00famero fixo por essa fun\u00e7\u00e3o na declara\u00e7\u00e3o da vari\u00e1vel.</p> <pre><code>    let numero_alvo: u8 = thread_rng().gen_range(1..100);\n</code></pre> <p>Ai colocamos que queremos gerar um valor entre 1 e 100 e agora vamos rodar os testes para ver se nossa altera\u00e7\u00e3o quebrou alguma coisa.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-1e17f810f8775677)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo tudo funcionando.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-o-cargo-fmt","title":"Usando o cargo fmt","text":"<p>Nesse m\u00f3dulo eu usei o editor helix e nele eu configurei para ajustar a formata\u00e7\u00e3o do meu c\u00f3digo automaticamente, mas, h\u00e1 um comando no <code>cargo</code> que \u00e9 poss\u00edvel fazer a formata\u00e7\u00e3o do seu c\u00f3digo que \u00e9 o fmt podemos roda-lo com o comando abaixo:</p> <pre><code>cargo fmt\n</code></pre> <p>Com isso pode ajustar nosso c\u00f3digo pra j\u00e1 trabalhar com o <code>clippy</code>.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-clippy","title":"Usando Clippy","text":"<p>Clippy \u00e9 uma ferramenta de an\u00e1lise est\u00e1tica para o Rust, desenvolvida pela comunidade. Ele fornece sugest\u00f5es e avisos sobre poss\u00edveis problemas de c\u00f3digo, seguindo as melhores pr\u00e1ticas e conven\u00e7\u00f5es da linguagem Rust.</p> <p>Para rodar o cargo clippy \u00e9 s\u00f3 executar o comando abaixo:</p> <pre><code>cargo clippy\n</code></pre> <p>Vamos ter uma sa\u00edda parecida com essa:</p> <pre><code>guessing_game on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.76.0 on \u2601\ufe0f   (eu-west-2)\n\u279c cargo clippy\n    Checking guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unneeded unit return type\n  --&gt; src/main.rs:39:10\n   |\n39 | fn game() -&gt; () {\n   |          ^^^^^^ help: remove the `-&gt; ()`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n   = note: `#[warn(clippy::unused_unit)]` on by default\n\nerror: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n  --&gt; src/main.rs:91:8\n   |\n91 |     if *pontuacao &lt;= 0 {\n   |        ^^^^^^^^^^^^^^^\n   |\n   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to 1 previous error; 1 warning emitted\n</code></pre> <p>Primeiro ponto vamos ver esse warning:</p> <pre><code>warning: unneeded unit return type\n  --&gt; src/main.rs:39:10\n   |\n39 | fn game() -&gt; () {\n   |          ^^^^^^ help: remove the `-&gt; ()`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n   = note: `#[warn(clippy::unused_unit)]` on by default\n</code></pre> <p>Aqui colocamos nossa sa\u00edda como uma option vazia <code>-&gt; ()</code> ent\u00e3o podemos remover conforme ele est\u00e1 indicando, \u00e9 importnte ver que tamb\u00e9m ele coloca uma documenta\u00e7\u00e3o do clippy informando por que \u00e9 uma m\u00e1 pr\u00e1tica. Caso voc\u00ea queira ignorar o erro voc\u00ea pode colocar a anota\u00e7\u00e3o que ele recomenda que no caso \u00e9 <code>#[warn(clippy::unused_unit)]</code>.</p> <p>Agora vamos ver o outro warning:</p> <pre><code>error: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n  --&gt; src/main.rs:91:8\n   |\n91 |     if *pontuacao &lt;= 0 {\n   |        ^^^^^^^^^^^^^^^\n   |\n   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default\n</code></pre> <p>Esse warning fala que estamos querendo ver um valor menor que zero, por\u00e9m estamos usando na pontua\u00e7\u00e3o um tipo <code>u</code> que n\u00e3o aceita sinal, temos duas formas de resolver isso, mudar nosso prametro pra o tipo <code>i</code> que aceita sinal ou ainda como nossa pontua\u00e7\u00e3o n\u00e3o deveria nunca ser menor que zero, podemos apenas seguir a instru\u00e7\u00e3o do clippy e deixar o sinal de igualdade <code>==</code>.</p> <p>Rodando agora o clippy novamente temos a sa\u00edda abaixo:</p> <pre><code>\u2726 \u279c cargo clippy\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n</code></pre> <p>Quer dizer que nosso c\u00f3digo est\u00e1 sem erros no momento.</p>"},{"location":"1_2_jogo_da_adivinhacao/#update-rust","title":"Update Rust","text":"<p>O rust vem sendo atualizado com o tempo, no caso do curso come\u00e7amos com a vers\u00e3o 1.73 ent\u00e3o vamos atualizar o nosso c\u00f3digo agora simplemente precisamos rodar o comando abaixo:</p> <pre><code>rustup update\n</code></pre> <p>Com isso agora vamos pra ultima vers\u00e3o do rust dispon\u00edvel.</p>"},{"location":"1_2_jogo_da_adivinhacao/#conclusao","title":"Conclus\u00e3o","text":"<p>Com esse jogo vimos como criar uma fun\u00e7\u00e3o em rust, criar testes para essa fun\u00e7\u00e3o usando a suite nativa de testes do rust, mais algumas fun\u00e7\u00f5es de manipula\u00e7\u00e3o de strings, como funciona o conceito de borrow and ownership, como funciona o gerenciamento de mem\u00f3ria do rust.</p>"},{"location":"1_2_jogo_da_adivinhacao/#exercicios-sugeridos","title":"Exercic\u00edos sugeridos","text":"<p>Exerc\u00edcio 1: Jogo de Perguntas e Respostas</p> <p>Crie um jogo de perguntas e respostas em que o jogador deve responder a v\u00e1rias perguntas. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>O programa deve conter um conjunto de perguntas e respostas.\nO jogador deve receber uma pergunta e fornecer uma resposta.\nO programa deve verificar se a resposta est\u00e1 correta e atualizar a pontua\u00e7\u00e3o do jogador.\nUse fun\u00e7\u00f5es para organizar o c\u00f3digo, armazenar perguntas e respostas, e verificar as respostas do jogador.\nEscreva testes para garantir que o jogo funcione corretamente.\n</code></pre> <p>Exerc\u00edcio 2: Jogo de Aventura com Hist\u00f3ria Interativa</p> <p>Crie um jogo de aventura com uma hist\u00f3ria interativa em que o jogador toma decis\u00f5es que afetam o desenrolar da hist\u00f3ria. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>Use enumera\u00e7\u00f5es para representar as diferentes escolhas e eventos na hist\u00f3ria.\nUse vari\u00e1veis mut\u00e1veis para rastrear o progresso da hist\u00f3ria e as decis\u00f5es do jogador.\nUse loops para permitir que o jogador fa\u00e7a escolhas ao longo da hist\u00f3ria.\nUse if, if else e match para verificar as escolhas do jogador e os resultados na hist\u00f3ria.\nUse a macro println! para exibir a narrativa da aventura.\n</code></pre> <p>Exerc\u00edcio 3: Jogo da Forca</p> <p>Crie um jogo multiplayer alternativo da forca em que o jogador deve adivinhar uma palavra oculta. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>O programa deve receber uma palavra aleat\u00f3ria de um jogador e uma dica.\nO outro jogador deve fazer tentativas para adivinhar a palavra escrevendo ela inteira.\nO programa deve mostrar uma representa\u00e7\u00e3o de quantas tentativas faltam.\nO jogo deve ser encerrado quando o jogador adivinhar a palavra corretamente ou ap\u00f3s um n\u00famero m\u00e1ximo de tentativas.\nUse fun\u00e7\u00f5es para organizar o c\u00f3digo.\nEscreva testes para garantir que o jogo funcione corretamente.\n</code></pre> <p>Exerc\u00edcio 4: Simulador de Compras com Crate Rust Money</p> <p>Crie um simulador de compras em que o jogador tem um or\u00e7amento limitado e deve fazer compras. Use o crate rust-money para representar valores monet\u00e1rios. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>Instale o crate rust-money para lidar com valores monet\u00e1rios.\nUse vari\u00e1veis mut\u00e1veis para rastrear o or\u00e7amento do jogador e o custo dos itens.\nUse loops para permitir que o jogador fa\u00e7a v\u00e1rias compras.\nUse if e match para verificar se o jogador pode pagar por um item e atualizar o or\u00e7amento.\nUse a macro println! para exibir informa\u00e7\u00f5es sobre as compras.\n</code></pre>"},{"location":"1_3_jogo_blackjack/","title":"Jogo Blackjack","text":"<p>Bom hoje vamos come\u00e7ar analisando sobre o jogo do blackjack.</p> <p>O Blackjack, tamb\u00e9m conhecido como 21, \u00e9 um jogo de cartas popular jogado em cassinos. Aqui est\u00e3o as regras b\u00e1sicas:</p> <ul> <li>Objetivo do Jogo:</li> <li> <p>O objetivo \u00e9 obter uma m\u00e3o com um valor total mais pr\u00f3ximo poss\u00edvel de 21, sem ultrapassar esse valor.</p> </li> <li> <p>Cartas e Valores:</p> </li> <li>As cartas de 2 a 10 valem seu valor nominal.</li> <li>Valetes(J), Damas(Q) e Reis(K) valem cada um 10 pontos.</li> <li> <p>As cartas de \u00c1s(A) podem valer 1 ou 11, dependendo da situa\u00e7\u00e3o.</p> </li> <li> <p>In\u00edcio do Jogo:</p> </li> <li>O jogador e o dealer recebem duas cartas no in\u00edcio.</li> <li> <p>O jogador v\u00ea uma das cartas do dealer.</p> </li> <li> <p>Jogada do Jogador:</p> </li> <li>O jogador decide entre \"pedir\" (receber uma carta) ou \"ficar\" (manter a m\u00e3o atual).</li> <li> <p>Se o valor da m\u00e3o do jogador ultrapassar 21, ele perde automaticamente.</p> </li> <li> <p>Jogada do Dealer:</p> </li> <li>Ap\u00f3s a vez do jogador, o dealer revela sua segunda carta.</li> <li> <p>O dealer deve continuar a pedir cartas at\u00e9 que a m\u00e3o alcance pelo menos 17 pontos.</p> </li> <li> <p>Determina\u00e7\u00e3o do Vencedor:</p> </li> <li>Se a m\u00e3o do jogador ultrapassar 21, ele perde automaticamente.</li> <li>Se o dealer ultrapassar 21, o jogador vence.</li> <li> <p>Se nenhum dos jogadores ultrapassar 21, o vencedor \u00e9 aquele com a m\u00e3o mais pr\u00f3xima de 21.</p> </li> <li> <p>Blackjack:</p> </li> <li> <p>Se um jogador receber um \u00c1s e uma carta de 10 pontos no in\u00edcio (um Blackjack), ele geralmente vence automaticamente, a menos que o dealer tamb\u00e9m tenha um Blackjack.</p> </li> <li> <p>Empate:</p> </li> <li>Se o jogador e o dealer tiverem o mesmo valor de m\u00e3o, o jogo \u00e9 um empate (\"push\").</li> </ul> <p>Em um empate (ou \"push\") no Blackjack, significa que a pontua\u00e7\u00e3o total da m\u00e3o do jogador \u00e9 a mesma que a pontua\u00e7\u00e3o total da m\u00e3o do dealer. Nesse cen\u00e1rio:</p> <ul> <li>Nenhum Vencedor ou Perdedor:</li> <li>Como as pontua\u00e7\u00f5es s\u00e3o iguais, nenhum jogador ganha ou perde.</li> <li> <p>O dinheiro apostado geralmente \u00e9 devolvido aos jogadores.</p> </li> <li> <p>M\u00e3o Empurrada (Push):</p> </li> <li>\u00c0s vezes, \u00e9 chamado de \"push\" quando n\u00e3o h\u00e1 vencedor ou perdedor.</li> <li> <p>Isso n\u00e3o afeta a pontua\u00e7\u00e3o ou saldo dos jogadores.</p> </li> <li> <p>Nova Rodada:</p> </li> <li>Ap\u00f3s um empate, o jogo geralmente avan\u00e7a para uma nova rodada.</li> <li>Os jogadores podem fazer novas apostas e iniciar uma nova m\u00e3o.</li> </ul> <p>O empate \u00e9 uma ocorr\u00eancia comum no Blackjack e faz parte do jogo. \u00c9 importante observar que, em alguns casos, as regras do cassino podem variar, e algumas varia\u00e7\u00f5es do jogo podem ter regras espec\u00edficas para empates. Ao jogar em um cassino ou seguir regras espec\u00edficas, \u00e9 sempre bom estar ciente das pol\u00edticas e procedimentos locais.</p> <p>Essas s\u00e3o as regras b\u00e1sicas do Blackjack. Estrat\u00e9gias avan\u00e7adas podem ser aplicadas, considerando as cartas j\u00e1 distribu\u00eddas, mas essas s\u00e3o as regras fundamentais para come\u00e7ar a jogar.</p>"},{"location":"1_3_jogo_blackjack/#raio-x-jogo-blackjack","title":"Raio X - Jogo Blackjack","text":"<p>Guia de Design de Jogo (GDD) - Blackjack</p> <ol> <li>Vis\u00e3o Geral do Jogo:</li> </ol> <p>O jogo de Blackjack \u00e9 uma vers\u00e3o digital do popular jogo de cartas de cassino, tamb\u00e9m conhecido como 21. Os jogadores competem contra o dealer (a casa) para alcan\u00e7ar uma m\u00e3o de cartas com um valor total pr\u00f3ximo de 21, sem ultrapass\u00e1-lo. O objetivo \u00e9 vencer o dealer sem estourar, o que resultaria em uma perda imediata.</p> <ol> <li> <p>Mec\u00e2nicas de Jogo:</p> <p>Distribui\u00e7\u00e3o de Cartas: Os jogadores recebem duas cartas viradas para cima, enquanto o dealer recebe uma carta virada para cima e uma carta virada para baixo.</p> <p>Tomada de Decis\u00e3o: Os jogadores t\u00eam a op\u00e7\u00e3o de \"bater\" (receber outra carta), \"ficar\" (manter sua m\u00e3o atual), \"dobrar\" (dobrar sua aposta e receber exatamente uma carta adicional) ou \"dividir\" (dividir sua m\u00e3o em duas m\u00e3os separadas, se as duas primeiras cartas tiverem o mesmo valor).</p> <p>Regras de Vit\u00f3ria e Derrota: O jogador ganha se sua m\u00e3o totalizar mais perto de 21 do que a do dealer sem ultrapassar. Se o jogador ultrapassar 21, ele perde automaticamente. Se a m\u00e3o do dealer ultrapassar 21 e a do jogador n\u00e3o, o jogador vence.</p> </li> <li> <p>Elementos do Jogo:</p> <p>Baralho de Cartas: Um baralho padr\u00e3o de 52 cartas \u00e9 usado, sem coringas.</p> <p>Aposta: Os jogadores podem apostar uma quantidade de fichas antes do in\u00edcio de cada rodada.</p> <p>Interface do Usu\u00e1rio: Uma interface de usu\u00e1rio intuitiva permitir\u00e1 que os jogadores interajam com o jogo, fazendo escolhas de jogo e visualizando suas m\u00e3os e a m\u00e3o do dealer.</p> </li> <li> <p>Arte e Design Visual:</p> <p>Design da Tela: O layout da tela ser\u00e1 simples e feito via terminal mostrando a informa\u00e7\u00e3o das cartas usando seus respectivos caracteres.</p> <p>Estilo Visual: Estilo de jogos feitos unicamente para terminal sem nenhum arte especifica.</p> </li> <li> <p>Considera\u00e7\u00f5es T\u00e9cnicas:</p> <p>Plataforma: O jogo ser\u00e1 desenvolvido para funcionar em desktops, dispositivos m\u00f3veis e navegadores da web.</p> <p>Tecnologia: Ser\u00e1 utilizado o framework de desenvolvimento de jogos Bevy, que oferece suporte robusto para gr\u00e1ficos 2D e \u00e1udio.</p> </li> </ol>"},{"location":"1_3_jogo_blackjack/#iniciando-o-jogo","title":"Iniciando o jogo","text":"<p>Bom vamos criar o nosso jogo.</p> <pre><code>cargo new blackjack\n</code></pre> <p>Agora vamos criar na nossa main o menu principal do jogo.</p>"},{"location":"INDICE/","title":"Summary","text":""},{"location":"INDICE/#ementa-desenvolvimento-de-jogos-em-ascii-com-rust","title":"Ementa: Desenvolvimento de Jogos em ASCII com Rust","text":""},{"location":"INDICE/#topico-1-conceitos-basicos-de-rust","title":"T\u00f3pico 1: Conceitos B\u00e1sicos de Rust","text":"<ul> <li>Introdu\u00e7\u00e3o</li> <li>Jogo a Floresta Misteriosa</li> <li>Tipos de Dados e Fun\u00e7\u00f5es</li> <li>Controle de Fluxo e Propriedade (Ownership)</li> </ul>"},{"location":"INDICE/#topico-2-introducao-a-arte-ascii","title":"T\u00f3pico 2: Introdu\u00e7\u00e3o \u00e0 Arte ASCII","text":"<ul> <li>[Manipula\u00e7\u00e3o de Strings e Caracteres ASCII]</li> <li>[Sa\u00edda para o Terminal e Interface do Usu\u00e1rio]</li> </ul>"},{"location":"INDICE/#topico-3-implementando-a-logica-de-jogos","title":"T\u00f3pico 3: Implementando a L\u00f3gica de Jogos","text":"<ul> <li>[Vetores e Matrizes]</li> <li>[Algoritmos de Busca e Ordena\u00e7\u00e3o]</li> </ul>"},{"location":"INDICE/#topico-4-gerenciamento-de-tela-e-interface-do-usuario","title":"T\u00f3pico 4: Gerenciamento de Tela e Interface do Usu\u00e1rio","text":"<ul> <li>[Manipula\u00e7\u00e3o de Tela e Terminal (ANSI escape codes)]</li> <li>[Entrada do Usu\u00e1rio (stdin) e Gerenciamento de Eventos]</li> </ul>"},{"location":"INDICE/#topico-5-mecanica-de-jogo","title":"T\u00f3pico 5: Mec\u00e2nica de Jogo","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto State]</li> </ul>"},{"location":"INDICE/#topico-6-tratamento-de-eventos","title":"T\u00f3pico 6: Tratamento de Eventos","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto Observer]</li> </ul>"},{"location":"INDICE/#topico-7-controle-de-estado-e-salvamento-do-jogo","title":"T\u00f3pico 7: Controle de Estado e Salvamento do Jogo","text":"<ul> <li>[Serializa\u00e7\u00e3o e Desserializa\u00e7\u00e3o de Dados]</li> </ul>"},{"location":"INDICE/#topico-8-desafios-e-recursos-avancados","title":"T\u00f3pico 8: Desafios e Recursos Avan\u00e7ados","text":"<ul> <li>[Threads e Concorr\u00eancia]</li> <li>[Gerenciamento de Mem\u00f3ria Avan\u00e7ado (Rc, Arc, Mutex)]</li> </ul>"},{"location":"INDICE/#topico-9-desenvolvimento-de-jogos-completos-em-ascii","title":"T\u00f3pico 9: Desenvolvimento de Jogos Completos em ASCII","text":"<ul> <li>[Estrutura de Projeto e Organiza\u00e7\u00e3o de Arquivos]</li> <li>[Tratamento de Erros (Result, Option)]</li> <li>[Documenta\u00e7\u00e3o do C\u00f3digo]</li> </ul>"},{"location":"INDICE/#topico-10-projeto-final-jogo-completo-em-ascii","title":"T\u00f3pico 10: Projeto Final: Jogo Completo em ASCII","text":"<ul> <li>[Aplica\u00e7\u00e3o de todos os conceitos aprendidos para criar um jogo completo e original em ASCII.]</li> </ul>"},{"location":"Jogos/","title":"Jogos","text":"<p>Ementa</p> <p>1 - Introdu\u00e7\u00e3o ao Rust 2 - Jogo 'A floresta misteriosa' 3 - Jogo da adivinha\u00e7\u00e3o 4 - Blackjack WIP 5 - Jogo de palavras cruzadas 6 - Jogo do Pong 7 - Jodo do Labirinto 5 - RPG de texto 7 - Jogo top down com eventos aleat\u00f3rios 8 - Criando sistema de salvamento pro nosso RPG 9 - Batalha naval Multiplayer 9 - Jogo de Xadrez multiplayer 10 - Criando nosso jogo Adventure 11 - Fazendo nosso RPG ser jogado Online 12 - Projeto Final: Jogo Rogue</p>"}]}