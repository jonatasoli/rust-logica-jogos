{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao curso Rust l\u00f3gica com jogos","text":"<p>Esse material est\u00e1 em desenvolvimento ent\u00e3o sugest\u00f5es s\u00e3o sempre bem-vindas.</p>"},{"location":"#o-que-e-rust","title":"O que \u00e9 Rust","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi projetado para oferecer uma experi\u00eancia pr\u00e1tica no ensiono da linguagem Rust, usando desenvolvimento de jogos em ASCII e textual. Durante o curso, o objetivo principal \u00e9 proporcionar aos participantes um entendimento abrangente dos conceitos fundamentais da linguagem Rust, juntamente com a aplica\u00e7\u00e3o pr\u00e1tica desses conhecimentos na cria\u00e7\u00e3o de jogos mesmo n\u00e3o sendo o foco do curso ensinar a fazer jogos profissionalmente.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Durante esse curso voc\u00ea vai aprender o b\u00e1sico de Rust como fluxos condicionais, repeti\u00e7\u00e3o, uso de fun\u00e7\u00f5es, escopo de v\u00e1riaveis at\u00e9 t\u00f3picos avan\u00e7ados como Threads e concorr\u00eancia.</p>"},{"location":"#esse-curso-e-gratuito","title":"Esse curso \u00e9 gratuito?","text":"<p>Essa wiki \u00e9 gratuita assim como os exerc\u00edcios, por\u00e9m ser\u00e1 craido um curso em v\u00eddeo e esse ser\u00e1 pago. E caso o estudando desejar poder\u00e1 me ajudar tamb\u00e9m atrav\u00e9s do github sponsor o valor arrecadado vai me ajudar a me manter durante a produ\u00e7\u00e3o do curso.</p>"},{"location":"#onde-ele-sera-disponibilizado","title":"Onde ele ser\u00e1 disponibilizado?","text":"<p>O curso vai ser disponibilizado atrav\u00e9s da plataforma Udemy.</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9 requisitos","text":"<p>Para fazer esse curso \u00e9 importante ter no\u00e7\u00f5es b\u00e1sicas de inform\u00e1tica como: - Saber usar um navegador - Saber entrar num prompt de comando seja no Windows, Mac ou Linux - J\u00e1 ter conhecimento em outra linguagem \u00e9 desej\u00e1vel mas, n\u00e3o \u00e9 essencial pois vamos trabalhar do zero e contruir projetos</p> <p>Obs: O curso ser\u00e1 desenvolvido totalmente em linux, caso queira usar Windows \u00e9 interessante usar WSL2 devo colocar no curso posteriormente um tutorial para configurar o ubuntu com wsl2 mas, por hora recomendo verem o v\u00eddeo do F\u00e1bio Akita criando um ambiente.</p>"},{"location":"#ementa","title":"Ementa","text":""},{"location":"#apos-esse-curso-vou-estar-capacitado-a-fazer-jogos-profissionalmente","title":"Ap\u00f3s esse curso vou estar capacitado a fazer jogos profissionalmente?","text":"<p>N\u00e3o, mesmo que seja abordados alguns principios do desenvolvimento de jogos, esse curso n\u00e3o tem como objetivo ajudar o aluno a fazer jogos profissionais, nesse caso o instrutor ainda recomenda buscar outros materiais para se aprofundar no tema.</p>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"Quem vai ministrar essas aulas?","text":"<p>Sou um profissional com 17 anos de experi\u00eancia no desenvolvimento de sistemas e websites, meu foco principal est\u00e1 sistemas web. Comecei a aprender Rust em 2020 e estou trabalhando no meu primeiro jogo profissionalmente.</p>"},{"location":"#o-que-voce-precisa-para-acompanhar-o-curso","title":"O que voc\u00ea precisa para acompanhar o curso?","text":"<ul> <li>Editor de texto ou IDE: Recomendo qualquer editor que tenha a capacidade de identicar c\u00f3digo Rust, durante os v\u00eddeos vou usar o nvim mas, voc\u00ea pode usar   qual quiser, se voc\u00ea for iniciante recomendo usar o vscodium.</li> </ul>"},{"location":"#repositorio","title":"Reposit\u00f3rio","text":"<p>Todas os exemplos criados para o curso assim como exercic\u00edos estar\u00e3o no reposit\u00f3rio abaixo.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/","title":"Jogo da adivinha\u00e7\u00e3o Raio-x","text":"<p>Vamos come\u00e7ar um novo jogo que \u00e9 o jogo da adivinha\u00e7\u00e3o \"Guessing Game\" o objetivo desse jogo \u00e9 identificar um n\u00famero escolhido aleat\u00f3riamente. O jogo inicia com 1000 pontos para o jogador e cada vez que ele erra o n\u00famero \u00e9 subtraido 100 pontos do placar dele quando o placar chegar a zero o jogo \u00e9 encerrado.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#regras","title":"Regras","text":"<p>As regras s\u00e3o as seguintes: - Ao iniciar o jogo o jogador tem a escolha de come\u00e7ar o jogo ou sair do jogo - O jogador vai escolher um n\u00famero entre 0 a 100 - Caso o jogador escolha um n\u00famero fora desse intervalo ser\u00e1 solicitado para ele escolher novamente - Caso o jogador escolha uma letra ou um caractere especial tamb\u00e9m ser\u00e1 solicitado para escolher o novamente - Caso o jogador escolha um n\u00famero menor que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi menor - Caso o jogador escolha um n\u00famero maior que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi maior - Casa escolha que n\u00e3o seja o n\u00famero escolhido pelo jogo dever\u00e1 marcar um contador de erro - O jogador come\u00e7a com 1000 pontos caso aconte\u00e7a um erro cada contador de erro deve subtrair 100 pontos - Caso o jogador perca o jogo dever\u00e1 ter um menu informando pra fechar o jogo ou jogar novamente - Caso o jogador ven\u00e7a dever\u00e1 mostrar o placar que ele obteve o a op\u00e7\u00e3o de sair do jogo ou tentar novamente.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#comecando-o-projeto","title":"Come\u00e7ando o projeto","text":"<p>Vamos iniciar um novo projeto em nossa pasta projects</p> <pre><code>cd ~/projects\ncargo new guessing_game\n</code></pre> <p>Agora para iniciar o nosso jogo vamos fazer o loop que j\u00e1 conhecemos e vamos criar o menu recebendo o input do usu\u00e1rio e imprimir na tela o valor escolhido e caso ele escolha iniciar vamos imprimir que o jogo come\u00e7ou e caso ele sair n\u00f3s vamos encerrar o jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        println!(\"A sua escolha foi {}\", escolha_str);\n        break;\n    }\n\n}\n</code></pre> <p>Aqui vamos mudar ao inv\u00e9s de usar n\u00fameros para op\u00e7\u00f5es vamos usar letras pois vamos precisar fazer um tratamento especial no c\u00f3digo, estamos usando a captura que estavamos fazendo anteriormente fazendo um println apenas no item escolhido, no final vamos dar um break apenas pra encerrar o loop. Agora se rodarmos o c\u00f3digo vamos ver que ele pegou a escolha que gostariamos e printou na tela.</p> <pre><code>cargo run\n</code></pre> <p>Certo agora vamos fazer um match com nossa escolha str s\u00f3 que como estamos usando letras vou for\u00e7ar que o que venha de letras senha minuscula ou maiuscula que ele force sempre a ser min\u00fasculo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n        };\n==\n\n    }\n}\n</code></pre> <p>Criamos a nossa linha como <code>match escolha.str.trim().to_lowercase()</code> usando a fun\u00e7\u00e3o <code>trim()</code> para removermos espa\u00e7os em branco e agora usamos uma nova fun\u00e7\u00e3o chamada <code>to_lowercase()</code> que vai transformar nossa string caso tenha letras maiusculas em min\u00fasculas. Outra fun\u00e7\u00e3o que usamomos foi o <code>as_str</code> pois quando usamos o <code>trim</code> e o <code>to_lowercase</code> eles voltam um &amp;str que \u00e9 um tipo diferente do String ent\u00e3o pra comparar vamos precisar reconverter novamente para String e ai usamos o <code>as_str</code>.</p> <p>Assim conseguimos agora colocar a compara\u00e7\u00e3o com a string \"i\" e a string \"q\".</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                println!(\"Iniciar Jogo\");\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n==\n\n    }\n}\n</code></pre> <p>Aqui colocamos o \"i\" para imprimir e usamos o <code>continue</code> para voltar ao inicio do loop. No caso o jogador use \"q\" o programa vai ser encerrado. Tamb\u00e9m usamos o coringa \"_\" caso seja dada outra op\u00e7\u00e3o que n\u00e3o seja \"i\" ou \"q\" n\u00f3s colocamos a mensagem de erro e reiniciamos o loop.</p> <p>Agora podemos testar e verificar se nossa fun\u00e7\u00e3o est\u00e1 correta.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#diferenca-entre-str-e-string","title":"Diferen\u00e7a entre &amp;str e String","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o moderna que coloca um forte foco na seguran\u00e7a e no gerenciamento de mem\u00f3ria, permitindo aos desenvolvedores escrever c\u00f3digo seguro e eficiente. Duas estruturas de dados muito importantes em Rust s\u00e3o &amp;str e String. Embora ambas sejam usadas para representar texto, elas t\u00eam diferen\u00e7as fundamentais em termos de propriedades e uso. Vamos explorar as distin\u00e7\u00f5es entre &amp;str e String em Rust.</p> <p>&amp;str - Refer\u00eancia para uma Sequ\u00eancia de Caracteres</p> <p>&amp;str \u00e9 uma fatia (slice) que representa uma sequ\u00eancia de caracteres em Rust. Essa fatia \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres armazenada em outro local da mem\u00f3ria. Aqui est\u00e3o algumas caracter\u00edsticas importantes do &amp;str:</p> <pre><code>Imut\u00e1vel: O &amp;str \u00e9 imut\u00e1vel, o que significa que voc\u00ea n\u00e3o pode modificar o conte\u00fado da sequ\u00eancia de caracteres a que ele faz refer\u00eancia.\n\nAloca\u00e7\u00e3o Zero: O &amp;str em si n\u00e3o aloca mem\u00f3ria para a sequ\u00eancia de caracteres. Ele simplesmente aponta para uma sequ\u00eancia existente.\n\nView (Vis\u00e3o): O &amp;str \u00e9 uma vis\u00e3o de uma sequ\u00eancia de caracteres. Pode ser usado para referenciar substrings de uma String ou literais de string.\n\nLifetime: O &amp;str tem um tempo de vida (lifetime) que est\u00e1 vinculado ao contexto em que \u00e9 criado. Isso garante que a refer\u00eancia seja v\u00e1lida durante o tempo necess\u00e1rio.\n</code></pre> <p>Aqui est\u00e1 um exemplo de &amp;str:</p> <pre><code>fn main() {\n    let texto: &amp;str = \"Ol\u00e1, Mundo!\";\n    println!(\"{}\", texto);\n}\n\n</code></pre> <p>String - Propriedade de uma Sequ\u00eancia de Caracteres</p> <p>String \u00e9 uma estrutura de dados que representa uma sequ\u00eancia de caracteres alocada dinamicamente em Rust. Aqui est\u00e3o algumas caracter\u00edsticas importantes da String:</p> <pre><code>Mut\u00e1vel: A String \u00e9 mut\u00e1vel, o que significa que voc\u00ea pode modificar seu conte\u00fado, adicionando ou removendo caracteres.\n\nAloca\u00e7\u00e3o Din\u00e2mica: A String aloca mem\u00f3ria dinamicamente para armazenar a sequ\u00eancia de caracteres. Isso permite que voc\u00ea ajuste o tamanho conforme necess\u00e1rio.\n\nPropriet\u00e1ria: A String \u00e9 propriet\u00e1ria, o que significa que \u00e9 respons\u00e1vel por gerenciar a mem\u00f3ria da sequ\u00eancia de caracteres que ela cont\u00e9m.\n\nConvers\u00e3o: Voc\u00ea pode converter um &amp;str em uma String usando a fun\u00e7\u00e3o to_string(), ou usar a fun\u00e7\u00e3o String::from().\n</code></pre> <p>Aqui est\u00e1 um exemplo de String:</p> <pre><code>fn main() {\n    let mut texto: String = String::from(\"Ol\u00e1, \");\n    texto.push_str(\"Mundo!\");\n    println!(\"{}\", texto);\n}\n</code></pre> <p>Quando Usar &amp;str e String</p> <p>A escolha entre &amp;str e String depende do contexto e dos requisitos do seu programa:</p> <pre><code>Use &amp;str quando precisar de uma refer\u00eancia imut\u00e1vel a uma sequ\u00eancia de caracteres existente. Por exemplo, ao passar argumentos de fun\u00e7\u00e3o ou realizar opera\u00e7\u00f5es de leitura em uma sequ\u00eancia.\n\nUse String quando precisar de uma sequ\u00eancia de caracteres mut\u00e1vel que pode ser modificada. Por exemplo, para construir uma sequ\u00eancia de caracteres dinamicamente.\n\nLembre-se de que &amp;str e String s\u00e3o intercambi\u00e1veis por meio de convers\u00f5es quando necess\u00e1rio.\n</code></pre>"},{"location":"1_2_tipos_de_dados_e_funcoes/#alocacao-de-memoria-em-rust","title":"Aloca\u00e7\u00e3o de mem\u00f3ria em Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o conhecida por seu controle rigoroso sobre a mem\u00f3ria. Ela oferece diversos tipos de mem\u00f3ria com comportamentos distintos, o que \u00e9 fundamental para garantir a seguran\u00e7a e o desempenho dos programas. Vamos explorar os principais tipos de mem\u00f3ria em Rust e como eles se comportam.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#1-stack-pilha","title":"1. Stack (Pilha)","text":"<p>A pilha, ou stack, \u00e9 um local de armazenamento de mem\u00f3ria de curto prazo e \u00e9 usada para alocar vari\u00e1veis locais e controlar a execu\u00e7\u00e3o do programa. Aqui est\u00e3o algumas caracter\u00edsticas da pilha:</p> <ul> <li>Alcance Limitado: As vari\u00e1veis alocadas na pilha t\u00eam um tempo de vida limitado e s\u00e3o desalocadas automaticamente quando saem do escopo.</li> <li>Aloca\u00e7\u00e3o R\u00e1pida: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria na pilha \u00e9 r\u00e1pida, pois segue uma ordem rigorosa de LIFO (\u00faltimo a entrar, primeiro a sair).</li> <li>Tamanho Conhecido em Tempo de Compila\u00e7\u00e3o: O tamanho das vari\u00e1veis alocadas na pilha deve ser conhecido em tempo de compila\u00e7\u00e3o.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o na pilha:</p> <pre><code>fn main() {\n    let x = 42; // Vari\u00e1vel \"x\" alocada na pilha\n}\n</code></pre>"},{"location":"1_2_tipos_de_dados_e_funcoes/#2-heap","title":"2. Heap","text":"<p>O heap \u00e9 um local de armazenamento de mem\u00f3ria de longo prazo, usado para alocar dados cujo tamanho n\u00e3o \u00e9 conhecido em tempo de compila\u00e7\u00e3o e/ou que precisam de tempo de vida mais longo. Aqui est\u00e3o algumas caracter\u00edsticas do heap:</p> <ul> <li>Alcance Mais Amplo: Os dados alocados no heap podem ter um tempo de vida mais longo e persistir al\u00e9m do escopo atual.</li> <li>Aloca\u00e7\u00e3o e Libera\u00e7\u00e3o Controladas: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria no heap s\u00e3o controladas manualmente pelo programador, usando fun\u00e7\u00f5es como Box::new, Vec::new, etc.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o no heap:</p> <pre><code>fn main() {\n    let x = Box::new(42); // Vari\u00e1vel \"x\" alocada no heap\n}\n</code></pre>"},{"location":"1_2_tipos_de_dados_e_funcoes/#3-memoria-estatica","title":"3. Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 usada para armazenar dados que t\u00eam um tempo de vida durante toda a execu\u00e7\u00e3o do programa. Ela \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada durante a execu\u00e7\u00e3o.</p> <ul> <li>Tempo de Vida Global: Os dados est\u00e1ticos t\u00eam um tempo de vida global e existem durante toda a execu\u00e7\u00e3o do programa.</li> <li>Aloca\u00e7\u00e3o em Tempo de Compila\u00e7\u00e3o: A mem\u00f3ria est\u00e1tica \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada ou realocada.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o de mem\u00f3ria est\u00e1tica:</p> <pre><code>static HELLO: &amp;str = \"Hello, World!\";\n</code></pre>"},{"location":"1_2_tipos_de_dados_e_funcoes/#4-string-vs-str","title":"4. String vs &amp;str","text":"<p>Rust distingue entre String e &amp;str. String \u00e9 uma sequ\u00eancia de caracteres alocada no heap, que permite modifica\u00e7\u00f5es. &amp;str \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres (geralmente String ou literal de string) e \u00e9 imut\u00e1vel.</p> <ul> <li>Use String quando precisar de uma sequ\u00eancia de caracteres que pode ser modificada.</li> <li>Use &amp;str para referenciar sequ\u00eancias de caracteres imut\u00e1veis.</li> </ul> <pre><code>fn main() {\n    let s1: String = String::from(\"Hello\");\n    let s2: &amp;str = \"World\";\n}\n</code></pre>"},{"location":"1_2_tipos_de_dados_e_funcoes/#criando-a-funcao-do-jogo","title":"Criando a fun\u00e7\u00e3o do jogo","text":"<p>Agora vamos criar uma fun\u00e7\u00e3o onde vamos manter nossa l\u00f3gica do jogo para isso vamos usar a palavra reservada fn</p> <pre><code>fn game() -&gt; () {\n    println!(\"Iniciar Jogo\");\n}\n</code></pre> <p>Com isso movemos nosso print iniciar jogo para dentro da fun\u00e7\u00e3o e vamos ver que vai continuar funcionando vale notar que na fun\u00e7\u00e3o n\u00f3s anotamos <code>()</code> que quer dizer que a fun\u00e7\u00e3o vai retornar uma Option vazia ou seja se for OK v\u00e3o vai ter valor algum isso faz a fun\u00e7\u00e3o main que chama a fun\u00e7\u00e3o game saber que essa fun\u00e7\u00e3o n\u00e3o tem retorno se n\u00f3s tentarmos receber algum valor de game n\u00f3s vamos receber a Option por\u00e9m ela vai ver sem nenhum valor, com isso n\u00f3s nunca vamos receber um valor Nulo no m\u00e1ximo um Option com um Ok por\u00e9m n\u00e3o existe um valor empty ou None isso \u00e9 uma caracteristica do rust para trabalhar sem usar valores nulos. Agora quero que nosso jogo defina o n\u00famero secreto, nesse momento vamos definir um n\u00famero fixo, mais a frente vamos fazer esse n\u00famero ser aleat\u00f3rio, tamb\u00e9m vamos receber a pontua\u00e7\u00e3o do jogador e vamos j\u00e1 contar um erro e o fim do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                ==\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(pontuacao=_pontuacao, numero=_numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game(pontuacao: u16, numero: u8) -&gt; () {\n    println!(\"Iniciar Jogo\");\n    ==\n    pontuacao = pontuacao - 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n    ==\n}\n</code></pre> <p>Se tentarmos compilar vamos receber o erro abaixo:</p> <pre><code>\u276e cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0384]: cannot assign to immutable argument `pontuacao`\n  --&gt; src/main.rs:35:5\n   |\n33 | fn game(pontuacao: u16, numero: u8) -&gt; () {\n   |         --------- help: consider making this binding mutable: `mut pontuacao`\n34 |     println!(\"Iniciar Jogo\");\n35 |     pontuacao = pontuacao - 100;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to previous error\n</code></pre> <p>Essa mensagem diz que pontua\u00e7\u00e3o dentro de game \u00e9 um atributo imut\u00e1vel ent\u00e3o precisamos deixar nosso parametro mut\u00e1vel. ent\u00e3o simplesmente vamos usar um mut no cabe\u00e7alho da fun\u00e7\u00e3o game.</p> <pre><code>fn game(mut pontuacao: u16, numero: u8) -&gt; () {\n...\n</code></pre> <p>Agora se rodarmos vai voltar o resultado que gostariamos.</p> <pre><code>Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\n...\n</code></pre> <p>Agora vamos mudar um pouco queremos que nosso print do resultado tamb\u00e9m seja impresso depois que o loop do game acabar ent\u00e3o vamos copia-lo pra fora da fun\u00e7\u00e3o.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(_pontuacao, _numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n</code></pre> <p>Agora vamos receber essa saida</p> <pre><code>\u279c cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\n     Running `target/debug/guessing_game`\nBem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n</code></pre> <p>O que aconteceu? Acontece que do jeito que est\u00e1 a fun\u00e7\u00e3o game est\u00e1 recebendo uma c\u00f3pia dos valores de _pontuacao e _numero_alvo ou seja o valor reduzido de 900 s\u00f3 existe dentro da fun\u00e7\u00e3o game quando a fun\u00e7\u00e3o termina o rust limpa as vari\u00e1veis do escopo de game poderiamos facilmente resolver isso fazendo com que game retorne o valor de 900 para nossa vari\u00e1vel _pontuacao mas, podemos resolver isso sem precisar duplicar os valores dentro da fun\u00e7\u00e3o passando a refer\u00eancia delas atrav\u00e9s de Borrowing que \u00e9 o que vamos discutir a seguinte.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#ownership-e-borrowing","title":"Ownership e Borrowing","text":"<p>Rust introduz o conceito de \"ownership\" (propriedade) e \"borrowing\" (empr\u00e9stimo) para gerenciar a mem\u00f3ria de forma segura. Isso implica que, em Rust, voc\u00ea precisa seguir regras rigorosas para acessar e modificar a mem\u00f3ria. A ideia principal \u00e9 que um recurso s\u00f3 pode ser possu\u00eddo por uma \u00fanica parte do c\u00f3digo em um determinado momento.</p> <ul> <li>Propriedade (Ownership): Uma vari\u00e1vel \u00e9 a \"dona\" de um recurso e \u00e9 respons\u00e1vel por liber\u00e1-lo quando n\u00e3o for mais necess\u00e1rio.</li> <li>Empr\u00e9stimo (Borrowing): Outras partes do c\u00f3digo podem \"emprestar\" acesso \u00e0 vari\u00e1vel, mas n\u00e3o podem modificar a propriedade.</li> </ul> <p>Assim sendo no nosso caso particular podemos pedir pro rust nos dar as refer\u00eancias das vari\u00e1veis _pontuacao e _numero_alvo assim sendo ele n\u00e3o cria uma nova vari\u00e1vel <code>numero</code> e <code>pontuacao</code> ele vai simplesmente pegar a referencia onde est\u00e1 armazenado os valores de _pontuacao e _numero_alvo e come\u00e7ar a apontar para os parametros que existem na fun\u00e7\u00e3o assim quando a fun\u00e7\u00e3o terminar ela vai devolver as refer\u00eancias para os parametros originais.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                ==\n                game(&amp;mut _pontuacao, &amp;_numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\n==\nfn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n==\n    println!(\"Iniciar Jogo\");\n    ==\n    *pontuacao -= 100;\n    ==\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Aqui fizemos algumas altera\u00e7\u00f5es a primeira \u00e9 que passamos na vari\u00e1vel o simbolo \"&amp;\" que indica que estamos emprestando a refer\u00eancia para a fun\u00e7\u00e3o ou seja ela vai ser tempor\u00e1riamente a dona dos parametros passados e no caso de pontua\u00e7\u00e3o n\u00f3s passamos como &amp;mut que quer dizer que ela pode ser modificada, caso fosse passado apenas om o &amp; comercial a fun\u00e7\u00e3o game s\u00f3 teria a permiss\u00e3o de ler o parametro e n\u00e3o modificalo.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n</code></pre> <p>No cabe\u00e7alho da fun\u00e7\u00e3o mudamos tamb\u00e9m indicando que pontua\u00e7\u00e3o \u00e9 a referencia mutavel de um u16 e a referencia de u8 assim na compila\u00e7\u00e3o ele sabe que a fun\u00e7\u00e3o est\u00e1 trabalhando com refer\u00eancias e n\u00e3o vai criar uma c\u00f3pia da fun\u00e7\u00e3o.</p> <p>Por ultimo vamos fazer uma altera\u00e7\u00e3o na nossa opera\u00e7\u00e3o de subtra\u00e7\u00e3o</p> <pre><code>    *pontuacao -= 100;\n</code></pre> <p>Usamos o simbilo \"*\" para indicar que n\u00e3o queremos mexer na refer\u00eancia onde est\u00e1 pontuacao mas, no valor que ele possui assim o valor que estava em _pontuacao mudou de 1000 para 900.</p> <p>Agora com isso conseguimos compreender as linhas onde capturamos a entrada do teclado do jogador</p> <pre><code>        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>Onde criamos uma vari\u00e1vel escolha_str que \u00e9 uma String vazia e mut\u00e1vel e quando chamamos a fun\u00e7\u00e3o read_line n\u00f3s passamos a refer\u00eancia mut\u00e1vel de escolha_str e enquanto ela est\u00e1 em execu\u00e7\u00e3o ela est\u00e1 alterando o valor do <code>escolha_str</code> para n\u00f3s e quando termina conseguimos usar o valor de escolha_str com os valores modificados pela fun\u00e7\u00e3o <code>read_line</code> sem precisar duplicar a vari\u00e1vel dentro da fun\u00e7\u00e3o.  \u00c9 importante refor\u00e7ar que em muitas linguagens n\u00e3o conseguimos fazer isso n\u00f3s normalmente precisamos receber a copia modificada dentro da fun\u00e7\u00e3o para conseguir trabalhar. Essa caracter\u00edstica do rust \u00e9 muito importante para casos que trabalhamos com pouca mem\u00f3ria ou mesmo um jogo onde quanto menos recursos usarmos mais leve ser\u00e1 nosso jogo.</p>"},{"location":"1_2_tipos_de_dados_e_funcoes/#introduzindo-testes-ao-nosso-codigo","title":"Introduzindo testes ao nosso c\u00f3digo","text":""},{"location":"1_2_tipos_de_dados_e_funcoes/#criando-nossa-funcao-do-jogo","title":"Criando nossa fun\u00e7\u00e3o do jogo","text":""},{"location":"1_2_tipos_de_dados_e_funcoes/#seguranca-de-memoria","title":"Seguran\u00e7a de Mem\u00f3ria","text":"<p>Rust fornece uma s\u00e9rie de garantias de seguran\u00e7a de mem\u00f3ria durante o tempo de compila\u00e7\u00e3o. Essas garantias s\u00e3o fundamentais para evitar erros comuns, como vazamentos de mem\u00f3ria, refer\u00eancias nulas e acessos inv\u00e1lidos.</p> <ul> <li>Sem Refer\u00eancias Nulas: Rust garante que as refer\u00eancias n\u00e3o sejam nulas, eliminando muitos erros de acesso nulo.</li> <li>Sem Vazamentos de Mem\u00f3ria: Rust controla rigorosamente o ciclo de vida dos recursos, o que impede vazamentos de mem\u00f3ria.</li> <li>Sem Concorr\u00eancia de Dados Mut\u00e1veis: Rust imp\u00f5e regras rigorosas para evitar a concorr\u00eancia de dados mut\u00e1veis, garantindo a seguran\u00e7a em threads.</li> </ul>"},{"location":"INDICE/","title":"Summary","text":"<ul> <li>Chapter 1</li> </ul>"},{"location":"INDICE/#ementa-desenvolvimento-de-jogos-em-ascii-com-rust","title":"Ementa: Desenvolvimento de Jogos em ASCII com Rust","text":""},{"location":"INDICE/#topico-1-conceitos-basicos-de-rust","title":"T\u00f3pico 1: Conceitos B\u00e1sicos de Rust","text":"<ul> <li>Vari\u00e1veis e Mutabilidade</li> <li>Tipos de Dados e Fun\u00e7\u00f5es</li> <li>Controle de Fluxo e Propriedade (Ownership)</li> </ul>"},{"location":"INDICE/#topico-2-introducao-a-arte-ascii","title":"T\u00f3pico 2: Introdu\u00e7\u00e3o \u00e0 Arte ASCII","text":"<ul> <li>Manipula\u00e7\u00e3o de Strings e Caracteres ASCII</li> <li>Sa\u00edda para o Terminal e Interface do Usu\u00e1rio</li> </ul>"},{"location":"INDICE/#topico-3-implementando-a-logica-de-jogos","title":"T\u00f3pico 3: Implementando a L\u00f3gica de Jogos","text":"<ul> <li>Vetores e Matrizes</li> <li>Algoritmos de Busca e Ordena\u00e7\u00e3o</li> </ul>"},{"location":"INDICE/#topico-4-gerenciamento-de-tela-e-interface-do-usuario","title":"T\u00f3pico 4: Gerenciamento de Tela e Interface do Usu\u00e1rio","text":"<ul> <li>Manipula\u00e7\u00e3o de Tela e Terminal (ANSI escape codes)</li> <li>Entrada do Usu\u00e1rio (stdin) e Gerenciamento de Eventos</li> </ul>"},{"location":"INDICE/#topico-5-mecanica-de-jogo","title":"T\u00f3pico 5: Mec\u00e2nica de Jogo","text":"<ul> <li>Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto State</li> </ul>"},{"location":"INDICE/#topico-6-tratamento-de-eventos","title":"T\u00f3pico 6: Tratamento de Eventos","text":"<ul> <li>Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto Observer</li> </ul>"},{"location":"INDICE/#topico-7-controle-de-estado-e-salvamento-do-jogo","title":"T\u00f3pico 7: Controle de Estado e Salvamento do Jogo","text":"<ul> <li>Serializa\u00e7\u00e3o e Desserializa\u00e7\u00e3o de Dados</li> </ul>"},{"location":"INDICE/#topico-8-desafios-e-recursos-avancados","title":"T\u00f3pico 8: Desafios e Recursos Avan\u00e7ados","text":"<ul> <li>Threads e Concorr\u00eancia</li> <li>Gerenciamento de Mem\u00f3ria Avan\u00e7ado (Rc, Arc, Mutex)</li> </ul>"},{"location":"INDICE/#topico-9-desenvolvimento-de-jogos-completos-em-ascii","title":"T\u00f3pico 9: Desenvolvimento de Jogos Completos em ASCII","text":"<ul> <li>Estrutura de Projeto e Organiza\u00e7\u00e3o de Arquivos</li> <li>Tratamento de Erros (Result, Option)</li> <li>Documenta\u00e7\u00e3o do C\u00f3digo</li> </ul>"},{"location":"INDICE/#topico-10-projeto-final-jogo-completo-em-ascii","title":"T\u00f3pico 10: Projeto Final: Jogo Completo em ASCII","text":"<ul> <li>Aplica\u00e7\u00e3o de todos os conceitos aprendidos para criar um jogo completo e original em ASCII.</li> </ul>"}]}