{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem vindo ao curso Rust l\u00f3gica com jogos","text":"<p>Esse material est\u00e1 em desenvolvimento ent\u00e3o sugest\u00f5es s\u00e3o sempre bem-vindas.</p>"},{"location":"#o-que-e-rust","title":"O que \u00e9 Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o compilada que se destaca por oferecer um alto desempenho, controle de mem\u00f3ria sem a necessidade de um coletor de lixo e garantias de seguran\u00e7a. Ela foi desenvolvida pela Mozilla Research e \u00e9 projetada para ser eficiente, segura e pr\u00e1tica.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi projetado para oferecer uma experi\u00eancia pr\u00e1tica no ensiono da linguagem Rust, usando desenvolvimento de jogos em ASCII e textual. Durante o curso, o objetivo principal \u00e9 proporcionar aos participantes um entendimento abrangente dos conceitos fundamentais da linguagem Rust, juntamente com a aplica\u00e7\u00e3o pr\u00e1tica desses conhecimentos na cria\u00e7\u00e3o de jogos mesmo n\u00e3o sendo o foco do curso ensinar a fazer jogos profissionalmente.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Durante esse curso voc\u00ea vai aprender o b\u00e1sico de Rust como fluxos condicionais, repeti\u00e7\u00e3o, uso de fun\u00e7\u00f5es, escopo de v\u00e1riaveis at\u00e9 t\u00f3picos avan\u00e7ados como Threads e concorr\u00eancia.</p>"},{"location":"#esse-curso-e-gratuito","title":"Esse curso \u00e9 gratuito?","text":"<p>Essa wiki \u00e9 gratuita assim como os exerc\u00edcios, por\u00e9m tamb\u00e9m h\u00e1 um curso em v\u00eddeo e esse ser\u00e1 pago.</p>"},{"location":"#onde-ele-sera-disponibilizado","title":"Onde ele ser\u00e1 disponibilizado?","text":"<p>O curso vai ser disponibilizado atrav\u00e9s da minha plataforma de cursos.</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9 requisitos","text":"<p>Para fazer esse curso \u00e9 importante ter no\u00e7\u00f5es b\u00e1sicas de inform\u00e1tica como: - Saber usar um navegador - Saber entrar num prompt de comando seja no Windows, Mac ou Linux - J\u00e1 ter conhecimento em outra linguagem \u00e9 desej\u00e1vel mas, n\u00e3o \u00e9 essencial pois vamos trabalhar do zero e contruir projetos</p> <p>Obs: O curso ser\u00e1 desenvolvido totalmente em linux, caso queira usar Windows \u00e9  Eu fiz um v\u00eddeo explicando como instalar o Rust no Windows.</p>"},{"location":"#ementa","title":"Ementa","text":""},{"location":"#jogos","title":"Jogos","text":""},{"location":"#apos-esse-curso-vou-estar-capacitado-a-fazer-jogos-profissionalmente","title":"Ap\u00f3s esse curso vou estar capacitado a fazer jogos profissionalmente?","text":"<p>N\u00e3o, mesmo que seja abordados alguns principios do desenvolvimento de jogos, esse curso n\u00e3o tem como objetivo ajudar o aluno a fazer jogos profissionais, nesse caso o instrutor ainda recomenda buscar outros materiais para se aprofundar no tema.</p>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"Quem vai ministrar essas aulas?","text":"<p>Ol\u00e1 eu sou o J\u00f4natas sou um profissional com 17 anos de experi\u00eancia no desenvolvimento de sistemas e websites, meu foco principal est\u00e1 sistemas web. Comecei a aprender Rust em 2020 e estou trabalhando no meu primeiro jogo profissionalmente. Tamb\u00e9m tenho um canal no Youtube Fa\u00e7o lives na Twitch</p>"},{"location":"#o-que-voce-precisa-para-acompanhar-o-curso","title":"O que voc\u00ea precisa para acompanhar o curso?","text":"<ul> <li>Editor de texto ou IDE: Recomendo qualquer editor que tenha a capacidade de identicar c\u00f3digo Rust, durante os v\u00eddeos vou usar alguns como nvim o helix e o Zed mas, voc\u00ea pode usar qual quiser, se voc\u00ea for iniciante recomendo usar o Zed ou o vscodium.</li> </ul>"},{"location":"#repositorio","title":"Reposit\u00f3rio","text":"<p>Todas os exemplos criados para o curso assim como exercic\u00edos estar\u00e3o no reposit\u00f3rio abaixo. https://github.com/jonatasoli/rust-logica-jogos-material</p>"},{"location":"#como-posso-ajudar","title":"Como posso ajudar?","text":"<p>Em primeiro lugar fazendo o curso e dando feedback do que gostou e o que n\u00e3o gostou me ajuda muito. Sugest\u00f5es de melhoria e corre\u00e7\u00f5es s\u00e3o sempre bem vindas.</p> <p>Caso desejar poder\u00e1 me ajudar tamb\u00e9m atrav\u00e9s do github sponsor ou por pix <code>contact@jonatasoliveira.dev</code> valor arrecadado vai me ajudar a me manter durante a produ\u00e7\u00e3o do curso.</p>"},{"location":"#agradecimentos","title":"Agradecimentos","text":"<p>Reinaldo por fazer revis\u00f5es pontuais no material Henrique Sebasti\u00e3o por adicionar a possibilidade de alternar o tema entre claro e escuro</p>"},{"location":"1_0_introducao/","title":"Introdu\u00e7\u00e3o","text":"<p>Bem vindo ao curso de Rust l\u00f3gica com jogos, voc\u00ea vai aprender: - Como fazer esse curso? - O que \u00e9 Rust? - Principais caracter\u00edsticas do Rust - Instala\u00e7\u00e3o do Rust - Configura\u00e7\u00e3o do editor - Principios b\u00e1sicos de um jogo eletr\u00f4nico - O que \u00e9 GDD? WIP</p>"},{"location":"1_0_introducao/#como-fazer-esse-curso","title":"Como fazer esse curso?","text":"<p>Para inicio voc\u00ea pode assistir um v\u00eddeo meu sobre meu m\u00e9todo de estudo mas, resumidamente: - Monte um cronograma - Veja o conte\u00fado - Fa\u00e7a os exercicios sugeridos - Use os exerc\u00edcios sugeridos como uma revis\u00e3o do conte\u00fado</p>"},{"location":"1_0_introducao/#o-que-e-rust","title":"O que \u00e9 Rust?","text":"<p>Nos \u00faltimos anos, a linguagem de programa\u00e7\u00e3o Rust tem ganhado destaque no cen\u00e1rio de desenvolvimento de software. Criada pela Mozilla Research e lan\u00e7ada em 2010, Rust \u00e9 uma linguagem de programa\u00e7\u00e3o de sistema que se destaca por sua seguran\u00e7a, performance e facilidade de uso.</p>"},{"location":"1_0_introducao/#principais-caracteristicas-do-rust","title":"Principais caracter\u00edsticas do Rust","text":""},{"location":"1_0_introducao/#seguranca","title":"Seguran\u00e7a","text":"<p>Um dos principais atrativos de Rust \u00e9 sua forte \u00eanfase na seguran\u00e7a. Ao combinar uma rigorosa verifica\u00e7\u00e3o de tipos em tempo de compila\u00e7\u00e3o com um sistema de gerenciamento de mem\u00f3ria sem garbage collector, Rust elimina muitas das classes comuns de bugs que assolam outras linguagens, como corrup\u00e7\u00e3o de mem\u00f3ria, vazamentos de mem\u00f3ria e race conditions.</p> <p>O sistema de tipos de Rust \u00e9 projetado para capturar erros em tempo de compila\u00e7\u00e3o que poderiam levar a falhas de seguran\u00e7a em tempo de execu\u00e7\u00e3o, como acessos inv\u00e1lidos \u00e0 mem\u00f3ria ou uso indevido de ponteiros. Isso \u00e9 poss\u00edvel gra\u00e7as a recursos exclusivos, como o conceito de propriedade (ownership) e empr\u00e9stimos (borrowing), que garantem que os recursos de mem\u00f3ria sejam gerenciados de forma segura durante toda a vida \u00fatil do programa.</p>"},{"location":"1_0_introducao/#performance","title":"Performance","text":"<p>Al\u00e9m de sua forte \u00eanfase na seguran\u00e7a, Rust tamb\u00e9m \u00e9 conhecida por sua excelente performance. Ao fornecer controle de baixo n\u00edvel sobre os recursos de hardware, como gerenciamento de mem\u00f3ria e concorr\u00eancia, Rust permite que os desenvolvedores escrevam c\u00f3digo altamente eficiente que rivaliza com linguagens de sistema tradicionais, como C e C++, sem sacrificar a seguran\u00e7a.</p> <p>A abordagem \u00fanica de Rust para a concorr\u00eancia, baseada em suas garantias de seguran\u00e7a em tempo de compila\u00e7\u00e3o, tamb\u00e9m torna mais f\u00e1cil escrever c\u00f3digo concorrente que \u00e9 livre de race conditions e deadlock, enquanto ainda aproveita ao m\u00e1ximo o poder do hardware moderno.</p>"},{"location":"1_0_introducao/#instalacao-do-rust","title":"Instala\u00e7\u00e3o do Rust","text":"<p>Para instalar o rust simplesmente abra seu terminal ou prompt de commando e cole o c\u00f3digo abaixo:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <p>Para windows <code>chocolatey</code>:</p> <pre><code>choco install rust\n\n</code></pre> <p>Para mac (Homebrew):</p> <pre><code>brew install rustup\n</code></pre>"},{"location":"1_0_introducao/#configuracao-do-editor","title":"Configura\u00e7\u00e3o do editor","text":"<p>Isso varia de acordo com o editor que voc\u00ea quer usar vou por aqui algumas sugest\u00f5es: - NeoVim - Helix - Emacs</p>"},{"location":"1_0_introducao/#principios-basicos-de-um-jogo-eletronico","title":"Principios b\u00e1sicos de um jogo eletr\u00f4nico","text":"<p>Os jogos eletr\u00f4nicos s\u00e3o formas de entretenimento interativo que envolvem os jogadores em experi\u00eancias virtuais atrav\u00e9s de dispositivos eletr\u00f4nicos, como consoles de videogame, computadores e dispositivos m\u00f3veis. Eles abrangem uma ampla variedade de g\u00eaneros, desde jogos de a\u00e7\u00e3o e aventura at\u00e9 quebra-cabe\u00e7as e jogos de simula\u00e7\u00e3o.</p>"},{"location":"1_0_introducao/#principios-basicos-dos-jogos-eletronicos","title":"Princ\u00edpios B\u00e1sicos dos Jogos Eletr\u00f4nicos","text":"<ol> <li> <p>Objetivo Todos os jogos t\u00eam um objetivo ou um conjunto de objetivos que os jogadores devem alcan\u00e7ar para progredir ou vencer o jogo. Isso pode incluir coletar itens, derrotar inimigos, resolver quebra-cabe\u00e7as ou alcan\u00e7ar uma pontua\u00e7\u00e3o espec\u00edfica.</p> </li> <li> <p>Regras Os jogos tamb\u00e9m t\u00eam regras que definem o funcionamento do jogo e o que os jogadores podem e n\u00e3o podem fazer. Essas regras podem incluir limites de tempo, restri\u00e7\u00f5es de movimento, condi\u00e7\u00f5es de vit\u00f3ria e derrota, entre outras.</p> </li> <li> <p>Interatividade Um dos aspectos mais distintivos dos jogos eletr\u00f4nicos \u00e9 sua interatividade. Os jogadores t\u00eam a capacidade de interagir com o mundo do jogo de v\u00e1rias maneiras, como mover personagens, tomar decis\u00f5es, resolver quebra-cabe\u00e7as e muito mais.</p> </li> <li> <p>Feedback Os jogos fornecem feedback aos jogadores para inform\u00e1-los sobre seu desempenho e progresso no jogo. Isso pode incluir efeitos visuais, sons, pontua\u00e7\u00f5es e mensagens na tela que indicam se uma a\u00e7\u00e3o foi bem-sucedida ou n\u00e3o.</p> </li> <li> <p>Desafio Os jogos s\u00e3o projetados para desafiar os jogadores e oferecer uma experi\u00eancia gratificante \u00e0 medida que eles superam obst\u00e1culos e alcan\u00e7am seus objetivos. O equil\u00edbrio entre desafio e habilidade \u00e9 fundamental para manter os jogadores envolvidos e motivados.</p> </li> <li> <p>Imers\u00e3o A imers\u00e3o \u00e9 a capacidade dos jogos de envolver os jogadores em um mundo virtual convincente. Isso pode ser alcan\u00e7ado por meio de gr\u00e1ficos realistas, trilha sonora envolvente, narrativa cativante e mec\u00e2nicas de jogo envolventes.</p> </li> <li> <p>Progress\u00e3o Os jogos geralmente apresentam um sistema de progress\u00e3o que permite aos jogadores avan\u00e7ar no jogo e desbloquear novos conte\u00fados, como n\u00edveis, personagens, habilidades e itens, \u00e0 medida que progridem.</p> </li> </ol>"},{"location":"1_0_introducao/#o-que-e-gdd","title":"O que \u00e9 GDD?","text":"<p>O Guia de Design de Jogo (GDD) \u00e9 um documento crucial no desenvolvimento de jogos, servindo como um mapa do tesouro para os criadores de jogos.</p> <p>Um Guia de Design de Jogo (GDD) \u00e9 um documento detalhado que descreve todos os aspectos de um jogo, desde sua concep\u00e7\u00e3o inicial at\u00e9 sua implementa\u00e7\u00e3o final. Ele serve como um guia abrangente para todos os membros da equipe de desenvolvimento de jogos, fornecendo uma vis\u00e3o clara e coesa do que o jogo ser\u00e1 e como ele ser\u00e1 criado.</p> <p>O GDD pode ser super detalhado ou apenas com os pontos principais do jogo, o importante que usamos ele como guia.</p>"},{"location":"1_1_jogo_floresta_misteriosa/","title":"Floresta Misteriosa","text":"<p>Para iniciar vamos dar um raio-x sobre nosso primeiro jogo, em a floresta misteriosa o jogador assume um papel de um aventureiro corajoso  que se aventura por uma floresta misteriosa. A cada escolha que o jogador faz v\u00e3o influenciar a sua jornada, dependendo da sua decis\u00e3o voc\u00ea vai ganhar ou perder pontos se voc\u00ea alcan\u00e7ar 100 pontos voc\u00ea vence o jogo.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#regras","title":"Regras","text":"<p>Nosso jogo apresentar\u00e1 um menu ao nosso jogador com as op\u00e7\u00f5es que ele pode escolher. Como nosso escopo \u00e9 pequeno vamos limitar em 4 escolhas.</p> <ul> <li>Ele pode beber agua no rio onde o jogador vai ganhar 10 pontos.</li> <li>Ele pode passar pela ponte fr\u00e1gil onde ele vai perder 20 pontos.</li> <li>Ele pode querer entrar na caverna escura ele vai ganhar 50 pontos.</li> <li>Ele pode passar pelo caminho iluminado onde vai perder 20 pontos.</li> </ul> <p>Essas escolhas v\u00e3o aparecendo toda vez que o jogador faz uma escolha at\u00e9 ele ganhar ou perder o jogo. Caso ele consiga 100 pontos o jogador ganha e se o jogador chegar a 0 ele perde.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#criando-o-projeto","title":"Criando o projeto","text":"<p>Bom primeiro vamos criar um diret\u00f3rio onde vamos armazenar nossos projetos do curso, minha sugest\u00e3o \u00e9 criar um diret\u00f3rio chamado projects. Ent\u00e3o vamos abrir um terminal primeiro vamos usar o comando <code>cd</code> para ir at\u00e9 o diret\u00f3rio <code>Home</code> do seu computador e depois vamos usar o comando <code>mkdir</code> para criar um diret\u00f3rio.</p> <pre><code>cd\nmkdir projects\n</code></pre> <p>Caso queria se aprofundar sobre os comandos via terminal minha sugest\u00e3o \u00e9 dar uma conferida no guia focalinux ele vai lhe ajudar a ter um entendimento melhor do funcionando dos comandos posix mas, vou explicando cada comando no terminal que vamos usar ao decorrer do curso.</p> <p>Bom agora vamos acessar o diret\u00f3rio que criamos.</p> <pre><code>cd projects\n</code></pre> <p>Agora que acessamos o diret\u00f3rio que vamos trabalho, o pr\u00f3ximo passo \u00e9 criarmos nosso projeto em rust, para criar um projeto em rust vamos usar o comando <code>cargo new</code> e o nome do nosso projeto \u00e9 chamado <code>mysterious_forest</code>. Assim ele vai criar um diret\u00f3rio chamado <code>mysterious_forest</code> para confirmar-mos se a pasta foi criada vamos usar o comando <code>ls -la</code> onde o <code>-la</code> \u00e9 um parametro apenas para listarmos tamb\u00e9m os arquivos ocultos.</p> <pre><code>cargo new mysterious_forest\nls -la\n</code></pre> <p>Agora vamos acessar o direorio que criamos no qual podemos acessa-lo atrav\u00e9s do comando <code>cd mysterious_forest</code>.</p> <pre><code>cd mysterious_forest\n</code></pre> <p>Agora podemos usar novamente o comando <code>ls -la</code> para vermos o que o comando cargo criou no nosso projeto.</p> <pre><code>.git\n.gitignore\nCargo.toml\nsrc\n</code></pre> <p>Uma observa\u00e7\u00e3o os arquivos com o <code>.</code> na frente como o <code>.git</code> e o <code>.gitignore</code> s\u00e3o arquivos ocultos no linux.</p> <p>Bom agora vou dar o comando <code>cargo run</code> para executar meu projeto.</p> <p>Assim vamos ter a sa\u00edda.</p> <pre><code>\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nHello, world!\n</code></pre> <p>Uma coisa interessante de notar quando executamos um projeto rust \u00e9 que na primeira linha: <code>Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)</code> N\u00f3s temos o nome do nosso execut\u00e1vel, no caso <code>mysterious_forest</code> e a vers\u00e3o do nosso execut\u00e1vel no caso <code>v0.1.0</code>.</p> <p>Na segunda linha temos: <code>Finished dev [unoptimized + debuginfo] target(s) in 0.12s</code> Aqui temos a informa\u00e7\u00e3o que nosso execut\u00e1vel foi compilado em modo dev e o tempo de compila\u00e7\u00e3o no caso <code>0.12</code></p> <p>Na terceira linha temos: <code>Running target/debug/mysterious_forest</code> Essa linha nos mostra onde fica nosso execut\u00e1vel ele que vamos dar a para que as pessoas possam jogar nosso jogo.</p> <p>Certo agora vamos entrar no projeto no arquivo no caminho <code>src/main.rs</code></p> <pre><code>fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre> <p>Isso \u00e9 um \"Hello, world!\" padr\u00e3o de um projeto rust, ent\u00e3o nesse caso n\u00e3o come\u00e7amos com um \"Hello, world!\" no projeto pois ele j\u00e1 vem no momento da cria\u00e7\u00e3o.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#falando-de-tipagem","title":"Falando de tipagem","text":"<p>A tipagem em programa\u00e7\u00e3o se refere \u00e0 maneira como as linguagens de programa\u00e7\u00e3o tratam os tipos de dados, ou seja, como elas definem e gerenciam os diferentes tipos de valores que podem ser usados em um programa. Rust \u00e9 uma linguagem de programa\u00e7\u00e3o que utiliza um sistema de tipagem est\u00e1tica, o que significa que os tipos de dados s\u00e3o verificados em tempo de compila\u00e7\u00e3o, tornando o c\u00f3digo mais seguro e eficiente. Tipagem Est\u00e1tica</p> <p>Em Rust, voc\u00ea precisa declarar explicitamente o tipo de dado que uma vari\u00e1vel pode armazenar. Isso \u00e9 feito durante a declara\u00e7\u00e3o da vari\u00e1vel, permitindo que o compilador verifique se o valor atribu\u00eddo \u00e0 vari\u00e1vel \u00e9 compat\u00edvel com o tipo declarado. Se houver uma incompatibilidade de tipos, o c\u00f3digo n\u00e3o ser\u00e1 compilado, o que ajuda a evitar erros em tempo de execu\u00e7\u00e3o. Tipos Primitivos em Rust</p> <p>Rust possui uma s\u00e9rie de tipos primitivos que podem ser usados para representar diferentes tipos de dados. Vamos dar uma olhada nos tipos primitivos mais comuns em Rust: 1. Integer Types (Tipos Inteiros)</p> <p>Os tipos inteiros em Rust representam n\u00fameros inteiros sem parte fracion\u00e1ria. Aqui est\u00e3o alguns dos tipos inteiros mais comuns, junto com sua faixa de valores:</p> <pre><code>i8: Intervalo de -128 a 127.\n\ni16: Intervalo de -32,768 a 32,767.\n\ni32: Intervalo de -2,147,483,648 a 2,147,483,647.\n\ni64: Intervalo de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807.\n\ni128: Intervalo extremamente grande de n\u00fameros inteiros com sinal.\n</code></pre> <p>Por exemplo, voc\u00ea pode declarar uma vari\u00e1vel inteira em Rust da seguinte forma:</p> <pre><code>rust\n\nlet numero: i32 = 42;\n</code></pre> <p>Os tipos inteiros sem sinal, representados com u, t\u00eam os mesmos tamanhos que os tipos inteiros com sinal e representam apenas valores n\u00e3o negativos. Por exemplo, u8 varia de 0 a 255, u16 varia de 0 a 65,535 e assim por diante. 2. Floating-Point Types (Tipos de Ponto Flutuante)</p> <p>Os tipos de ponto flutuante em Rust representam n\u00fameros com parte fracion\u00e1ria. Os tipos mais comuns s\u00e3o:</p> <pre><code>f32: Representa n\u00fameros de ponto flutuante de precis\u00e3o simples.\n\nf64: Representa n\u00fameros de ponto flutuante de dupla precis\u00e3o (mais precisos).\n</code></pre> <p>Exemplo:</p> <pre><code>rust\n\nlet pi: f64 = 3.14159;\n</code></pre> <ol> <li>Boolean Type (Tipo Booleano)</li> </ol> <p>O tipo booleano em Rust \u00e9 usado para representar valores verdadeiro (true) ou falso (false). \u00c9 frequentemente usado em express\u00f5es condicionais e l\u00f3gicas.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet esta_chovendo: bool = true;\n</code></pre> <ol> <li>Character Type (Tipo de Caractere)</li> </ol> <p>Rust tamb\u00e9m possui um tipo de caractere chamado char, que representa um \u00fanico caractere Unicode. Isso \u00e9 \u00fatil para lidar com texto e caracteres especiais.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet letra: char = 'A';\n</code></pre> <ol> <li>String Type (Tipo de Texto)</li> </ol> <p>Rust diferencia entre dois tipos relacionados: str e String.</p> <pre><code>str: Representa uma sequ\u00eancia de caracteres imut\u00e1vel (n\u00e3o pode ser modificada ap\u00f3s a cria\u00e7\u00e3o) e \u00e9 frequentemente usado com refer\u00eancias (&amp;str) para manipula\u00e7\u00e3o de texto eficiente.\n\nString: Representa uma sequ\u00eancia de caracteres mut\u00e1vel (pode ser modificada) e \u00e9 mais flex\u00edvel, geralmente alocada na mem\u00f3ria de forma din\u00e2mica.\n</code></pre> <p>Exemplo:</p> <pre><code>rust\n\nlet texto_estatico: &amp;str = \"Isso \u00e9 um texto imut\u00e1vel\";\nlet mut texto_mutavel: String = String::from(\"Isso \u00e9 um texto mut\u00e1vel\");\n</code></pre> <p>Essa \u00e9 uma explica\u00e7\u00e3o mais abrangente sobre a tipagem em Rust, os tipos primitivos mais comuns e a diferen\u00e7a entre str e String. \u00c0 medida que voc\u00ea se familiariza mais com Rust, poder\u00e1 explorar tipos compostos, structs, enums e outros recursos poderosos que a linguagem oferece para lidar com problemas espec\u00edficos de programa\u00e7\u00e3o.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#variaveis","title":"Variaveis","text":"<p>Bom para come\u00e7ar nosso jogo precisamos definir algumas estruturas de dados que v\u00e3o armazenar a pontua\u00e7\u00e3o do nosso jogador e o qual escolha ele vai fazer em seguida, pra isso vamos precisar criar vari\u00e1veis.</p> <p>As vari\u00e1veis em rust s\u00e3o declarados usando a palavra reservada <code>let</code> o nome da vari\u00e1vel e o tipo dela al\u00e9m do seu valor de inicializa\u00e7\u00e3o. Uma v\u00e1riavel em rust \u00e9 diferente de outras linguagens pois ela \u00e9 imut\u00e1vel ou seja quando inicializamos ela, a mesma n\u00e3o altera seu valor, h\u00e1 uma forma de informar explicitamente que queremos que a vari\u00e1vel receba valores dinamicamente mas, vamos ver mais a frente.</p> <p>Ent\u00e3o agora dentro do nosso main vamos declarar a primeira vari\u00e1vel do nosso projeto.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n}\n ```\n\nVamos da uma olhada mais de perto no nosso c\u00f3digo:\n`fn` \u00e9 a palavra reservada para declarar uma fun\u00e7\u00e3o\n`main` \u00e9 o nome da nossa fun\u00e7\u00e3o e os parenteses `()` \u00e9 a estrutura que usamos para declarar os parametros da nossa fun\u00e7\u00e3o que no caso n\u00e3o temos nenhum ent\u00e3o ela est\u00e1 vazia.\nPara simplificar um pouco as coisas parametros nada mais \u00e9 que as vari\u00e1veis que uma fun\u00e7\u00e3o vai receber quando ela for executada, mas n\u00e3o tema em um outor momento vamos falar mais de fun\u00e7\u00f5es e parametros.\n`{}` determina um bloco de c\u00f3digo ent\u00e3o o que estiver ali dentro vai ser o c\u00f3digo que ser\u00e1 executado pela nossa fun\u00e7\u00e3o main.\n`let pontuacao: i32 = 0;` aqui declaramos nossa vari\u00e1vel come\u00e7ando com a palavra reservada `let` depois o nome da vari\u00e1vel que no caso \u00e9 `pontuacao` o tipo dela que no nosso caso \u00e9 um `i32` ai temos o `=` que o nosso simbulo de atribui\u00e7\u00e3o ou seja, que `pontuacao` vai receber um valor, na sequencia temos o valor que estamos inicializando que no caso \u00e9 o valor `0` e finalmente temos o simbulo `;` que indica pro compilador que a linha de execu\u00e7\u00e3o foi encerrada finalizando a instru\u00e7\u00e3o.\n\nCom isso podemos criar nossa segunda vari\u00e1vel:\n\n```rust\nfn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n}\n</code></pre> <p>Ent\u00e3o criamos uma variavel escolha que tamb\u00e9m \u00e9 uma <code>i32</code> s\u00f3 que agora colocamos como valor incial <code>1</code>.</p> <p>Para dar sequ\u00eancia no nosso projeto vamos criar uma mensagem de boas-vindas, pra isso vamos usar uma macro no rust que nada mais \u00e9 que uma sequ\u00eancia de instru\u00e7\u00f5es que v\u00e3o rodar internamente quando ela for executada que no nosso caso \u00e9 o <code>println!</code> o  <code>!</code> no final nos indica que ela \u00e9 uma macro.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    ==println!(\"Bem-vindo \u00e0 floresta misteriosa\")==\n}\n\n</code></pre> <p>Um ponto importante pra se observar n\u00f3s n\u00e3o usamos o simbolo <code>;</code> no final da nossa macro <code>println!</code> isso por que em rust dentro de um bloco de c\u00f3digo a ultima linha n\u00e3o precisa ter esse simbolo pois ele interpreta essa \u00faltima linha como o valor a se retornar da fun\u00e7\u00e3o no nosso caso por\u00e9m estamos executando uma macro que vai imprimir valores na tela ent\u00e3o ele basicamente n\u00e3o est\u00e1 retornando nada. Voc\u00ea pode observar que dentro dos parenteses da nossa macro temos os simbolos de aspas <code>\"\"</code> e dentro delas colocamos nosso texto com acentos. Como o rust usa o padr\u00e3o unicode para caracteres podemos usar qualquer simbolo ou diagrama representado pela tabela unicode. Mas, no nosso c\u00f3digo em si n\u00f3s evitamos usar acentos e caracteres especiais.</p> <p>Agora vamos imprimir na tela o valor da nossa escolha e a pontua\u00e7\u00e3o pra isso vamos usar novamente a macro <code>println!</code>.</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n    ==\n    println!(\"A sua escolha foi {}\", escolha);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}\", pontuacao)\n    ==\n}\n\n</code></pre> <p>Observe que s\u00f3 deixamos sem o <code>;</code> a ultima linha por isso no nosso primeiro <code>println!</code> agora tem a pontua\u00e7\u00e3o. Outra coisa \u00e9 que nosso c\u00f3digo est\u00e1 usando a macro de uma forma diferente. Temos o simbolo das chaves <code>{}</code> dentro das aspas, isso indica que queremos imprimir o valor de uma vari\u00e1vel que no nosso caso s\u00e3o as vari\u00e1veis <code>escolha</code> e <code>pontuacao</code>. No caso se quisermos colocar mais vari\u00e1veis dentro de uma string que \u00e9 o caso do nosso <code>println!</code> podemos usar mais chaves que ele vai entender.</p> <p>Agora podemos rodar novamente  o <code>cargo run</code> para ver o retorno da nossa fun\u00e7\u00e3o.</p> <pre><code>\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 0\n</code></pre> <p>Perfeito tudo funcionando!</p>"},{"location":"1_1_jogo_floresta_misteriosa/#controle-de-fluxo-condicional-com-if","title":"Controle de fluxo condicional com if","text":"<p>Vamos da uma olhada agora em como dar escolhas para nosso jogador. Primeiro vamos colocar um <code>println!</code> pedindo a escolha e 4 op\u00e7\u00f5es n\u00famericas para ele escolher.</p> <pre><code>\\\\ c\u00f3digo\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\\\\c\u00f3digo\n</code></pre> <p>Agora precisamos de um recurso que nos mostre que quando digitarmos no teclado a op\u00e7\u00e3o 1 ele fa\u00e7a a a\u00e7\u00e3o <code>Entrar na caverna escura</code> e assim com as demais op\u00e7\u00f5es e quando ele escolher a op\u00e7\u00e3o fa\u00e7a a soma ou a subtra\u00e7\u00e3o dos pontos. Pra isso vamos usar o <code>if</code> ele \u00e9 nosso primeiro condicional e com ele podemos fazer que com determinada escolha ele fa\u00e7a uma sequencia de a\u00e7\u00f5es no nosso caso se o jogador escolher a op\u00e7\u00e3o 1 precisa realizar a a\u00e7\u00e3o de somar 50 pontos na pontua\u00e7\u00e3o atual.</p> <pre><code>\\\\c\u00f3digo\n    println!(\"4 - Descansar na beira do riacho\");\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    }\n\\\\c\u00f3digo\n</code></pre> <p>Vamos ter um erro mas, vamos ignora-lo por enquanto, agora precisamos colocar as outras condi\u00e7\u00f5es ent\u00e3o usamos a palavra reservada <code>if</code> e poderiamos ficar usando ela para as demais op\u00e7\u00f5es mas, h\u00e1 um problema, nosso c\u00f3digo usando 4 <code>if's</code> nesse caso ele vai verificar todas 4 vezes em todos os casos. Ent\u00e3o podemos usar um outro recurso que \u00e9 o sen\u00e3o se  que basicamente vai verificar a primeira condi\u00e7\u00e3o e se ela n\u00e3o for verdade e vai verificar a pr\u00f3xima condi\u00e7\u00e3o e assim sucessivamente. O c\u00f3digo ficaria assim:</p> <pre><code>fn main() {\n    let pontuacao: i32 = 0;\n    let escolha: i32 = 1;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n==\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n==\n\n    println!(\"A sua escolha foi {}\", escolha);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}\", pontuacao)\n}\n</code></pre> <p>Agora vamos rodar nosso c\u00f3digo ele vai receber um erro igual o abaixo:</p> <pre><code>error[E0384]: cannot assign twice to immutable variable `pontuacao`\n  --&gt; src/main.rs:20:9\n   |\n2  |     let pontuacao: i32 = 0;\n   |         ---------\n   |         |\n   |         first assignment to `pontuacao`\n   |         help: consider making this binding mutable: `mut pontuacao`\n...\n20 |         pontuacao = pontuacao + 10;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\n</code></pre> <p>Aqui ele est\u00e1 dizendo que n\u00e3o pode mudar uma vari\u00e1vel imut\u00e1vel e \u00e9 isso que vamos explorar a seguinte.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#introducao-a-variaveis-e-imutabilidade","title":"Introdu\u00e7\u00e3o a v\u00e1riaveis e imutabilidade","text":"<p>Se voc\u00ea est\u00e1 come\u00e7ando a aprender sobre programa\u00e7\u00e3o, \u00e9 importante entender o que s\u00e3o vari\u00e1veis e constantes em Rust, uma linguagem de programa\u00e7\u00e3o moderna e segura. Vamos explorar esses conceitos e suas implica\u00e7\u00f5es, incluindo exemplos de constantes. Vari\u00e1veis em Rust</p> <p>Uma vari\u00e1vel em Rust \u00e9 uma forma de armazenar e manipular dados em um programa. \u00c9 como uma caixa que voc\u00ea pode usar para guardar informa\u00e7\u00f5es temporariamente. No entanto, Rust difere de muitas outras linguagens de programa\u00e7\u00e3o em um aspecto fundamental: por padr\u00e3o, as vari\u00e1veis s\u00e3o imut\u00e1veis, o que significa que n\u00e3o podem ser alteradas ap\u00f3s a primeira atribui\u00e7\u00e3o.</p> <p>Por exemplo, considere o seguinte c\u00f3digo:</p> <pre><code>rust\n\nlet nome = \"Alice\";\nnome = \"Bob\"; // Isso geraria um erro de compila\u00e7\u00e3o!\n</code></pre> <p>Neste exemplo, a tentativa de mudar o valor de nome para \"Bob\" resultaria em um erro de compila\u00e7\u00e3o. Isso ocorre porque, por padr\u00e3o, Rust preza pela seguran\u00e7a e evita que voc\u00ea modifique dados acidentalmente. A Palavra Reservada mut</p> <p>Mas e se voc\u00ea quiser que uma vari\u00e1vel seja mut\u00e1vel, ou seja, que possa ser alterada? \u00c9 a\u00ed que entra a palavra reservada mut. Quando voc\u00ea declara uma vari\u00e1vel com a palavra-chave mut, voc\u00ea est\u00e1 indicando explicitamente que a vari\u00e1vel pode ser modificada.</p> <p>Exemplo:</p> <pre><code>rust\n\nlet mut contador = 0;\ncontador = contador + 1; // Isso \u00e9 permitido, pois 'contador' \u00e9 mut\u00e1vel\n</code></pre> <p>Neste caso, contador \u00e9 uma vari\u00e1vel mut\u00e1vel, e voc\u00ea pode aumentar seu valor sem problemas. Constantes em Rust</p> <p>Al\u00e9m de vari\u00e1veis, Rust tamb\u00e9m oferece o conceito de constantes. As constantes s\u00e3o valores imut\u00e1veis que s\u00e3o definidos em tempo de compila\u00e7\u00e3o. Elas s\u00e3o declaradas usando a palavra-chave const e sempre devem ter um tipo de dado espec\u00edfico.</p> <p>Exemplo:</p> <pre><code>rust\n\nconst PI: f64 = 3.14159;\n</code></pre> <p>Aqui, PI \u00e9 uma constante que representa o valor de \u03c0 (pi) com uma precis\u00e3o de ponto flutuante de dupla precis\u00e3o (f64). Essa constante n\u00e3o pode ser alterada ap\u00f3s sua defini\u00e7\u00e3o e \u00e9 acess\u00edvel em todo o escopo em que est\u00e1 definida. Vantagens e Desvantagens da Imutabilidade por Padr\u00e3o</p> <p>A abordagem de imutabilidade por padr\u00e3o em Rust oferece algumas vantagens importantes: 1. Seguran\u00e7a:</p> <pre><code>Evita erros comuns relacionados \u00e0 muta\u00e7\u00e3o de dados, como condi\u00e7\u00f5es de corrida (race conditions) em programas concorrentes.\n\nFacilita a previsibilidade do c\u00f3digo, uma vez que voc\u00ea n\u00e3o precisa se preocupar com efeitos colaterais inesperados.\n</code></pre> <ol> <li> <p>Melhora a Legibilidade:</p> <p>Torna o c\u00f3digo mais f\u00e1cil de entender, uma vez que voc\u00ea sabe que uma vari\u00e1vel n\u00e3o ser\u00e1 alterada em lugares inesperados.</p> </li> <li> <p>Facilita a Concorr\u00eancia:</p> <p>Permite que Rust garanta a seguran\u00e7a na concorr\u00eancia, pois a imutabilidade reduz o risco de acesso concorrente a dados mut\u00e1veis.</p> </li> </ol> <p>No entanto, essa abordagem tamb\u00e9m pode ter desvantagens, como: 1. Mais Digita\u00e7\u00e3o:</p> <pre><code>Pode ser necess\u00e1rio digitar mais c\u00f3digo para criar vari\u00e1veis mut\u00e1veis quando necess\u00e1rio.\n</code></pre> <ol> <li> <p>Curva de Aprendizado:</p> <p>Pode levar algum tempo para se acostumar com a imutabilidade por padr\u00e3o, especialmente se voc\u00ea est\u00e1 familiarizado com linguagens que n\u00e3o a adotam.</p> </li> </ol> <p>Outras Linguagens com Caracter\u00edsticas Semelhantes</p> <p>Algumas outras linguagens de programa\u00e7\u00e3o tamb\u00e9m adotam a imutabilidade por padr\u00e3o ou oferecem suporte a vari\u00e1veis imut\u00e1veis:</p> <pre><code>Haskell\n\nElm\n\nClojure\n</code></pre> <p>Em resumo, vari\u00e1veis e constantes em Rust t\u00eam a caracter\u00edstica \u00fanica de serem imut\u00e1veis por padr\u00e3o, proporcionando seguran\u00e7a e legibilidade. A palavra-chave mut permite que voc\u00ea torne vari\u00e1veis mut\u00e1veis quando necess\u00e1rio, mantendo o controle sobre a mutabilidade dos dados em seu c\u00f3digo. Rust tamb\u00e9m suporta constantes, que s\u00e3o valores imut\u00e1veis definidos em tempo de compila\u00e7\u00e3o. Essa abordagem pode ser diferente de outras linguagens, mas traz benef\u00edcios significativos em termos de seguran\u00e7a e concorr\u00eancia.</p> <p>\u00c9 importante refor\u00e7ar que com isso voc\u00ea pode usar uma vari\u00e1vel imut\u00e1vel durante a maior parte da execu\u00e7\u00e3o e quando ela precisar ser alterada redeclarar ela como mut\u00e1vel mais a frente vamos falar do conceito de como funciona o gerenciamente de mem\u00f3ria do rust e isso vai acabar ficando mais claro.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#variaveis-e-mutabilidade","title":"Vari\u00e1veis e mutabilidade","text":"<p>Bom conforme vimos anteriormente nosso c\u00f3digo estava dando erro pois o rust acusava que estavamos tentando mudar uma vari\u00e1vel imut\u00e1vel. Isso acontece por que em rust todas as vari\u00e1veis por padr\u00e3o s\u00e3o imut\u00e1veis, ent\u00e3o n\u00e3o podemos modifica-la depois inicializar ela. Para isso vamos precisamos indicar pro rust que nossa vari\u00e1vel \u00e9 mut\u00e1vel usando a palavra reservada <code>mut</code> depois do <code>let</code>.</p> <pre><code>fn main() {\n    ==let mut pontuacao: i32 = 0;== \n    let escolha: i32 = 1;\n\n    // c\u00f3digo\n}\n\n</code></pre> <p>Agora voc\u00ea pode ver que seu editor deve parar de dar algum aviso de erro. Vamos tentar rodar nosso c\u00f3digo.</p> <pre><code>mysterious_forest on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.73.0 on \u2601\ufe0f  (eu-west-2) took 4m4s\n\u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 50\n\n</code></pre> <p>Certo agora nosso c\u00f3digo foi executado com sucesso mostrando que nossa pontua\u00e7\u00e3o foi 50.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#recebendo-parametros-do-jogador-e-usando-a-condicional-match","title":"Recebendo parametros do jogador e usando a condicional match","text":"<p>Bom nosso jogo est\u00e1 nos devolvendo a pontua\u00e7\u00e3o da nossa escolha, mas nosso jogador ainda n\u00e3o consegue nos passar a op\u00e7\u00e3o que ele quer, ent\u00e3o pra isso vamos precisar receber os dados do usu\u00e1rio isso quer dizer que precisamos pedir pro rust pedir o input do teclado do usu\u00e1rio. Pra isso vamos importar uma biblioteca que existe dentro do built in do rust ou seja uma biblioteca que ele j\u00e1 nos fornece por padr\u00e3o pra ser usada.</p> <p>Para importa-la precisamos usar a palavra reservada <code>use</code> chamar a biblioteca que queremos que no caso \u00e9 a <code>std</code> que \u00e1 biblioteca standard do rust, e no caso eu quero um m\u00f3dulo especifico da biblioteca e n\u00e3o ela toda pra chamar o m\u00f3dulo precisamos usar o simbolo <code>::</code> para indicar que vamos selecionar um m\u00f3dulo e escolhe-lo que no caso \u00e9 o m\u00f3dulo <code>io</code>.</p> <p>Nosso c\u00f3digo ficaria assim:</p> <pre><code>use std::io;\n</code></pre> <p>Agora vamos precisar criar uma vari\u00e1vel mutavel para receber a escolha do nosso usu\u00e1rio, no caso a escolha de um usu\u00e1rio sempre ser\u00e1 uma sequencia de caracteres no caso podemos incializa-la com uma <code>String</code> vazia conforme abaixo:</p> <pre><code>    //c\u00f3digo\n    println!(\"4 - Descansar na beira do riacho\");\n\n    ==let mut escolha_str: String = String::new();==\n\n    if escolha == 1 {\n    //c\u00f3digo\n</code></pre> <p>Aqui usamos o simbolo <code>::</code> para chamar um m\u00e9todo associado chamado <code>new</code> dentro da <code>Struct</code> chamada <code>String</code> que \u00e9 uma sequ\u00eancia de caracteres.</p> <p>Agora vamos usar o m\u00f3dulo <code>io</code> e chamar duas fun\u00e7\u00f5es a <code>stdin</code> e a <code>read_line</code>, nesse primeiro momento n\u00e3o precisa se preocupar muito com a chamada que vou fazer, mas atente-se que vou colocar como parametro de <code>read_line</code> nossa vari\u00e1vel <code>escolha_str</code> mais a frente vamos explicar com mais detalhes como funciona essa chamada que vamos fazer.</p> <pre><code>    // c\u00f3digo\n    let mut escolha_str: String = String::new();\n\n    ==io::stdin().read_line(&amp;mut escolha_str);==\n\n    if escolha == 1 {\n    // c\u00f3digo\n\n</code></pre> <p>Agora vamos fazer um <code>println!</code> para imprimir o que o usu\u00e1rio escolheu no meu caso vou escolha a op\u00e7\u00e3o <code>4</code>.</p> <pre><code>    // c\u00f3digo\n    io::stdin().read_line(&amp;mut escolha_str);\n\n    ==println!(\"Escolha str \u00e9 {}\", escolha_str);==\n\n    if escolha == 1 {\n    // c\u00f3digo\n</code></pre> <p>Com a sa\u00edda:</p> <pre><code>warning: `mysterious_forest` (bin \"mysterious_forest\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.13s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n5\nEscolha str \u00e9 4\n\nA sua escolha foi 1\nA sua pontua\u00e7\u00e3o foi 50\n</code></pre> <p>Atente-se que a escolha \u00e9 ainda 1 mas, a escolha str foi 4.</p> <p>Agora quero que meu escolha receba o valor de escolha_str, por\u00e9m o escolha_str \u00e9 uma <code>String</code> e o escolha \u00e9 um <code>i32</code>. Ent\u00e3o pra conseguir fazer o que quero vou mudar minha vari\u00e1vel escolha para <code>u32</code> para n\u00e3o receber n\u00famero negativos e vou converter minha <code>String</code> para isso preciso remover espa\u00e7os e quebras de linha e pra isso uso a fun\u00e7\u00e3o <code>trim</code> e depois chamo a fun\u00e7\u00e3o <code>parse</code> que vai tentar converter pro tipo da vari\u00e1vel que quero.</p> <p>\u00c9 importante ressalta que a fun\u00e7\u00e3o <code>parse</code> vai me voltar um <code>Rusult</code> que \u00e9 uma estrutura no formato abaixo:</p> <pre><code>    (OK, Err)\n</code></pre> <p>Onde <code>OK</code> vai ter o valor do parse caso de certo e em <code>Err</code> vai voltar o erro caso ocorra um erro. Essa estrutura nunca vai voltar os dois valores. Pois ele ou vai retornar um valor do tipo <code>OK</code> ou um valor do tipo <code>Err</code> assim n\u00e3o precisando ter recursos como o null de algumas linguagens.</p> <p>Ent\u00e3o vamos mover nosso escolha para abaixo de escolha_str e fazer o parse.</p> <pre><code>    println!(\"Escolha str \u00e9 {}\", escolha_str);\n    ==let escolha: i32 = escolha_str.trim().parse();==\n\n    if escolha == 1 {\n\n</code></pre> <p>No caso como o <code>parse</code> vai nos retornar ou <code>OK</code> ou <code>Err</code> eu quero que quando vier um erro nossa escolha receba o valor <code>0</code>. Poderiamos fazer isso com um <code>if</code> que nossa estrutura condicional que j\u00e1 conhecemos, mas, nesse momento quero lhe mostrar outra estrutura que no caso \u00e9 o <code>match</code>.</p> <pre><code>    //c\u00f3digo\n    println!(\"Escolha str \u00e9 {}\", escolha_str);\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n</code></pre> <p>Sua estrutura \u00e9:</p> <pre><code>    match &lt;condi\u00e7\u00e3o&gt; {\n        possivel retorno =&gt; retorno do c\u00f3digo,\n        possivel retorno 2 =&gt; retorno do c\u00f3digo,\n        ...\n        poss\u00edvel retorno n =&gt; retorno do c\u00f3digo\n    }\n</code></pre> <p>Outro ponto \u00e9 o simbolo <code>_</code> que \u00e9 um coringa o que quer dizer que n\u00e3o importa o valor que vir ele vai considerar ele um valor v\u00e1lido \u00e9 como uma condi\u00e7\u00e3o \"Se tudo que foi verificado antes n\u00e3o deu certo me use\". Tudo certo agora vamos rodar nosso c\u00f3digo.</p> <p>Agora nossa sa\u00edda fica assim:  <code>``bash warning:</code>mysterious_forest<code>(bin \"mysterious_forest\") generated 1 warning     Finished dev [unoptimized + debuginfo] target(s) in 0.14s      Running</code>target/debug/mysterious_forest` Bem-vindo \u00e0 floresta misteriosa Por favor escolha uma op\u00e7\u00e3o: 1 - Entrar na caverna escura 2 - Seguir no caminho iluminado 3 - Cruzar a ponte fr\u00e1gil 4 - Descansar na beira do riacho 4 Escolha str \u00e9 4</p> <p>A sua escolha foi 4 A sua pontua\u00e7\u00e3o foi 10</p> <pre><code>\n## Trabalhando com loop\n\nBom agora a primeira coisa que quero fazer \u00e9 parar de dar o warning na linha onde capturamos a entrada do jogador pra isso vamos fazer uma altera\u00e7\u00e3o no c\u00f3digo:\n\n```rust\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>H\u00e1 outras formas de resolver isso mas, nesse momento vamos fazer esse que \u00e9 o mais simples. Agora vamos fazer nossa condi\u00e7\u00e3o de vit\u00f3ria e derrota.</p> <p>// main.rs</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 0;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n    let mut escolha_str: String = String::new();\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n        pontuacao = pontuacao + 50;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n    ==\n    if pontuacao &gt;= 100 {\n        println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n    } else if pontuacao &lt;= 0 {\n        println!(\"Que pena voc\u00ea perdeu\");\n    }\n\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n    ==\n}\n\n</code></pre> <p>Aqui eu fiz um if verificando se a pontua\u00e7\u00e3o \u00e9 maior ou igual a 100 coloco um print parabenizando pela vit\u00f3ria ou se a pontua\u00e7\u00e3o for menor ou igual a zero informando a derrota. H\u00e1 tamb\u00e9m mais um print para informar o fim do jogo al\u00e9m de ter tirado nosso println! para escolha str.</p> <p>Agora podemos rodar nosso jogo e ver a condi\u00e7\u00e3o de derrota j\u00e1 que a de vit\u00f3ria ainda n\u00e3o vamos conseguir por conta da pontua\u00e7\u00e3o.</p> <pre><code>\u2726 \u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n3\nObrigado por jogar 'A floresta misteriosa!'\n\n</code></pre> <p>[!info] Condicionais</p> <p>Vale ressaltar que podemos usar <code>==</code> para verificar igualdades, <code>!=</code> para verificar &gt;diferen\u00e7as, <code>&lt;=</code> para verificar se \u00e9 menor ou igual, <code>&gt;=</code> para verificar se \u00e9 maior ou igual assim como <code>&lt;</code> e <code>&gt;</code> para verificar se \u00e9 menor e igual respectivamente. </p> <p>Agora vamos por 100 na ultima op\u00e7\u00e3o para conseguirmos testar nossa condi\u00e7\u00e3o de vit\u00f3ria.</p> <pre><code>    } else if escolha == 4 {\n        pontuacao = pontuacao + 100;\n    }\n\n</code></pre> <p>Agora podemos testar.</p> <pre><code>mysterious_forest on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.76.0 on \u2601\ufe0f   (eu-west-2) took 11s\n\u2726 \u279c cargo run\n   Compiling mysterious_forest v0.1.0 (/home/feanor/projects/mysterious_forest)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.12s\n     Running `target/debug/mysterious_forest`\nBem-vindo \u00e0 floresta misteriosa\nPor favor escolha uma op\u00e7\u00e3o:\n1 - Entrar na caverna escura\n2 - Seguir no caminho iluminado\n3 - Cruzar a ponte fr\u00e1gil\n4 - Descansar na beira do riacho\n4\nParab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\nObrigado por jogar 'A floresta misteriosa!'\n\n</code></pre> <p>Certo agora temos nossa condi\u00e7\u00e3o de vit\u00f3ria e derrota funcionando, mas basicamente nosso jogo por enquanto s\u00f3 podemos escolher uma op\u00e7\u00e3o e o jogo acaba. Ent\u00e3o precisamos de uma forma de pode escolher repetidas vezes.  Primeiro vamos ajustar nossa pontua\u00e7\u00e3o inicial e o ganho e perda da pontua\u00e7\u00e3o do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 50;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n    println!(\"1 - Entrar na caverna escura\");\n    println!(\"2 - Seguir no caminho iluminado\");\n    println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n    println!(\"4 - Descansar na beira do riacho\");\n\n    let mut escolha_str: String = String::new();\n\n    let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n    let escolha: i32 = match escolha_str.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; 0,\n    };\n\n    if escolha == 1 {\n        pontuacao = pontuacao + 30;\n    } else if escolha == 2 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 3 {\n        pontuacao = pontuacao - 20;\n    } else if escolha == 4 {\n        pontuacao = pontuacao + 10;\n    }\n\n    if pontuacao &gt;= 100 {\n        println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n    } else if pontuacao &lt;= 0 {\n        println!(\"Que pena voc\u00ea perdeu\");\n    }\n\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n}\n\n</code></pre> <p>Agora n\u00e3o conseguimos chegar nem a 100 e nem a 0 na primeira escolha, agora precisamos de algo que ajude nosso jogo a se repetir para isso vamos usar uma estrutura chamada <code>loop</code>.</p> <pre><code>use std::io;\n\nfn main() {\n    let mut pontuacao: i32 = 50;\n\n    println!(\"Bem-vindo \u00e0 floresta misteriosa\");\n\n    ==loop \n        println!(\"Por favor escolha uma op\u00e7\u00e3o:\");\n        println!(\"1 - Entrar na caverna escura\");\n        println!(\"2 - Seguir no caminho iluminado\");\n        println!(\"3 - Cruzar a ponte fr\u00e1gil\");\n        println!(\"4 - Descansar na beira do riacho\");\n\n        let mut escolha_str: String = String::new();\n\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        let escolha: i32 = match escolha_str.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; 0,\n        };\n\n        if escolha == 1 {\n            pontuacao = pontuacao + 30;\n        } else if escolha == 2 {\n            pontuacao = pontuacao - 20;\n        } else if escolha == 3 {\n            pontuacao = pontuacao - 20;\n        } else if escolha == 4 {\n            pontuacao = pontuacao + 10;\n        }\n\n        if pontuacao &gt;= 100 {\n            println!(\"Parab\u00e9ns voc\u00ea \u00e9 um verdadeiro aventureiro!\");\n            ==break;==\n        } else if pontuacao &lt;= 0 {\n            println!(\"Que pena voc\u00ea perdeu\");\n            ==break;==\n        }\n    ==\n    println!(\"Obrigado por jogar 'A floresta misteriosa!'\")\n}\n</code></pre> <p>No c\u00f3digo acima envolvelmos a l\u00f3gica do nosso jogo dentro do <code>loop</code> com o bloco de c\u00f3digo <code>{}</code> evitando as mensagens de vit\u00f3ria e derrota. Se deixarmos s\u00f3 o <code>loop</code> nosso c\u00f3digo iria rodar infinitamente, ent\u00e3o precisamos definir uam condi\u00e7\u00e3o para ele parar e no nosso caso podemos usar nossa condi\u00e7\u00e3o de vit\u00f3ria/derrota, para isso depois da mensagens usamos a palavra reservada <code>break</code>.</p> <p>Agora se rodarmos nosso jogo com <code>cargo run</code> nosso jogo j\u00e1 est\u00e1 funcionando perfeitamente.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#alguns-ajustes","title":"Alguns ajustes","text":"<p>Vamos fazer algumas melhorias no c\u00f3digo, primeiro vou simplicicar a soma e subtra\u00e7\u00e3o da nossa pontua\u00e7\u00e3o usando a express\u00e3o <code>+=</code> e <code>-=</code>.</p> <pre><code>        if escolha == 1 {\n            pontuacao += 30;\n        } else if escolha == 2 {\n            pontuacao -= 20;\n        } else if escolha == 3 {\n            pontuacao += 20;\n        } else if escolha == 4 {\n            pontuacao += 10;\n        }\n\n</code></pre> <p>Agora vamos por alguma mensagem de feedback pro jogador saber se ele est\u00e1 fazendo uma a\u00e7\u00e3o correta ou n\u00e3o.</p> <pre><code>        if escolha == 1 {\n            ==println!(\"Voc\u00ea entrou na caverna escura e econtrou um tesouro parab\u00e9ns!\");==\n            pontuacao += 30;\n        } else if escolha == 2 {\n            ==println!(\"Voc\u00ea encontrou um Ogro poderoso, mas com sorte conseguiu escapar!\");==\n            pontuacao -= 20;\n        } else if escolha == 3 {\n            ==println!(\"A ponte se quebrou com sorte voc\u00ea conseguiu nadar de volta para a margem!\");==\n            pontuacao += 20;\n        } else if escolha == 4 {\n            ==println!(\"Voc\u00ea conseguiu recuperar um pouco das suas for\u00e7as!\");==\n            pontuacao += 10;\n        }\n\n</code></pre> <p>Agora se rodarmos o feedback ficou muito mais f\u00e1cil pro jogador.</p> <p>Como desafio tente colocar uma op\u00e7\u00e3o de jogar novamente o jogo com a op\u00e7\u00e3o S/N.</p> <p>Com isso finalizamos nosso primeiro jogo em Rust, agora voc\u00ea pode tentar fazer os desafios abaixo.</p>"},{"location":"1_1_jogo_floresta_misteriosa/#exercicios-sugeridos","title":"Exercic\u00edos sugeridos","text":"<p>Aqui vou colocar os projetos para voc\u00ea fazer suas revis\u00f5es, muitas vezes os desafios poder\u00e3o n\u00e3o ser jogos infelizmente, mas estarei dispon\u00edvel no forum ou no Revolt para tirar d\u00favidas.</p> <p>Revis\u00e3o 1</p> <ul> <li>Crie um programa em Rust que simule o controle de estoque de uma loja, fa\u00e7a simples s\u00f3 com um unico produto utilizando vari\u00e1veis para armazenar a quantidade do produto e permitindo a atualiza\u00e7\u00e3o dos valores de estoque de forma mut\u00e1vel.</li> </ul> <p>Revis\u00e3o 2</p> <ul> <li>Desenvolva um programa que calcule o fatorial de um n\u00famero inserido pelo usu\u00e1rio. Utilize uma vari\u00e1vel mut\u00e1vel para armazenar o resultado parcial do c\u00e1lculo.</li> </ul> <p>Revis\u00e3o 3</p> <ul> <li>Crie um programa que simule uma calculadora simples em Rust, permitindo que o usu\u00e1rio realize opera\u00e7\u00f5es de adi\u00e7\u00e3o, subtra\u00e7\u00e3o, multiplica\u00e7\u00e3o e divis\u00e3o. Utilize vari\u00e1veis mut\u00e1veis para armazenar os valores inseridos pelo usu\u00e1rio e o resultado das opera\u00e7\u00f5es.</li> </ul> <p>Revis\u00e3o 4 - Implemente um programa em Rust que converta temperaturas entre Celsius e Fahrenheit. Utilize vari\u00e1veis mut\u00e1veis para armazenar os valores e permitir que o usu\u00e1rio escolha a convers\u00e3o desejada.</p>"},{"location":"1_2_jogo_da_adivinhacao/","title":"Jogo da adivinha\u00e7\u00e3o","text":"<p>Vamos come\u00e7ar um novo jogo que \u00e9 o jogo da adivinha\u00e7\u00e3o \"Guessing Game\" o objetivo desse jogo \u00e9 identificar um n\u00famero escolhido aleat\u00f3riamente. O jogo inicia com 1000 pontos para o jogador e cada vez que ele erra o n\u00famero \u00e9 subtraido 100 pontos do placar dele quando o placar chegar a zero o jogo \u00e9 encerrado.</p>"},{"location":"1_2_jogo_da_adivinhacao/#regras","title":"Regras","text":"<p>As regras s\u00e3o as seguintes: - Ao iniciar o jogo o jogador tem a escolha de come\u00e7ar o jogo ou sair do jogo - O jogador vai escolher um n\u00famero entre 0 a 100 - Caso o jogador escolha um n\u00famero fora desse intervalo ser\u00e1 solicitado para ele escolher novamente - Caso o jogador escolha uma letra ou um caractere especial tamb\u00e9m ser\u00e1 solicitado para escolher o novamente - Caso o jogador escolha um n\u00famero menor que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi menor - Caso o jogador escolha um n\u00famero maior que o n\u00famero escolhido pelo jogo o jogo deve informar que o n\u00famero escolhido foi maior - Casa escolha que n\u00e3o seja o n\u00famero escolhido pelo jogo dever\u00e1 marcar um contador de erro - O jogador come\u00e7a com 1000 pontos caso aconte\u00e7a um erro cada contador de erro deve subtrair 100 pontos - Caso o jogador perca o jogo dever\u00e1 ter um menu informando pra fechar o jogo ou jogar novamente - Caso o jogador ven\u00e7a dever\u00e1 mostrar o placar que ele obteve o a op\u00e7\u00e3o de sair do jogo ou tentar novamente.</p>"},{"location":"1_2_jogo_da_adivinhacao/#comecando-o-projeto","title":"Come\u00e7ando o projeto","text":"<p>Vamos iniciar um novo projeto em nossa pasta projects</p> <pre><code>cd ~/projects\ncargo new guessing_game\n</code></pre> <p>Agora para iniciar o nosso jogo vamos fazer o loop que j\u00e1 conhecemos e vamos criar o menu recebendo o input do usu\u00e1rio e imprimir na tela o valor escolhido e caso ele escolha iniciar vamos imprimir que o jogo come\u00e7ou e caso ele sair n\u00f3s vamos encerrar o jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        println!(\"A sua escolha foi {}\", escolha_str);\n        break;\n    }\n\n}\n</code></pre> <p>Aqui vamos mudar ao inv\u00e9s de usar n\u00fameros para op\u00e7\u00f5es vamos usar letras pois vamos precisar fazer um tratamento especial no c\u00f3digo, estamos usando a captura que estavamos fazendo anteriormente fazendo um println apenas no item escolhido, no final vamos dar um break apenas pra encerrar o loop. Agora se rodarmos o c\u00f3digo vamos ver que ele pegou a escolha que gostariamos e printou na tela.</p> <pre><code>cargo run\n</code></pre> <p>Certo agora vamos fazer um match com nossa escolha str s\u00f3 que como estamos usando letras vou for\u00e7ar que o que venha de letras senha minuscula ou maiuscula que ele force sempre a ser min\u00fasculo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n        };\n==\n\n    }\n}\n</code></pre> <p>Criamos a nossa linha como <code>match escolha.str.trim().to_lowercase()</code> usando a fun\u00e7\u00e3o <code>trim()</code> para removermos espa\u00e7os em branco e agora usamos uma nova fun\u00e7\u00e3o chamada <code>to_lowercase()</code> que vai transformar nossa string caso tenha letras maiusculas em min\u00fasculas. Outra fun\u00e7\u00e3o que usamos foi o <code>as_str</code> pois quando usamos o <code>trim</code> e o <code>to_lowercase</code> eles voltam uma String que \u00e9 um tipo diferente do str, e nesse caso vamos comparar com \"i\" e \"q\" e quando passamos esses valores com aspas eles s\u00e3o do tipo str ent\u00e3o pra comparar vamos precisar reconverter novamente para str e ai usamos o <code>as_str</code>.</p> <p>Assim conseguimos agora colocar a compara\u00e7\u00e3o com a string \"i\" e a string \"q\".</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n==\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                println!(\"Iniciar Jogo\");\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n==\n\n    }\n}\n</code></pre> <p>Aqui colocamos o \"i\" para imprimir e usamos o <code>continue</code> para voltar ao inicio do loop. No caso o jogador use \"q\" o programa vai ser encerrado. Tamb\u00e9m usamos o coringa \"_\" caso seja dada outra op\u00e7\u00e3o que n\u00e3o seja \"i\" ou \"q\" n\u00f3s colocamos a mensagem de erro e reiniciamos o loop.</p> <p>Agora podemos testar e verificar se nossa fun\u00e7\u00e3o est\u00e1 correta.</p>"},{"location":"1_2_jogo_da_adivinhacao/#seguranca-de-memoria","title":"Seguran\u00e7a de Mem\u00f3ria","text":"<p>Rust fornece uma s\u00e9rie de garantias de seguran\u00e7a de mem\u00f3ria durante o tempo de compila\u00e7\u00e3o. Essas garantias s\u00e3o fundamentais para evitar erros comuns, como vazamentos de mem\u00f3ria, refer\u00eancias nulas e acessos inv\u00e1lidos.</p> <ul> <li>Sem Refer\u00eancias Nulas: Rust garante que as refer\u00eancias n\u00e3o sejam nulas, eliminando muitos erros de acesso nulo.</li> <li>Sem Vazamentos de Mem\u00f3ria: Rust controla rigorosamente o ciclo de vida dos recursos, o que impede vazamentos de mem\u00f3ria.</li> <li>Sem Concorr\u00eancia de Dados Mut\u00e1veis: Rust imp\u00f5e regras rigorosas para evitar a concorr\u00eancia de dados mut\u00e1veis, garantindo a seguran\u00e7a em threads.</li> </ul> <p>Exitem 3 locais de mem\u00f3ria que trabalhamos com rust que \u00e9 a mem\u00f3ria est\u00e1tica, stack e heap.</p> <p></p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-estatica","title":"Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 onde fica o bin\u00e1rio do nosso programa, vari\u00e1veis est\u00e1ticas, strings literais. N\u00f3s conhecemos ela em tempo de compila\u00e7\u00e3o pois o rust vai reservar a mem\u00f3ria necess\u00e1ria para acomodar os recursos criados aqui. Ela possui um tamanho fixo e essa mem\u00f3ria existe durante o tempo de aloca\u00e7\u00e3o do programa e \u00e9 liberada assim que o programa \u00e9 encerrado e a forma mais r\u00e1pida de acessar um recurso.</p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-stack","title":"Mem\u00f3ria Stack","text":"<p>A mem\u00f3ria stack armazena argumentos de fun\u00e7\u00f5es e variaveis locais ou seja recursos dentro de um bloco de fun\u00e7\u00e3o quando trabalhamos com v\u00e1rias threads cada thread vai ter uma stack especifica e ele \u00e9 conhecido em tempo de compila\u00e7\u00e3o por\u00e9m ele tem um tamanho din\u00e2mico dentro de um limite especifico, quando esse limite \u00e9 estourado recebemos o famoso erro stack overflow. Como \u00e9 uma mem\u00f3ria din\u00e2mica o gatilho pra liberar a mem\u00f3ria \u00e9 quando uma fun\u00e7\u00e3o \u00e9 encerrada.</p>"},{"location":"1_2_jogo_da_adivinhacao/#memoria-heap","title":"Mem\u00f3ria Heap","text":"<p>A mem\u00f3ria heap \u00e9 um tipo de mem\u00f3ria onde armazenamos valores din\u00e2micos ou seja que durante a execu\u00e7\u00e3o de um programa pode variar, por exemplo num jogo onde recebemos o nome do jogador n\u00f3s n\u00e3o vamos saber previamente o tamanho do nome do mesmo ent\u00e3o ele ser\u00e1 armazenado na mem\u00f3ria heap. Ele \u00e9 usado sempre que tivermos vari\u00e1veis que s\u00e3o muito grandes ou qual eu n\u00e3o conhe\u00e7a o valor previamente. Quanto trabalhamos com threads esse valor \u00e9 compartilhado e n\u00e3o sabemos em tempo de compila\u00e7\u00e3o onde o valor dispon\u00edvel normalmente \u00e9 fornecido pelo sistema operacional. O tempo de vida dessas vari\u00e1veis ser\u00e3o determinados pelo programador ou pela linguagem usada e no caso do Rust ela \u00e9 liberada usando RAII.</p>"},{"location":"1_2_jogo_da_adivinhacao/#o-que-e-raii","title":"O que \u00e9 RAII?","text":"<p>RAII significa \"Resource Acquisition Is Initialization\". \u00c9 um princ\u00edpio de programa\u00e7\u00e3o utilizado em linguagens como C++ e Rust. A ideia principal por tr\u00e1s do RAII \u00e9 associar a aquisi\u00e7\u00e3o de recursos \u00e0 inicializa\u00e7\u00e3o de objetos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#diferenca-entre-str-e-string","title":"Diferen\u00e7a entre &amp;str e String","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o moderna que coloca um forte foco na seguran\u00e7a e no gerenciamento de mem\u00f3ria, permitindo aos desenvolvedores escrever c\u00f3digo seguro e eficiente. Duas estruturas de dados muito importantes em Rust s\u00e3o &amp;str e String. Embora ambas sejam usadas para representar texto, elas t\u00eam diferen\u00e7as fundamentais em termos de propriedades e uso. Vamos explorar as distin\u00e7\u00f5es entre &amp;str e String em Rust.</p> <p>&amp;str - Refer\u00eancia para uma Sequ\u00eancia de Caracteres</p> <p>\u00c9 importante refor\u00e7ar que caratere representa um simbolo em Rust e ele \u00e9 um tipo primitivo que acabamos n\u00e3o vendo ainda, o tipo str \u00e9 uma sequ\u00eancia de caracteres que \u00e9 o tipo primitivo. &amp;str \u00e9 uma fatia (slice) que representa uma sequ\u00eancia de caracteres em Rust. Essa fatia \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres armazenada em outro local da mem\u00f3ria. Aqui est\u00e3o algumas caracter\u00edsticas importantes do &amp;str:</p> <pre><code>Imut\u00e1vel: O &amp;str \u00e9 imut\u00e1vel, o que significa que voc\u00ea n\u00e3o pode modificar o conte\u00fado da sequ\u00eancia de caracteres a que ele faz refer\u00eancia.\n\nAloca\u00e7\u00e3o Zero: O &amp;str em si n\u00e3o aloca mem\u00f3ria para a sequ\u00eancia de caracteres. Ele simplesmente aponta para uma sequ\u00eancia existente.\n\nView (Vis\u00e3o): O &amp;str \u00e9 uma vis\u00e3o de uma sequ\u00eancia de caracteres (tipo primitivo). Pode ser usado para referenciar substrings de uma String ou literais de string.\n\nLifetime: O &amp;str \u00e9 um tipo est\u00e1tico ou seja ele vai alocar a mem\u00f3ria quando o programa \u00e9 compilado e vai existir durante todo o tempo em que o programa for executado.\n</code></pre> <p>Aqui est\u00e1 um exemplo de &amp;str:</p> <pre><code>fn main() {\n    let texto: &amp;str = \"Ol\u00e1, Mundo!\";\n    println!(\"{}\", texto);\n}\n\n</code></pre> <p>String - Propriedade de uma Sequ\u00eancia de Caracteres</p> <p>String \u00e9 uma estrutura de dados que representa uma sequ\u00eancia de caracteres alocada dinamicamente em Rust. Aqui est\u00e3o algumas caracter\u00edsticas importantes da String:</p> <pre><code>Mut\u00e1vel: A String \u00e9 mut\u00e1vel, o que significa que voc\u00ea pode modificar seu conte\u00fado, adicionando ou removendo caracteres.\n\nAloca\u00e7\u00e3o Din\u00e2mica: A String aloca mem\u00f3ria dinamicamente para armazenar a sequ\u00eancia de caracteres. Isso permite que voc\u00ea ajuste o tamanho conforme necess\u00e1rio.\n\nPropriet\u00e1ria: A String \u00e9 propriet\u00e1ria, o que significa que \u00e9 respons\u00e1vel por gerenciar a mem\u00f3ria da sequ\u00eancia de caracteres que ela cont\u00e9m.\n\nConvers\u00e3o: Voc\u00ea pode converter um &amp;str em uma String usando a fun\u00e7\u00e3o to_string(), ou usar a fun\u00e7\u00e3o String::from().\n</code></pre> <p>Aqui est\u00e1 um exemplo de String:</p> <pre><code>fn main() {\n    let mut texto: String = String::from(\"Ol\u00e1, \");\n    texto.push_str(\"Mundo!\");\n    println!(\"{}\", texto);\n}\n</code></pre> <p>Quando Usar &amp;str e String</p> <p>A escolha entre &amp;str e String depende do contexto e dos requisitos do seu programa:</p> <pre><code>Use &amp;str quando precisar de uma refer\u00eancia imut\u00e1vel a uma sequ\u00eancia de caracteres existente. Por exemplo, ao passar argumentos de fun\u00e7\u00e3o ou realizar opera\u00e7\u00f5es de leitura em uma sequ\u00eancia.\n\nUse String quando precisar de uma sequ\u00eancia de caracteres mut\u00e1vel que pode ser modificada. Por exemplo, para construir uma sequ\u00eancia de caracteres dinamicamente.\n\nLembre-se de que &amp;str e String s\u00e3o intercambi\u00e1veis por meio de convers\u00f5es quando necess\u00e1rio.\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#alocacao-de-memoria-em-rust","title":"Aloca\u00e7\u00e3o de mem\u00f3ria em Rust","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o conhecida por seu controle rigoroso sobre a mem\u00f3ria. Ela oferece diversos tipos de mem\u00f3ria com comportamentos distintos, o que \u00e9 fundamental para garantir a seguran\u00e7a e o desempenho dos programas. Vamos explorar os principais tipos de mem\u00f3ria em Rust e como eles se comportam.</p>"},{"location":"1_2_jogo_da_adivinhacao/#1-stack-pilha","title":"1. Stack (Pilha)","text":"<p>A pilha, ou stack, \u00e9 um local de armazenamento de mem\u00f3ria de curto prazo e \u00e9 usada para alocar vari\u00e1veis locais e controlar a execu\u00e7\u00e3o do programa. Aqui est\u00e3o algumas caracter\u00edsticas da pilha:</p> <ul> <li>Alcance Limitado: As vari\u00e1veis alocadas na pilha t\u00eam um tempo de vida limitado e s\u00e3o desalocadas automaticamente quando saem do escopo.</li> <li>Aloca\u00e7\u00e3o R\u00e1pida: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria na pilha \u00e9 r\u00e1pida, pois segue uma ordem rigorosa de LIFO (\u00faltimo a entrar, primeiro a sair).</li> <li>Tamanho Conhecido em Tempo de Compila\u00e7\u00e3o: O tamanho das vari\u00e1veis alocadas na pilha deve ser conhecido em tempo de compila\u00e7\u00e3o.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o na pilha:</p> <pre><code>fn main() {\n    let x = 42; // Vari\u00e1vel \"x\" alocada na pilha\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#2-heap","title":"2. Heap","text":"<p>O heap \u00e9 um local de armazenamento de mem\u00f3ria de longo prazo, usado para alocar dados cujo tamanho n\u00e3o \u00e9 conhecido em tempo de compila\u00e7\u00e3o e/ou que precisam de tempo de vida mais longo. Aqui est\u00e3o algumas caracter\u00edsticas do heap:</p> <ul> <li>Alcance Mais Amplo: Os dados alocados no heap podem ter um tempo de vida mais longo e persistir al\u00e9m do escopo atual.</li> <li>Aloca\u00e7\u00e3o e Libera\u00e7\u00e3o Controladas: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria no heap s\u00e3o controladas manualmente pelo programador, usando fun\u00e7\u00f5es como Box::new, Vec::new, etc.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o no heap:</p> <pre><code>fn main() {\n    let x = Box::new(42); // Vari\u00e1vel \"x\" alocada no heap\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#3-memoria-estatica","title":"3. Mem\u00f3ria Est\u00e1tica","text":"<p>A mem\u00f3ria est\u00e1tica \u00e9 usada para armazenar dados que t\u00eam um tempo de vida durante toda a execu\u00e7\u00e3o do programa. Ela \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada durante a execu\u00e7\u00e3o.</p> <ul> <li>Tempo de Vida Global: Os dados est\u00e1ticos t\u00eam um tempo de vida global e existem durante toda a execu\u00e7\u00e3o do programa.</li> <li>Aloca\u00e7\u00e3o em Tempo de Compila\u00e7\u00e3o: A mem\u00f3ria est\u00e1tica \u00e9 alocada em tempo de compila\u00e7\u00e3o e n\u00e3o pode ser liberada ou realocada.</li> </ul> <p>Exemplo de aloca\u00e7\u00e3o de mem\u00f3ria est\u00e1tica:</p> <pre><code>static HELLO: &amp;str = \"Hello, World!\";\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#4-string-vs-str","title":"4. String vs &amp;str","text":"<p>Rust distingue entre String e &amp;str. String \u00e9 uma sequ\u00eancia de caracteres alocada no heap, que permite modifica\u00e7\u00f5es. &amp;str \u00e9 uma refer\u00eancia a uma sequ\u00eancia de caracteres (geralmente String ou literal de string) e \u00e9 imut\u00e1vel.</p> <ul> <li>Use String quando precisar de uma sequ\u00eancia de caracteres que pode ser modificada.</li> <li>Use &amp;str para referenciar sequ\u00eancias de caracteres imut\u00e1veis.</li> </ul> <pre><code>fn main() {\n    let s1: String = String::from(\"Hello\");\n    let s2: &amp;str = \"World\";\n}\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#criando-a-funcao-do-jogo","title":"Criando a fun\u00e7\u00e3o do jogo","text":"<p>Agora vamos criar uma fun\u00e7\u00e3o onde vamos manter nossa l\u00f3gica do jogo para isso vamos usar a palavra reservada fn</p> <pre><code>fn game() -&gt; () {\n    println!(\"Iniciar Jogo\");\n}\n</code></pre> <p>Com isso movemos nosso print iniciar jogo para dentro da fun\u00e7\u00e3o e vamos ver que vai continuar funcionando vale notar que na fun\u00e7\u00e3o n\u00f3s anotamos <code>()</code> que quer dizer que a fun\u00e7\u00e3o vai retornar uma Option vazia ou seja se for OK v\u00e3o vai ter valor algum isso faz a fun\u00e7\u00e3o main que chama a fun\u00e7\u00e3o game saber que essa fun\u00e7\u00e3o n\u00e3o tem retorno se n\u00f3s tentarmos receber algum valor de game n\u00f3s vamos receber a Option por\u00e9m ela vai ver sem nenhum valor, com isso n\u00f3s nunca vamos receber um valor Nulo no m\u00e1ximo um Option com um Ok por\u00e9m n\u00e3o existe um valor empty ou None isso \u00e9 uma caracteristica do rust para trabalhar sem usar valores nulos. Agora quero que nosso jogo defina o n\u00famero secreto, nesse momento vamos definir um n\u00famero fixo, mais a frente vamos fazer esse n\u00famero ser aleat\u00f3rio, tamb\u00e9m vamos receber a pontua\u00e7\u00e3o do jogador e vamos j\u00e1 contar um erro e o fim do jogo.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                ==\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(pontuacao=_pontuacao, numero=_numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game(pontuacao: u16, numero: u8) -&gt; () {\n    println!(\"Iniciar Jogo\");\n    ==\n    pontuacao = pontuacao - 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n    ==\n}\n</code></pre> <p>Se tentarmos compilar vamos receber o erro abaixo:</p> <pre><code>\u276e cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0384]: cannot assign to immutable argument `pontuacao`\n  --&gt; src/main.rs:35:5\n   |\n33 | fn game(pontuacao: u16, numero: u8) -&gt; () {\n   |         --------- help: consider making this binding mutable: `mut pontuacao`\n34 |     println!(\"Iniciar Jogo\");\n35 |     pontuacao = pontuacao - 100;\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to previous error\n</code></pre> <p>Essa mensagem diz que pontua\u00e7\u00e3o dentro de game \u00e9 um atributo imut\u00e1vel ent\u00e3o precisamos deixar nosso parametro mut\u00e1vel. ent\u00e3o simplesmente vamos usar um mut no cabe\u00e7alho da fun\u00e7\u00e3o game.</p> <pre><code>fn game(mut pontuacao: u16, numero: u8) -&gt; () {\n...\n</code></pre> <p>Agora se rodarmos vai voltar o resultado que gostariamos.</p> <pre><code>Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\n...\n</code></pre> <p>Agora vamos mudar um pouco queremos que nosso print do resultado tamb\u00e9m seja impresso depois que o loop do game acabar ent\u00e3o vamos copia-lo pra fora da fun\u00e7\u00e3o.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                game(_pontuacao, _numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                ==\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n</code></pre> <p>Agora vamos receber essa saida</p> <pre><code>\u279c cargo run\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.09s\n     Running `target/debug/guessing_game`\nBem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\ni - Iniciar o jogo\nq - Fechar o jogo\ni\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n</code></pre> <p>O que aconteceu? Acontece que do jeito que est\u00e1 a fun\u00e7\u00e3o game est\u00e1 recebendo uma c\u00f3pia dos valores de _pontuacao e _numero_alvo ou seja o valor reduzido de 900 s\u00f3 existe dentro da fun\u00e7\u00e3o game quando a fun\u00e7\u00e3o termina o rust limpa as vari\u00e1veis do escopo de game poderiamos facilmente resolver isso fazendo com que game retorne o valor de 900 para nossa vari\u00e1vel _pontuacao mas, podemos resolver isso sem precisar duplicar os valores dentro da fun\u00e7\u00e3o passando a refer\u00eancia delas atrav\u00e9s de Borrowing que \u00e9 o que vamos discutir a seguinte.</p>"},{"location":"1_2_jogo_da_adivinhacao/#ownership-e-borrowing","title":"Ownership e Borrowing","text":"<p>Rust introduz o conceito de \"ownership\" (propriedade) e \"borrowing\" (empr\u00e9stimo) para gerenciar a mem\u00f3ria de forma segura. Isso implica que, em Rust, voc\u00ea precisa seguir regras rigorosas para acessar e modificar a mem\u00f3ria. A ideia principal \u00e9 que um recurso s\u00f3 pode ser possu\u00eddo por uma \u00fanica parte do c\u00f3digo em um determinado momento.</p> <ul> <li>Propriedade (Ownership): Uma vari\u00e1vel \u00e9 a \"dona\" de um recurso e \u00e9 respons\u00e1vel por liber\u00e1-lo quando n\u00e3o for mais necess\u00e1rio.</li> <li>Empr\u00e9stimo (Borrowing): Outras partes do c\u00f3digo podem \"emprestar\" acesso \u00e0 vari\u00e1vel, mas n\u00e3o podem modificar a propriedade.</li> </ul> <p>Assim sendo no nosso caso particular podemos pedir pro rust nos dar as refer\u00eancias das vari\u00e1veis _pontuacao e _numero_alvo assim sendo ele n\u00e3o cria uma nova vari\u00e1vel <code>numero</code> e <code>pontuacao</code> ele vai simplesmente pegar a referencia onde est\u00e1 armazenado os valores de _pontuacao e _numero_alvo e come\u00e7ar a apontar para os parametros que existem na fun\u00e7\u00e3o assim quando a fun\u00e7\u00e3o terminar ela vai devolver as refer\u00eancias para os parametros originais.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                let mut _pontuacao: u16 = 1000;\n                let _numero_alvo: u8 = 42;\n                ==\n                game(&amp;mut _pontuacao, &amp;_numero_alvo);\n                ==\n                println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", _pontuacao, _numero_alvo);\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\n==\nfn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n==\n    println!(\"Iniciar Jogo\");\n    ==\n    *pontuacao -= 100;\n    ==\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Aqui fizemos algumas altera\u00e7\u00f5es a primeira \u00e9 que passamos na vari\u00e1vel o simbolo \"&amp;\" que indica que estamos emprestando a refer\u00eancia para a fun\u00e7\u00e3o ou seja ela vai ser tempor\u00e1riamente a dona dos parametros passados e no caso de pontua\u00e7\u00e3o n\u00f3s passamos como &amp;mut que quer dizer que ela pode ser modificada, caso fosse passado apenas om o &amp; comercial a fun\u00e7\u00e3o game s\u00f3 teria a permiss\u00e3o de ler o parametro e n\u00e3o modificalo.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n</code></pre> <p>No cabe\u00e7alho da fun\u00e7\u00e3o mudamos tamb\u00e9m indicando que pontua\u00e7\u00e3o \u00e9 a referencia mutavel de um u16 e a referencia de u8 assim na compila\u00e7\u00e3o ele sabe que a fun\u00e7\u00e3o est\u00e1 trabalhando com refer\u00eancias e n\u00e3o vai criar uma c\u00f3pia da fun\u00e7\u00e3o.</p> <p>Por ultimo vamos fazer uma altera\u00e7\u00e3o na nossa opera\u00e7\u00e3o de subtra\u00e7\u00e3o</p> <pre><code>    *pontuacao -= 100;\n</code></pre> <p>Usamos o simbilo \"*\" para indicar que n\u00e3o queremos mexer na refer\u00eancia onde est\u00e1 pontuacao mas, no valor que ele possui assim o valor que estava em _pontuacao mudou de 1000 para 900.</p> <p>Agora com isso conseguimos compreender as linhas onde capturamos a entrada do teclado do jogador</p> <pre><code>        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n</code></pre> <p>Onde criamos uma vari\u00e1vel escolha_str que \u00e9 uma String vazia e mut\u00e1vel e quando chamamos a fun\u00e7\u00e3o read_line n\u00f3s passamos a refer\u00eancia mut\u00e1vel de escolha_str e enquanto ela est\u00e1 em execu\u00e7\u00e3o ela est\u00e1 alterando o valor do <code>escolha_str</code> para n\u00f3s e quando termina conseguimos usar o valor de escolha_str com os valores modificados pela fun\u00e7\u00e3o <code>read_line</code> sem precisar duplicar a vari\u00e1vel dentro da fun\u00e7\u00e3o.  \u00c9 importante refor\u00e7ar que em muitas linguagens n\u00e3o conseguimos fazer isso n\u00f3s normalmente precisamos receber a copia modificada dentro da fun\u00e7\u00e3o para conseguir trabalhar. Essa caracter\u00edstica do rust \u00e9 muito importante para casos que trabalhamos com pouca mem\u00f3ria ou mesmo um jogo onde quanto menos recursos usarmos mais leve ser\u00e1 nosso jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introducao-sobre-testes-de-software","title":"Introdu\u00e7\u00e3o sobre testes de software","text":"<p>A programa\u00e7\u00e3o \u00e9 uma tarefa complexa que envolve a cria\u00e7\u00e3o de software que seja confi\u00e1vel, eficiente e livre de erros. \u00c0 medida que os projetos de desenvolvimento de software crescem em complexidade, torna-se cada vez mais cr\u00edtico garantir a qualidade do c\u00f3digo. Uma das abordagens mais eficazes para assegurar a qualidade do software \u00e9 a pr\u00e1tica de testes, especialmente o Desenvolvimento Orientado a Testes (TDD).</p> <p>Ent\u00e3o vamos agora explorar sobre a import\u00e2ncia dos testes na programa\u00e7\u00e3o e como o TDD pode ser uma ferramenta valiosa para alcan\u00e7ar um c\u00f3digo mais robusto e confi\u00e1vel. Vamos mergulhar no mundo dos testes e entender por que eles s\u00e3o essenciais para qualquer desenvolvedor de software.</p> <p>Os testes desempenham um papel fundamental no processo de desenvolvimento de software por v\u00e1rias raz\u00f5es:</p> <ul> <li>Detec\u00e7\u00e3o Precoce de Erros: Os testes permitem que os desenvolvedores identifiquem e corrijam erros em um est\u00e1gio inicial do desenvolvimento, economizando tempo e recursos no longo prazo.</li> <li>Manuten\u00e7\u00e3o Simplificada: Um c\u00f3digo bem testado \u00e9 mais f\u00e1cil de manter. Quando novos recursos s\u00e3o adicionados ou modifica\u00e7\u00f5es s\u00e3o feitas, os testes garantem que as funcionalidades existentes continuem funcionando conforme o esperado.</li> <li>Redu\u00e7\u00e3o de Bugs em Produ\u00e7\u00e3o: Testar seu c\u00f3digo ajuda a evitar que bugs cheguem aos usu\u00e1rios finais, resultando em uma melhor experi\u00eancia do cliente e economizando custos associados \u00e0 corre\u00e7\u00e3o de problemas em produ\u00e7\u00e3o.</li> <li>Documenta\u00e7\u00e3o Autom\u00e1tica: Testes bem escritos funcionam como documenta\u00e7\u00e3o viva do seu c\u00f3digo. Eles descrevem como as diferentes partes do software devem se comportar.</li> <li>Confian\u00e7a no C\u00f3digo: Testar seu c\u00f3digo cria confian\u00e7a tanto para os desenvolvedores quanto para os usu\u00e1rios. Saber que o software passou em uma bateria de testes proporciona tranquilidade.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#desenvolvimento-orientado-a-testes-tdd","title":"Desenvolvimento Orientado a Testes (TDD)","text":"<p>O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem de desenvolvimento que enfatiza a escrita de testes antes de escrever o c\u00f3digo real. O ciclo TDD segue tr\u00eas passos simples: \"Red-Green-Refactor.\"</p> <ul> <li>Red (Vermelho): Neste est\u00e1gio, voc\u00ea escreve um teste que descreve a funcionalidade que deseja implementar. Como voc\u00ea ainda n\u00e3o escreveu o c\u00f3digo, o teste falhar\u00e1.</li> <li>Green (Verde): Agora, voc\u00ea escreve o c\u00f3digo m\u00ednimo necess\u00e1rio para fazer o teste passar. O objetivo \u00e9 fazer o teste passar o mais r\u00e1pido poss\u00edvel.</li> <li>Refactor (Refatorar): Com o teste passando, voc\u00ea pode refatorar o c\u00f3digo para torn\u00e1-lo mais limpo, eficiente e leg\u00edvel.</li> </ul> <p>O TDD oferece in\u00fameras vantagens, incluindo:</p> <ul> <li>Maior Qualidade do C\u00f3digo: TDD incentiva a escrita de c\u00f3digo de alta qualidade desde o in\u00edcio.</li> <li>Projeto Centrado no Usu\u00e1rio: Testes escritos com base nos requisitos do usu\u00e1rio garantem que o software atenda \u00e0s expectativas.</li> <li>Facilidade de Manuten\u00e7\u00e3o: O c\u00f3digo resultante do TDD \u00e9 mais f\u00e1cil de manter, pois as mudan\u00e7as n\u00e3o quebram as funcionalidades existentes.</li> <li>Confian\u00e7a nas Mudan\u00e7as: TDD permite que os desenvolvedores fa\u00e7am altera\u00e7\u00f5es no c\u00f3digo com confian\u00e7a, sabendo que os testes ir\u00e3o detectar problemas.</li> <li>Feedback R\u00e1pido: TDD fornece feedback imediato, acelerando o processo de desenvolvimento.</li> </ul> <p>A import\u00e2ncia dos testes na programa\u00e7\u00e3o n\u00e3o pode ser subestimada. Eles desempenham um papel cr\u00edtico na cria\u00e7\u00e3o de software de alta qualidade, confi\u00e1vel e seguro. O Desenvolvimento Orientado a Testes (TDD) \u00e9 uma abordagem valiosa que torna os testes uma parte integrante do processo de desenvolvimento, resultando em um c\u00f3digo mais robusto e confi\u00e1vel.</p> <p>Para os desenvolvedores, a pr\u00e1tica de testes e o uso do TDD representam um investimento que se traduz em economia de tempo, redu\u00e7\u00e3o de custos e satisfa\u00e7\u00e3o do cliente. \u00c0 medida que a ind\u00fastria de software continua a evoluir, a cultura de testes se torna cada vez mais fundamental para o sucesso de projetos de desenvolvimento de software.</p> <p>Portanto, da pr\u00f3xima vez que voc\u00ea come\u00e7ar a escrever c\u00f3digo, lembre-se da import\u00e2ncia dos testes e considere adotar o Desenvolvimento Orientado a Testes como parte integrante do seu processo de desenvolvimento. A qualidade do seu software agradecer\u00e1.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introduzindo-testes-ao-nosso-codigo","title":"Introduzindo testes ao nosso c\u00f3digo","text":"<p>Agora vamos abrir nosso arquivo test_game_loop.rs, esse teste vai ser usado para testarmos nossas condi\u00e7\u00f5es do jogo ent\u00e3o vamos criar um primeiro teste para validar a condi\u00e7\u00e3o que est\u00e1 fixa hoje. Vamos adicionar o c\u00f3digo abaixo no final do nosso main.rs</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero)\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Inicialmente precisamos adicionar uma anota\u00e7\u00e3o annotattion <code>#[test]</code> as anota\u00e7\u00f5es s\u00e3o colocadas no inicio de uma fun\u00e7\u00e3o/m\u00f3dulo/trait para adicionar alguma funcionalidade aquele bloco de c\u00f3digo. NO nosso caso estamos adicionando uma funcionalidade de teste para nossa fun\u00e7\u00e3o de teste <code>test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral</code> assim podemos rodar o comando de teste <code>cargo test</code>. Nossa estrutura de testes \u00e9 divida em 3 partes: - Arrange -&gt; que \u00e9 os dados que precisamos preparar para o teste - Act -&gt; Execu\u00e7\u00e3o do c\u00f3digo que queremos testas - Assert -&gt; Que \u00e9 o que esperamos que aconte\u00e7a depois do c\u00f3digo sendo executado.</p> <p>No caso do assert executamos uma macro nova que \u00e9 o <code>assert_eq!</code> sua fun\u00e7\u00e3o \u00e9 comprar dois valores caso sejam iguais ele termina corretamente, caso sejam diferentes ele vai voltar um erro no nosso teste, vamos primeiro rodar o teste do jeito que est\u00e1.</p> <pre><code>cargo test\n</code></pre> <p>Voc\u00ea deve ter um retorno parecido com esse:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Vale destacar alguns pontos:</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n    \n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n     \n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Aqui mostra onde foi compilado o teste</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\n    \nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n     \n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Nessas linhas mostram quantos testes rodaram, o nome do teste que rodou e se foi ok ou n\u00e3o</p> <pre><code>\u279c cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\n    \ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n     \n</code></pre> <p>Nessa linha temos um pequeno relat\u00f3rio dos testes quando passaram quantos derram erro e por ai vai, al\u00e9m de tudo mostra o tempo que demorou pra rodar os testes.</p> <p>Agora vamos mudar nosso teste para ele falhar</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n\n    // Act\n    game(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    ==assert_eq!(pontuacao, 0)==\n}\n</code></pre> <p>Agora temos uma sa\u00edda diferente</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.12s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral stdout ----\n\nIniciar Jogo\nA sua pontua\u00e7\u00e3o foi 900, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral' panicked at src/main.rs:51:5:\nassertion `left == right` failed\n  left: 900\n right: 0\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\n\nfailures:\n    test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n\nerror: test failed, to rerun pass `--bin guessing_game`\n\n</code></pre> <p>\u00c9 importante n\u00e3o ter medo de ler toda a mensagem mesmo que seja grande pois com ela podemos ver o problema.</p> <p>Veja que agora ele mostra a saida da execu\u00e7\u00e3o de game, no caso ele vai mostrar os dois prints que criamos depois ele vai mostrar o erro do assertion mostrando que o valor de pontua\u00e7\u00e3o foi 900 e o valor da direita foi 0 ent\u00e3o sabemos quanto nossa variavel retornou e o valor da compara\u00e7\u00e3o.</p> <p>Tamb\u00e9m podemos ver que agora no nosso relat\u00f3rio temos um teste como failed pois o teste falhou.</p> <p>Vamos agora voltar nosso teste para passar novamente e rodar os testes.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo agora podemos continuar trabalhando no jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-o-chute-do-jogador","title":"Adicionando o chute do jogador","text":"<p>Agora vamos adicionar a captura da entrada do jogador para e vamos passar o valor para nossa fun\u00e7\u00e3o game.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    \n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n    \n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos nosso teste ele ainda vai passar.</p> <pre><code>\u279c  cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos fazer algumas altera\u00e7\u00f5es vamos criar uma nova fun\u00e7\u00e3o que vai atualizar a pontua\u00e7\u00e3o. Mas primeiro vamos mudar nosso teste para verificar com a fun\u00e7\u00e3o check_win_condition e passar mais um parametro chamado chute que vai ser um inteiro tamb\u00e9m.</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_conditition(&amp;mut pontuacao, &amp;numero);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Vamos receber agora um erro de compila\u00e7\u00e3o</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0425]: cannot find function `check_win_conditition` in this scope\n  --&gt; src/main.rs:55:5\n   |\n55 |     check_win_conditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n</code></pre> <p>\u00c9 importante sempre ler a mensagem de erro e tentar entender tamb\u00e9m sempre que quiser poder rodar o <code>--explain</code> para ver a descri\u00e7\u00e3o do erro.</p> <pre><code>rustc --explain E0425\n</code></pre> <p>Nesse caso o erro \u00e9 que check_win_conditition n\u00e3o existe dentro  do escopo isso por que ele n\u00e3o foi criado, vamos ent\u00e3o cria-lo e mover o c\u00f3digo respons\u00e1vel por diminuir a pontua\u00e7\u00e3o.</p> <pre><code>fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Se rodarmos o teste ele vai funcionar com um warning que logo vamos remove-lo.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `pontuacao`\n  --&gt; src/main.rs:33:9\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pontuacao`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `numero`\n  --&gt; src/main.rs:33:30\n   |\n33 | fn game(pontuacao: &amp;mut u16, numero: &amp;u8) -&gt; () {\n   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_numero`\n\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:39:59\n   |\n39 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings (run `cargo fix --bin \"guessing_game\" --tests` to apply 3 suggestions)\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>O principal ponto desse warnings \u00e9 que n\u00e3o estamos usando v\u00e1rias variaveis vamos ajusta-las. Primeiro precisamos converter nossa variavel chute para int.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        let _ = io::stdin().read_line(&amp;mut escolha_str);\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    let _ = io::stdin().read_line(&amp;mut chute);\n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    *pontuacao -= 100;\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Temos algumas mudan\u00e7as aqui, precisamos mover pontuacao e numero_alvo para dentro da fun\u00e7\u00e3o game, pois n\u00e3o podemos reimprestar  pontuacao para verify_win_conditition essa \u00e9 uma caracteristica do rust ent\u00e3o jogamos tudo para a fun\u00e7\u00e3o game deixando a main apenas para menu. Tamb\u00e9m fizemos o match abaixo para converter a entrada  string para u8 e com isso temos um efeito colateral que precisamos voltar um n\u00famero que no caso \u00e9 0.</p> <pre><code>    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n</code></pre> <p>Agora vamos rodar nosso teste.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused variable: `chute`\n  --&gt; src/main.rs:48:59\n   |\n48 | fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n   |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chute`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning (run `cargo fix --bin \"guessing_game\" --tests` to apply 1 suggestion)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Vamos agora remover o ultimo warning e vamos come\u00e7ar a usar nosso parametro chute.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    \n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n</code></pre> <p>Assim agora apenas se o n\u00famero for menor que o n\u00famero a pontua\u00e7\u00e3o vai mudar. Vamos rodar o teste.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 1 test\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora vamos alterar nossa entrada para n\u00e3o receber o parametro \"_\", pois h\u00e1 uma forma melhor de fazer isso.</p> <pre><code>use std::io;\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        \n        io::stdin().read_line(&amp;mut escolha_str).expect(\"Erro ao receber sua escolha\");\n        \n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n\n    }\n}\n\nfn game() -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    \n    io::stdin().read_line(&amp;mut chute).expect(\"Erro ao receber o n\u00famero\");\n    \n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; { \n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero_alvo);\n}\n\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; () {\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n}\n\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n</code></pre> <p>Aqui retiramos o parametro n\u00e3o usado e colocamo no final um expect isso \u00e9 uma captura de erro, vamos detalhar isso mais a frente mas, se pense que agora caso a option que esteja com algum dado \u00e9 a <code>Err</code> ele vai printar no nosso console as mensagens que colocamos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-vitoria","title":"Adicionando condi\u00e7\u00e3o de vit\u00f3ria","text":"<p>Primeiro passo que vamos fazer \u00e9 criar um teste para a condi\u00e7\u00e3o de vit\u00f3ria:</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(pontuacao, 1000)\n}\n\n</code></pre> <p>Aqui criamos uma fun\u00e7\u00e3o de teste test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao onde simplesmente passamos o n\u00famero correto e ele deve voltar a com a pontua\u00e7\u00e3o exata que passamos. Vamos rodar o teste:</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo o teste est\u00e1 passando vamos fazer com que nossa fun\u00e7\u00e3o retorne que o jogador ganhou, normalmente em muitas linguagens trabalhariamos com um valor de verdadeiro ou falso poderiamos fazer isso aqui tamb\u00e9m, por\u00e9m como o rust nos da a ferramenta do result vamos voltar um tipo Result::Win para dizer que o jogador ganhou, mas como vamos ter outras condi\u00e7\u00f5es vamos criar uma estrutura de enumerador para representar os estados que jogo pode retornar:</p> <pre><code>#[derive(Debug, PartialEq)]\nenum GameResult {\n    Win,\n    Gaming,\n    Lose,\n}\n</code></pre> <p>Vamos primeiro entender o que \u00e9 um enum:</p> <p>! Enum Enum \u00e9 um tipo de dado que representa um conjunto de valores que voc\u00ea quer relacionar no nosso caso estamos criando um conjunto relacionado com os estados que podemos representar sobre a nossa condi\u00e7\u00e3o de vit\u00f3ria \"WIN\" para dizer que o jogador venceu, \"GAMING\" para dizer que o jogador continua jogando, \"LOSE\" para dizer que o jogador perdeu, nosso caso essa representa\u00e7\u00e3o \u00e9 um enum por isso precisamos passar o tipo de dado e o nome desse enum que no nosso caso \u00e9 GameResult. Alguns pontos importantes sobre enums: * Valores Variantes: Em uma enumera\u00e7\u00e3o, voc\u00ea define os valores poss\u00edveis, chamados de \"variantes\". Cada variante representa um valor espec\u00edfico que o tipo de enumera\u00e7\u00e3o pode ter. * Tipos Personalizados: Enums permitem que voc\u00ea crie tipos personalizados com valores limitados. Por exemplo, voc\u00ea pode criar uma enumera\u00e7\u00e3o para representar os dias da semana ou os estados de um jogo. * Padr\u00e3o de Correspond\u00eancia: Enums s\u00e3o frequentemente usadas em combina\u00e7\u00e3o com o padr\u00e3o de correspond\u00eancia (match) para fazer escolhas com base no valor da enumera\u00e7\u00e3o. Isso torna as enums \u00fateis para expressar a l\u00f3gica condicional. * Seguran\u00e7a de Tipos: Enums ajudam a garantir a seguran\u00e7a de tipos, pois o compilador verifica se todas as variantes s\u00e3o tratadas nos padr\u00f5es de correspond\u00eancia. Isso evita erros em tempo de execu\u00e7\u00e3o. * Enumera\u00e7\u00f5es com Dados: Enums podem ter dados associados a suas variantes. Isso permite que voc\u00ea armazene informa\u00e7\u00f5es adicionais com uma variante. Por exemplo, uma enumera\u00e7\u00e3o de formas geom\u00e9tricas pode ter uma variante \"C\u00edrculo\" com um raio associado. * Enums Gen\u00e9ricas: Enums podem ser gen\u00e9ricas, o que significa que voc\u00ea pode parametriz\u00e1-las com tipos de dados, tornando-as vers\u00e1teis e reutiliz\u00e1veis.</p> <p>Enuns podem ter uma chave e um valor como no exemplo abaixo:</p> <pre><code>enum DiaDaSemana {\n    Segunda(u32),\n    Terca(u32),\n    Quarta(u32),\n    Quinta(u32),\n    Sexta(u32),\n    Sabado(u32),\n    Domingo(u32),\n}\n</code></pre> <p>Ou com multiplos valores para representar uma chave como abaixo:</p> <pre><code>enum Cor {\n    RGB(u8, u8, u8),\n    Nome(String),\n}\n</code></pre> <p>H\u00e1 outras formas mas, vamos nos fixar em usa-lo apenas para que a chave e o valor sejam os mesmos que no caso \u00e9 forma que criamos nosso enum sem passar nenhum tipo.</p> <p>Agora usamos uma anota\u00e7\u00e3o nova que \u00e9 o  `#[derive(...)] A anota\u00e7\u00e3o #[derive(...)] em Rust \u00e9 uma caracter\u00edstica poderosa que gera automaticamente a implementa\u00e7\u00e3o de certos tra\u00e7os (traits) para tipos de dados personalizados, como structs e enums. Isso ajuda a evitar a escrita repetitiva de c\u00f3digo ao criar tipos de dados personalizados.</p>"},{"location":"1_2_jogo_da_adivinhacao/#trait","title":"Trait","text":"<p>Em Rust, um trait \u00e9 como um contrato ou um conjunto de regras que um tipo de dado deve seguir. \u00c9 uma maneira de definir comportamentos que tipos diferentes podem compartilhar.</p> <p>Um trait especifica m\u00e9todos que um tipo deve implementar, e outros tipos podem aderir a esse trait, implementando esses m\u00e9todos. Isso permite que diferentes tipos de dados compartilhem funcionalidades comuns.</p> <p>Por exemplo, voc\u00ea pode ter um trait chamado \"Imprim\u00edvel\" que especifica um m\u00e9todo imprimir, e v\u00e1rias estruturas diferentes podem implementar esse trait para que possam ser impressas de maneira semelhante, mesmo que sejam tipos diferentes. Isso torna o c\u00f3digo mais gen\u00e9rico e reutiliz\u00e1vel.</p> <p>Traits usam conceito de polimorfismo.</p> <p>Polimorfismo permite que objetos de diferentes tipos sejam tratados de maneira uniforme, permitindo o uso de m\u00e9todos ou fun\u00e7\u00f5es comuns a esses objetos, independentemente de seus tipos espec\u00edficos.</p>"},{"location":"1_2_jogo_da_adivinhacao/#derive","title":"Derive","text":"<p>A atribui\u00e7\u00e3o #[derive] em Rust permite que os programadores gerem automaticamente a implementa\u00e7\u00e3o de certos tra\u00e7os para suas estruturas de dados, enums ou uni\u00f5es. Ele \u00e9 usado para derivar a implementa\u00e7\u00e3o de tra\u00e7os comuns, como Clone, Debug, Eq, PartialEq, Hash, entre outros, com base na estrutura da sua estrutura de dados.</p> <p>Elas podem ser implementadas diretamente no c\u00f3digo caso precise de um c\u00f3digo mais complexo.</p> <ul> <li>Traits de compara\u00e7\u00e3o: Eq, PartialEq, Ord, PartialOrd.</li> <li>Clone, para criar um novo objeto a partir de outro via copia.</li> <li>Copy, para copiar o elemento ao inv\u00e9s de mover.</li> <li>Hash, para computar um hast a partir &amp;T.</li> <li>Default, para criar um objeto padr\u00e3o do tipo especificado.</li> <li>Debug, para formatar a partir de {:?} formatter.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#vantagens-do-derive","title":"Vantagens do Derive","text":"<p>Facilita a implementa\u00e7\u00e3o de tra\u00e7os comuns para tipos de dados personalizados. Reduz a necessidade de escrever c\u00f3digo manualmente para cada tra\u00e7o. Permite que o compilador Rust gere automaticamente c\u00f3digo de implementa\u00e7\u00e3o eficiente para os tra\u00e7os derivados. Simplifica a manuten\u00e7\u00e3o e o desenvolvimento de c\u00f3digo, tornando-o mais conciso e leg\u00edvel. Voc\u00ea pode criar um c\u00f3digo com <code>#[derive]</code> usando <code>procedural macros</code></p>"},{"location":"1_2_jogo_da_adivinhacao/#procedural-macros","title":"Procedural macros","text":"<p>As macros procedurais s\u00e3o uma caracter\u00edstica avan\u00e7ada do Rust que permite que os desenvolvedores escrevam c\u00f3digo que manipula a representa\u00e7\u00e3o de c\u00f3digo Rust em tempo de compila\u00e7\u00e3o. Essas macros permitem que voc\u00ea escreva c\u00f3digo que gera c\u00f3digo, o que pode ser \u00fatil para automatizar tarefas repetitivas, criar DSLs espec\u00edficas do dom\u00ednio ou realizar transforma\u00e7\u00f5es complexas no c\u00f3digo Rust.</p> <ul> <li>Permitem a gera\u00e7\u00e3o de c\u00f3digo personalizado em tempo de compila\u00e7\u00e3o.</li> <li>Podem ser usadas para automatizar tarefas tediosas ou repetitivas.</li> <li>Permitem a cria\u00e7\u00e3o de DSLs espec\u00edficas do dom\u00ednio para tornar o c\u00f3digo mais expressivo e leg\u00edvel.</li> <li>Podem ser usadas para realizar transforma\u00e7\u00f5es complexas no c\u00f3digo, como otimiza\u00e7\u00f5es de desempenho ou an\u00e1lise est\u00e1tica avan\u00e7ada.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#no-nosso-caso-vamos-passar-algumas-implementacoes-basicas-no-derive","title":"No nosso caso vamos passar algumas implementa\u00e7\u00f5es b\u00e1sicas no derive","text":"<p>Debug <code>derive</code> (#[derive(Debug)]): Ao usar #[derive(Debug)] em uma estrutura ou enumera\u00e7\u00e3o, Rust gera automaticamente a implementa\u00e7\u00e3o do Debug para esse tipo. O <code>derive</code> Debug permite que voc\u00ea formate o valor do tipo de forma leg\u00edvel por humanos quando voc\u00ea imprime um objeto desse tipo usando a fun\u00e7\u00e3o println!(\"{:?}\", objeto). Isso \u00e9 particularmente \u00fatil para fins de depura\u00e7\u00e3o, pois fornece informa\u00e7\u00f5es detalhadas sobre o estado do objeto.</p> <p>PartialEq derive (#[derive(PartialEq)]): Usando #[derive(PartialEq)], Rust gera a implementa\u00e7\u00e3o do trait PartialEq para o tipo. O PartialEq permite que voc\u00ea compare objetos do tipo com operadores de igualdade (==) e desigualdade (!=). Isso significa que voc\u00ea pode verificar se dois objetos s\u00e3o iguais ou diferentes com facilidade, simplificando a l\u00f3gica de compara\u00e7\u00e3o.</p> <p>Certo agora vamos ajustar o teste para nossa fun\u00e7\u00e3o:</p> <pre><code>#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    ==let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);==\n\n    //Assert\n    ==assert_eq!(result, Ok(GameResult::Win));==\n    assert_eq!(pontuacao, 1000)\n}\n</code></pre> <p>Ali colocamos uma variavel para receber o retorno da nossa fun\u00e7\u00e3o chamado result e tamb\u00e9m verificamos se essa variav\u00e9l result retorna no seu ResultSet o valor do enum GameResult como Win que \u00e9 o valor do enum que criamos. Agora vamos rodar o teste.</p> <pre><code>cargo test\n</code></pre> <p>Com o seguinte resultado</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:89:24\n   |\n89 |     assert_eq!(result, Ok(GameResult::Win));\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `()`, found `Result&lt;GameResult, _&gt;`\n   |\n   = note: expected unit type `()`\n                   found enum `Result&lt;GameResult, _&gt;`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n</code></pre> <p>Isso ocorreu por que estamos voltando um ResultSet vazio e ele esperava um ResultSet com um GameResult, ent\u00e3o vamos mudar o retorno da nossa fun\u00e7\u00e3o.</p> <pre><code>...\nfn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n...\n</code></pre> <p>Aqui falamos que o result tem o OK como  um <code>GameResult</code> e o Erro tamb\u00e9m como um <code>GameResult</code> vamos rodar o teste.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:59:5\n   |\n59 |     println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;GameResult, ...&gt;`, found `()`\n   |\n   = note:   expected enum `Result&lt;GameResult, GameResult&gt;`\n           found unit type `()`\n   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` (bin \"guessing_game\" test) due to previous error\n\n</code></pre> <p>Aqui fala que o problema \u00e9 que temos um print no final da fun\u00e7\u00e3o vamos colocar no final um <code>GameResult::Gaming</code> para mostrar a condi\u00e7\u00e3o que o jogo ainda n\u00e3o terminou.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero);\n    ==Ok(GameResult::Gaming)==\n}\n</code></pre> <p>Aqui colocamos de maneira explicita no final ele vai retornar um result do tipo <code>OK</code> com o valor Gaming do nosso enum. Vale atentar que precisamos agora colocar um  \";\" no nosso print. Agora vamos rodar os testes:</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: variant `Lose` is never constructed\n --&gt; src/main.rs:7:5\n  |\n4 | enum GameResult {\n  |      ---------- variant in this enum\n...\n7 |     Lose,\n  |     ^^^^\n  |\n  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:51:5\n   |\n51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:73:5\n   |\n73 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n73 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao stdout ----\nA sua pontua\u00e7\u00e3o foi 1000, e o n\u00famero era 42\n\nthread 'test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao' panicked at src/main.rs:90:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Win)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\n\nfailures:\n    test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n</code></pre> <p>Aqui vamos ter alguns warnings, mas no ponto de destaque mostra ainha que deu erro, no meu caso ainha 90 e mostra que ele espearava um <code>Ok(Win)</code> mas, recebeu um <code>Ok(Gaming)</code>. Ent\u00e3o finalmente  podemos agora colocar nosso bloco de c\u00f3digo que determina que o usu\u00e1rio venceu que nesse caso ser\u00e1 um if.</p> <pre><code>fn check_win_coditition(pontuacao: &amp;mut u16, numero: &amp;u8, chute: &amp;u8) -&gt; Result&lt;GameResult, GameResult&gt; {\n    \n    if chute == numero {\n        return Ok(GameResult::Win)\n    }\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    println!(\"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\", pontuacao, numero);\n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui comparamos que o chute \u00e9 igual ao n\u00famero e caso essa compara\u00e7\u00e3o seja verdadeira precisamos colocar a palavra chave return com o  <code>Ok(GameResult::Win)</code> pois temos mais c\u00f3digo que vai ser executado abaixo dele ent\u00e3o estamos for\u00e7ando um retorno prematuro.</p> <p>Agora vamos rodar os testes.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: variant `Lose` is never constructed\n --&gt; src/main.rs:7:5\n  |\n4 | enum GameResult {\n  |      ---------- variant in this enum\n...\n7 |     Lose,\n  |     ^^^^\n  |\n  = note: `GameResult` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:51:5\n   |\n51 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n51 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:76:5\n   |\n76 |     check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n76 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 3 warnings\n    Finished test [unoptimized + debuginfo] target(s) in 0.14s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 2 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Ainda temos alguns warnings mas, nossos testes voltaram a passar.</p>"},{"location":"1_2_jogo_da_adivinhacao/#adicionando-condicao-de-derrota","title":"Adicionando condi\u00e7\u00e3o de derrota","text":"<p>Bom agora vamos criar uma condi\u00e7\u00e3o pra nossa fun\u00e7\u00e3o registrar a derrota. Mas, primeiro vamos criar o teste.</p> <pre><code>#[test]\nfn test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    == let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==\n\n    // Assert\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Win));\n    assert_eq!(pontuacao, 1000)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n</code></pre> <p>Nesse teste diminuimos a pontua\u00e7\u00e3o e erramos pra baixo e ele deve voltar o rusult como Lose e a pontua\u00e7\u00e3o como 0. Ent\u00e3o vamos testar.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.17s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 3 tests\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... FAILED\n\nfailures:\n\n---- test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo stdout ----\n\nA sua pontua\u00e7\u00e3o foi 0, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo' panicked at src/main.rs:119:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Lose)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo\n\ntest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n</code></pre> <p>Bom tivemos um erro por que voltou Gaming ao inv\u00e9s de Lose, para arrumarmos isso vamos ajustar nossa fun\u00e7\u00e3o.</p> <pre><code>fn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    \n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    \n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero\n    );\n    Ok(GameResult::Gaming)\n}\n\n</code></pre> <p>Aqui adicionamos mais uma condi\u00e7\u00e3o para que se a pontua\u00e7\u00e3o for menor ou igual a 0 retornamos <code>GameResult::Lose</code> pra fun\u00e7\u00e3o chamadora, agora vamos testar novamente.</p> <pre><code>\u276e cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 3 tests\ntest test_jogador_deu_numero_errado_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Perfeito agora nosso teste passou mas, vamos criar outro teste passando nosso chute sendo um valor maior que o n\u00famero alvo.</p> <pre><code>#[test]\n== fn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() { ==\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n</code></pre> <p>Aqui renomeamos o nosso teste anterior pra explicitar que estamos chutando um n\u00famero baixo e criamos outro explicitando que estamos chutando um n\u00famero altoi, agora rodando os testes teremos uma falha.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.14s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 4 tests\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... FAILED\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\n\nfailures:\n\n---- test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo stdout ----\n\nA sua pontua\u00e7\u00e3o foi 100, e o n\u00famero era 42\nthread 'test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo' panicked at src/main.rs:137:5:\nassertion `left == right` failed\n  left: Ok(Gaming)\n right: Ok(Lose)\n\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo\n\ntest result: FAILED. 3 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin guessing_game`\n\n</code></pre> <p>Como podemos ver ele voltou Gaming ao inv\u00e9s de Lose isso por que n\u00e3o implementamos a condi\u00e7\u00e3o pra que o valor maior decremente ent\u00e3o vamos cria-la.</p> <pre><code> check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    \n    if chute &lt; numero {\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        *pontuacao -= 100;\n    }\n    \n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero\n    );\n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui colocamos nossa condi\u00e7\u00e3o de decrementar a pontua\u00e7\u00e3o com um erro como a primeira coisa a ser verificada, para evitar qualquer problema de ser decrementado ap\u00f3s verificar a condi\u00e7\u00e3o de vit\u00f3ria, assim adicionamos mais um if no nosso c\u00f3digo e podemos rodar o teste para verificar se est\u00e1 passando.</p> <pre><code>\u276f cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:54:5\n   |\n54 |     check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n   |\n54 |     let _ = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute);\n   |     +++++++\n\nwarning: `guessing_game` (bin \"guessing_game\" test) generated 1 warning\n    Finished test [unoptimized + debuginfo] target(s) in 0.13s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 4 tests\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Bom agora conseguimos ter a condi\u00e7\u00e3o de derrota no nosso jogo.</p>"},{"location":"1_2_jogo_da_adivinhacao/#criando-mais-testes","title":"Criando mais testes","text":"<p>Bom agora que temos nossa condi\u00e7\u00e3o para decrementar a pontua\u00e7\u00e3o quando erramos pra cima ou pra baixo, precisamos ajustar nosso teste test_jogador_deu_numero_errado_deve_diminuir_pontuacao_geral para receber a condi\u00e7\u00e3o <code>GameResult::Gaming</code> e tamb\u00e9m criar um novo teste para explicitar o chute pra cima e o outro pra baixo.</p> <pre><code> -&gt; () {\n    println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    let mut chute = String::new();\n    io::stdin()\n        .read_line(&amp;mut chute)\n        .expect(\"Erro ao receber o n\u00famero\");\n\n    let chute: u8 = match chute.trim().parse() {\n        Ok(num) =&gt; num,\n        Err(_) =&gt; {\n            println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n            0\n        }\n    };\n    ==let _result = check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute); ==\n    println!(\n        \"A sua pontua\u00e7\u00e3o foi {}, e o n\u00famero era {}\",\n        pontuacao, numero_alvo\n    );\n}\n\n...\n#[test]\n fn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() { \n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    == let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute); ==\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n</code></pre> <p>Aqui mudamos o nome do teste anterior e criamos um novo al\u00e9m de adiconar o result para verifica\u00e7\u00e3o e tamb\u00e9m pra nossa fun\u00e7\u00e3o game, o agora se rodarmos os testes os warnings v\u00e3o desaparecer.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.12s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>"},{"location":"1_2_jogo_da_adivinhacao/#melhorando-nossa-funcao-de-condicao-e-ajustando-a-funcao-game","title":"Melhorando nossa fun\u00e7\u00e3o de condi\u00e7\u00e3o e ajustando a fun\u00e7\u00e3o game.","text":"<p>Bom poderiamos agora criar testes de integra\u00e7\u00e3o pra nossa fun\u00e7\u00e3o game, mas vamos trabalhar isso mais a frente, agora vamos melhorar nossa fun\u00e7\u00e3o game, n\u00e3o importa se acertamos ou \u258derramos n\u00f3s voltamos ao menu principal, ent\u00e3o precisamos s\u00f3 voltar pro loop do menu quando perdemos ou ganharmos o jogo pra isso vamos criar um novo loop no nosso jogo.</p> <pre><code>\nfn game() -&gt; () {\n    let mut pontuacao: u16 = 1000;\n    let numero_alvo: u8 = 42;\n    loop {\n        println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n        let mut chute = String::new();\n        io::stdin()\n            .read_line(&amp;mut chute)\n            .expect(\"Erro ao receber o n\u00famero\");\n\n        let chute: u8 = match chute.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n                0\n            }\n        };\n        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {\n            Ok(result) =&gt; {\n                if result == GameResult::Win {\n                    println!(\"Parab\u00e9ns voc\u00ea venceu! Sua pontua\u00e7\u00e3o foi {}\", pontuacao);\n                    break;\n                } else if result == GameResult::Lose {\n                    println!(\"Que pena voc\u00ea perdeu!\");\n                    break;\n                }\n            }\n            Err(_) =&gt; {\n                println!(\"Ocorreu um erro e o jogo ser\u00e1 reiniciado!\");\n                break;\n            }\n        };\n        println!(\"A sua pontua\u00e7\u00e3o est\u00e1 em {}\", pontuacao);\n    }\n}\n\n\nfn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        == println!(\"O n\u00famero \u00e9 maior!\"); ==\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        == println!(\"O n\u00famero \u00e9 menor!\"); ==\n        *pontuacao -= 100;\n    }\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n     \n    Ok(GameResult::Gaming)\n}\n</code></pre> <p>Aqui criamos um loop dentro da nossa fun\u00e7\u00e3o game e s\u00f3 deixamos o n\u00famero alvo e a pontua\u00e7\u00e3o fora pois sempre que iniciar um jogo vamos reiniciar o placar. Nossa fun\u00e7\u00e3o check_win_condition nos retorna um <code>ResultGame</code>, por conta disso podemos fazer um match para caso entre na condi\u00e7\u00e3o de vit\u00f3ria ou derrota o jogo \u00e9 encerrado e volta no menu, tamb\u00e9m caso tenhamos algum erro de execu\u00e7\u00e3o ele vai retornar o jogo pro menu. Tamb\u00e9m colocamos uma dica pro jogador saber se o n\u00famero \u00e9 maior ou menor para facilitar que ele.</p> <p>Para ter certeza que n\u00e3o quebramos nada vamos rodar nossos testes.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.16s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-d4e6bf5f3d77f592)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Com isso agora j\u00e1 temos um jogo bem jog\u00e1vel.</p>"},{"location":"1_2_jogo_da_adivinhacao/#colocando-aleatoriedade-no-nosso-jogo","title":"Colocando aleatoriedade no nosso jogo","text":"<p>Nosso jogo est\u00e1 bem interessante mas, nesse momento nosso n\u00famero alvo est\u00e1 fixo e queremos que ele seja aleat\u00f3rio para isso vamos precisar de uma biblioteca que n\u00e3o est\u00e1 no padr\u00e3o da linguagem rust que \u00e9 o rand.</p>"},{"location":"1_2_jogo_da_adivinhacao/#introducao-aos-crates","title":"Introdu\u00e7\u00e3o aos crates","text":"<p>Rust \u00e9 uma linguagem de programa\u00e7\u00e3o que ganhou popularidade devido \u00e0 sua seguran\u00e7a, desempenho e concorr\u00eancia. Um dos conceitos fundamentais no ecossistema Rust \u00e9 o de \"crates\". Vamos explorar o que s\u00e3o os crates em Rust e como eles funcionam para facilitar o desenvolvimento de software.</p>"},{"location":"1_2_jogo_da_adivinhacao/#o-que-sao-crates","title":"O Que S\u00e3o Crates?","text":"<p>Em Rust, um \"crate\" \u00e9 a unidade de compila\u00e7\u00e3o de c\u00f3digo. Um crate pode ser uma biblioteca, um aplicativo, um bin\u00e1rio ou at\u00e9 mesmo um subconjunto menor de c\u00f3digo. A ideia por tr\u00e1s dos crates \u00e9 promover a modularidade e a reutiliza\u00e7\u00e3o de c\u00f3digo, permitindo que voc\u00ea organize seu projeto de forma limpa e eficaz.</p>"},{"location":"1_2_jogo_da_adivinhacao/#tipos-de-crates","title":"Tipos de Crates","text":"<p>Existem dois tipos principais de crates em Rust: crates bin\u00e1rios e crates de biblioteca.</p> <ul> <li> <p>Crates Bin\u00e1rios: Esses s\u00e3o os crates que criam um execut\u00e1vel quando compilados. Eles s\u00e3o destinados a iniciar um programa e geralmente cont\u00eam a fun\u00e7\u00e3o main(). Um exemplo de crate bin\u00e1rio \u00e9 um aplicativo de linha de comando ou uma aplica\u00e7\u00e3o de servidor.</p> </li> <li> <p>Crates de Biblioteca: Esses crates n\u00e3o t\u00eam uma fun\u00e7\u00e3o main() e s\u00e3o destinados a serem usados como bibliotecas por outros crates. Os crates de biblioteca podem conter fun\u00e7\u00f5es, estruturas, enums e muito mais que podem ser usados por outros desenvolvedores para criar seus programas.</p> </li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#estrutura-de-diretorios-de-um-crate","title":"Estrutura de Diret\u00f3rios de um Crate","text":"<p>Dentro do diret\u00f3rio do seu crate, voc\u00ea encontrar\u00e1 uma estrutura t\u00edpica de diret\u00f3rios:</p> <ul> <li>src: Cont\u00e9m o c\u00f3digo-fonte do seu crate.</li> <li>Cargo.toml: Arquivo de configura\u00e7\u00e3o do seu crate, onde voc\u00ea especifica depend\u00eancias e outras informa\u00e7\u00f5es.</li> <li>tests: Diret\u00f3rio para escrever testes para o seu crate.</li> <li>examples: Diret\u00f3rio para incluir exemplos de c\u00f3digo para demonstrar o uso do seu crate.</li> </ul>"},{"location":"1_2_jogo_da_adivinhacao/#gerenciando-dependencias","title":"Gerenciando Depend\u00eancias","text":"<p>Rust usa o gerenciador de pacotes Cargo para gerenciar depend\u00eancias. Voc\u00ea pode especificar as depend\u00eancias necess\u00e1rias no arquivo Cargo.toml. Quando voc\u00ea compila seu crate, o Cargo se encarrega de baixar e compilar todas as depend\u00eancias automaticamente.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-crates-de-terceiros","title":"Usando Crates de Terceiros","text":"<p>Um dos principais benef\u00edcios do ecossistema Rust \u00e9 a facilidade de uso de crates de terceiros. Voc\u00ea pode pesquisar e encontrar uma vasta cole\u00e7\u00e3o de crates de alta qualidade no Rust's package registry, crates.io. Para adicionar uma depend\u00eancia a um crate, basta adicionar a linha apropriada no seu arquivo Cargo.toml.</p> <pre><code>\n[dependencies]\nnome_do_pacote = \"versao\"\n</code></pre> <p>Ap\u00f3s adicionar a depend\u00eancia, execute cargo build para baixar e compilar os crates necess\u00e1rios.</p> <p>Tamb\u00e9m podemos instalar diratamente na linha de comando como abaixo:</p> <pre><code>cargo add lib\n</code></pre> <p>Crates s\u00e3o um componente fundamental do ecossistema Rust, permitindo que voc\u00ea desenvolva, compartilhe e reutilize c\u00f3digo de maneira eficaz. A modularidade e a facilidade de gerenciamento de depend\u00eancias tornam Rust uma linguagem poderosa para o desenvolvimento de software. Compreender o sistema de crates \u00e9 essencial para qualquer desenvolvedor Rust, pois \u00e9 uma parte integrante do processo de constru\u00e7\u00e3o de aplica\u00e7\u00f5es robustas e seguras.</p> <p>Agora vamos entrar no site do crates.io vamos buscar a biblioteca rand, aqui no crates.io podemos ver mais sobre a biblioteca, no nosso caso essa biblioteca serve para gerar n\u00fameros aleat\u00f3rio. Vamos instala-la.</p> <pre><code>cargo add rand\n</code></pre> <p>Agora vamos implementa-la no nosso c\u00f3digo.</p> <pre><code>== use rand::{thread_rng, Rng}; ==\nuse std::io;\n\n#[derive(Debug, PartialEq)]\nenum GameResult {\n    Win,\n    Gaming,\n    Lose,\n}\n\nfn main() {\n    loop {\n        println!(\"Bem vindo ao jogo da adivinha\u00e7\u00e3o escolha uma das op\u00e7\u00f5es abaixo\");\n        println!(\"i - Iniciar o jogo\");\n        println!(\"q - Fechar o jogo\");\n\n        let mut escolha_str = String::new();\n        io::stdin()\n            .read_line(&amp;mut escolha_str)\n            .expect(\"Erro ao receber sua escolha\");\n\n        match escolha_str.trim().to_lowercase().as_str() {\n            \"i\" =&gt; {\n                game();\n                continue;\n            }\n            \"q\" =&gt; {\n                println!(\"Obrigado por jogar\");\n                break;\n            }\n            _ =&gt; {\n                println!(\"Escolha inv\u00e1lida. Tente novamente.\");\n                continue;\n            }\n        };\n    }\n}\n\nfn game() -&gt; () {\n    let mut pontuacao: u16 = 1000;\n    == let numero_alvo: u8 = thread_rng().gen_range(1..100); ==\n    loop {\n        println!(\"Por favor digite o n\u00famero que voc\u00ea acredita ser\");\n        let mut chute = String::new();\n        io::stdin()\n            .read_line(&amp;mut chute)\n            .expect(\"Erro ao receber o n\u00famero\");\n\n        let chute: u8 = match chute.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; {\n                println!(\"Valor n\u00e3o \u00e9 v\u00e1lido ou n\u00e3o est\u00e1 entre 0 e 255\");\n                0\n            }\n        };\n        match check_win_coditition(&amp;mut pontuacao, &amp;numero_alvo, &amp;chute) {\n            Ok(result) =&gt; {\n                if result == GameResult::Win {\n                    println!(\"Parab\u00e9ns voc\u00ea venceu! Sua pontua\u00e7\u00e3o foi {}\", pontuacao);\n                    break;\n                } else if result == GameResult::Lose {\n                    println!(\"Que pena voc\u00ea perdeu!\");\n                    break;\n                }\n            }\n            Err(_) =&gt; {\n                println!(\"Ocorreu um erro e o jogo ser\u00e1 reiniciado!\");\n                break;\n            }\n        };\n        println!(\"A sua pontua\u00e7\u00e3o est\u00e1 em {}\", pontuacao);\n    }\n}\n\nfn check_win_coditition(\n    pontuacao: &amp;mut u16,\n    numero: &amp;u8,\n    chute: &amp;u8,\n) -&gt; Result&lt;GameResult, GameResult&gt; {\n    if chute &lt; numero {\n        println!(\"O n\u00famero \u00e9 maior!\");\n        *pontuacao -= 100;\n    }\n    if chute &gt; numero {\n        println!(\"O n\u00famero \u00e9 menor!\");\n        *pontuacao -= 100;\n    }\n    if chute == numero {\n        return Ok(GameResult::Win);\n    }\n    if *pontuacao &lt;= 0 {\n        return Ok(GameResult::Lose);\n    }\n    Ok(GameResult::Gaming)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    // Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    // Assert\n    assert_eq!(result, Ok(GameResult::Gaming));\n    assert_eq!(pontuacao, 900)\n}\n\n#[test]\nfn test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao() {\n    // Arrange\n    let mut pontuacao: u16 = 1000;\n    let numero: u8 = 42;\n    let chute: u8 = 42;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Win));\n    assert_eq!(pontuacao, 1000)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 1;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n\n#[test]\nfn test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo() {\n    // Arrange\n    let mut pontuacao: u16 = 100;\n    let numero: u8 = 42;\n    let chute: u8 = 100;\n\n    //Act\n    let result = check_win_coditition(&amp;mut pontuacao, &amp;numero, &amp;chute);\n\n    //Asert\n    assert_eq!(result, Ok(GameResult::Lose));\n    assert_eq!(pontuacao, 0)\n}\n</code></pre> <p>No caso do rand gerar o n\u00famero que queremos precisamos usar a fun\u00e7\u00e3o gen_range olhando na documenta\u00e7\u00e3o precisamos importar <code>use rand::{thread_rng, Rng};</code> que s\u00e3o as fun\u00e7\u00f5es de base e simplemente removemos o n\u00famero fixo por essa fun\u00e7\u00e3o na declara\u00e7\u00e3o da vari\u00e1vel.</p> <pre><code>    let numero_alvo: u8 = thread_rng().gen_range(1..100);\n</code></pre> <p>Ai colocamos que queremos gerar um valor entre 1 e 100 e agora vamos rodar os testes para ver se nossa altera\u00e7\u00e3o quebrou alguma coisa.</p> <pre><code>\u279c cargo test\n   Compiling guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.15s\n     Running unittests src/main.rs (target/debug/deps/guessing_game-1e17f810f8775677)\n\nrunning 5 tests\ntest test_jogador_deu_numero_errado_pra_cima_deve_diminuir_pontuacao_geral ... ok\ntest test_jogador_deu_numero_errado_alto_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_errado_baixo_deve_finalizar_jogo_perdendo ... ok\ntest test_jogador_deu_numero_exato_deve_finalizar_jogo_sem_mudar_pontuacao ... ok\ntest test_jogador_deu_numero_errado_pra_baixo_deve_diminuir_pontuacao_geral ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo tudo funcionando.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-o-cargo-fmt","title":"Usando o cargo fmt","text":"<p>Nesse m\u00f3dulo eu usei o editor helix e nele eu configurei para ajustar a formata\u00e7\u00e3o do meu c\u00f3digo automaticamente, mas, h\u00e1 um comando no <code>cargo</code> que \u00e9 poss\u00edvel fazer a formata\u00e7\u00e3o do seu c\u00f3digo que \u00e9 o fmt podemos roda-lo com o comando abaixo:</p> <pre><code>cargo fmt\n</code></pre> <p>Com isso pode ajustar nosso c\u00f3digo pra j\u00e1 trabalhar com o <code>clippy</code>.</p>"},{"location":"1_2_jogo_da_adivinhacao/#usando-clippy","title":"Usando Clippy","text":"<p>Clippy \u00e9 uma ferramenta de an\u00e1lise est\u00e1tica para o Rust, desenvolvida pela comunidade. Ele fornece sugest\u00f5es e avisos sobre poss\u00edveis problemas de c\u00f3digo, seguindo as melhores pr\u00e1ticas e conven\u00e7\u00f5es da linguagem Rust.</p> <p>Para rodar o cargo clippy \u00e9 s\u00f3 executar o comando abaixo:</p> <pre><code>cargo clippy\n</code></pre> <p>Vamos ter uma sa\u00edda parecida com essa:</p> <pre><code>guessing_game on \ue0a0 main [?] is \ud83d\udce6 v0.1.0 via \ud83e\udd80 v1.76.0 on \u2601\ufe0f   (eu-west-2)\n\u279c cargo clippy\n    Checking guessing_game v0.1.0 (/home/feanor/worspace/protipos-jogos-curso/guessing_game)\nwarning: unneeded unit return type\n  --&gt; src/main.rs:39:10\n   |\n39 | fn game() -&gt; () {\n   |          ^^^^^^ help: remove the `-&gt; ()`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n   = note: `#[warn(clippy::unused_unit)]` on by default\n\nerror: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n  --&gt; src/main.rs:91:8\n   |\n91 |     if *pontuacao &lt;= 0 {\n   |        ^^^^^^^^^^^^^^^\n   |\n   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\nerror: could not compile `guessing_game` (bin \"guessing_game\") due to 1 previous error; 1 warning emitted\n</code></pre> <p>Primeiro ponto vamos ver esse warning:</p> <pre><code>warning: unneeded unit return type\n  --&gt; src/main.rs:39:10\n   |\n39 | fn game() -&gt; () {\n   |          ^^^^^^ help: remove the `-&gt; ()`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n   = note: `#[warn(clippy::unused_unit)]` on by default\n</code></pre> <p>Aqui colocamos nossa sa\u00edda como uma option vazia <code>-&gt; ()</code> ent\u00e3o podemos remover conforme ele est\u00e1 indicando, \u00e9 importnte ver que tamb\u00e9m ele coloca uma documenta\u00e7\u00e3o do clippy informando por que \u00e9 uma m\u00e1 pr\u00e1tica. Caso voc\u00ea queira ignorar o erro voc\u00ea pode colocar a anota\u00e7\u00e3o que ele recomenda que no caso \u00e9 <code>#[warn(clippy::unused_unit)]</code>.</p> <p>Agora vamos ver o outro warning:</p> <pre><code>error: this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n  --&gt; src/main.rs:91:8\n   |\n91 |     if *pontuacao &lt;= 0 {\n   |        ^^^^^^^^^^^^^^^\n   |\n   = help: because `0` is the minimum value for this type, the case where the two sides are not equal never occurs, consider using `*pontuacao == 0` instead\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n   = note: `#[deny(clippy::absurd_extreme_comparisons)]` on by default\n</code></pre> <p>Esse warning fala que estamos querendo ver um valor menor que zero, por\u00e9m estamos usando na pontua\u00e7\u00e3o um tipo <code>u</code> que n\u00e3o aceita sinal, temos duas formas de resolver isso, mudar nosso prametro pra o tipo <code>i</code> que aceita sinal ou ainda como nossa pontua\u00e7\u00e3o n\u00e3o deveria nunca ser menor que zero, podemos apenas seguir a instru\u00e7\u00e3o do clippy e deixar o sinal de igualdade <code>==</code>.</p> <p>Rodando agora o clippy novamente temos a sa\u00edda abaixo:</p> <pre><code>\u2726 \u279c cargo clippy\n    Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n</code></pre> <p>Quer dizer que nosso c\u00f3digo est\u00e1 sem erros no momento.</p>"},{"location":"1_2_jogo_da_adivinhacao/#update-rust","title":"Update Rust","text":"<p>O rust vem sendo atualizado com o tempo, no caso do curso come\u00e7amos com a vers\u00e3o 1.73 ent\u00e3o vamos atualizar o nosso c\u00f3digo agora simplemente precisamos rodar o comando abaixo:</p> <pre><code>rustup update\n</code></pre> <p>Com isso agora vamos pra ultima vers\u00e3o do rust dispon\u00edvel.</p>"},{"location":"1_2_jogo_da_adivinhacao/#conclusao","title":"Conclus\u00e3o","text":"<p>Com esse jogo vimos como criar uma fun\u00e7\u00e3o em rust, criar testes para essa fun\u00e7\u00e3o usando a suite nativa de testes do rust, mais algumas fun\u00e7\u00f5es de manipula\u00e7\u00e3o de strings, como funciona o conceito de borrow and ownership, como funciona o gerenciamento de mem\u00f3ria do rust.</p>"},{"location":"1_2_jogo_da_adivinhacao/#exercicios-sugeridos","title":"Exercic\u00edos sugeridos","text":"<p>Exerc\u00edcio 1: Jogo de Perguntas e Respostas</p> <p>Crie um jogo de perguntas e respostas em que o jogador deve responder a v\u00e1rias perguntas. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>O programa deve conter um conjunto de perguntas e respostas.\nO jogador deve receber uma pergunta e fornecer uma resposta.\nO programa deve verificar se a resposta est\u00e1 correta e atualizar a pontua\u00e7\u00e3o do jogador.\nUse fun\u00e7\u00f5es para organizar o c\u00f3digo, armazenar perguntas e respostas, e verificar as respostas do jogador.\nEscreva testes para garantir que o jogo funcione corretamente.\n</code></pre> <p>Exerc\u00edcio 2: Jogo de Aventura com Hist\u00f3ria Interativa</p> <p>Crie um jogo de aventura com uma hist\u00f3ria interativa em que o jogador toma decis\u00f5es que afetam o desenrolar da hist\u00f3ria. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>Use enumera\u00e7\u00f5es para representar as diferentes escolhas e eventos na hist\u00f3ria.\nUse vari\u00e1veis mut\u00e1veis para rastrear o progresso da hist\u00f3ria e as decis\u00f5es do jogador.\nUse loops para permitir que o jogador fa\u00e7a escolhas ao longo da hist\u00f3ria.\nUse if, if else e match para verificar as escolhas do jogador e os resultados na hist\u00f3ria.\nUse a macro println! para exibir a narrativa da aventura.\n</code></pre> <p>Exerc\u00edcio 3: Jogo da Forca</p> <p>Crie um jogo multiplayer alternativo da forca em que o jogador deve adivinhar uma palavra oculta. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>O programa deve receber uma palavra aleat\u00f3ria de um jogador e uma dica.\nO outro jogador deve fazer tentativas para adivinhar a palavra escrevendo ela inteira.\nO programa deve mostrar uma representa\u00e7\u00e3o de quantas tentativas faltam.\nO jogo deve ser encerrado quando o jogador adivinhar a palavra corretamente ou ap\u00f3s um n\u00famero m\u00e1ximo de tentativas.\nUse fun\u00e7\u00f5es para organizar o c\u00f3digo.\nEscreva testes para garantir que o jogo funcione corretamente.\n</code></pre> <p>Exerc\u00edcio 4: Simulador de Compras com Crate Rust Money</p> <p>Crie um simulador de compras em que o jogador tem um or\u00e7amento limitado e deve fazer compras. Use o crate rust-money para representar valores monet\u00e1rios. O jogo deve incluir as seguintes funcionalidades:</p> <pre><code>Instale o crate rust-money para lidar com valores monet\u00e1rios.\nUse vari\u00e1veis mut\u00e1veis para rastrear o or\u00e7amento do jogador e o custo dos itens.\nUse loops para permitir que o jogador fa\u00e7a v\u00e1rias compras.\nUse if e match para verificar se o jogador pode pagar por um item e atualizar o or\u00e7amento.\nUse a macro println! para exibir informa\u00e7\u00f5es sobre as compras.\n</code></pre>"},{"location":"1_3_jogo_blackjack/","title":"Blackjack","text":""},{"location":"1_3_jogo_blackjack/#raio-x-blackjack","title":"Raio X Blackjack","text":""},{"location":"1_3_jogo_blackjack/#mecanicas-do-jogo","title":"Mec\u00e2nicas do jogo:","text":"<p>Obter uma m\u00e3o com um valor total mais pr\u00f3ximo poss\u00edvel de 21, sem ultrapassar esse valor. O Jogador e o dealer recebem duas cartas no in\u00edcio. O jogador decide entre \"pedir\" (receber uma carta) ou \"ficar\" (manter a m\u00e3o atual). Se o valor da m\u00e3o do jogador ultrapassar 21, ele perde automaticamente. Ap\u00f3s a vez do jogador, o dealer revela sua segunda carta. O dealer deve continuar a pedir cartas at\u00e9 que a m\u00e3o alcance pelo menos 17 pontos. Se a m\u00e3o do jogador ultrapassar 21, ele perde automaticamente. Se o dealer ultrapassar 21, o jogador vence. Se nenhum dos jogadores ultrapassar 21, o vencedor \u00e9 aquele com a m\u00e3o mais pr\u00f3xima de 21.</p>"},{"location":"1_3_jogo_blackjack/#atualizando-o-rust","title":"Atualizando o rust","text":"<p>Bom antes de come\u00e7armos nosso jogo vamos fazer novamente a atualiza\u00e7\u00e3o do rust:</p> <pre><code>rustup update stable\n</code></pre> <p>Criando projeto</p> <p>Bom vamos criar nosso novo projeto em projects:</p> <pre><code>cargo new blackjack\ncd blackjack\n</code></pre> <p>Para criar esse projeto vamos entender melhor como vamos estruturar nosso jogo.</p>"},{"location":"1_3_jogo_blackjack/#estruturando-o-blackjack","title":"Estruturando o blackjack","text":"<p>Para esse jogo queremos fazer uma mudan\u00e7a em como nosso jogo vai se comportar: - main.rs vai ter nosso loop b\u00e1sico do jogo e vamos iniciar nossa fun\u00e7\u00e3o game. - Nossa fun\u00e7\u00e3o game vai ser respons\u00e1vel por administrar todos os elementos do jogo e a   l\u00f3gica do jogo em si - Vamos ter uma fun\u00e7\u00e3o para criar uma carta - Vamos ter que ter uma estrutura para criar um baralho - Vamos ter que ter uma estrutura para gerenciar a hierarquias das cartas Ex: Valete, Rainha e Rei val\u00e9m 10 pontos e \u00e0s vale 1 ou 11.</p> <p>Assim para manter o c\u00f3digo mais organizado vamos separar algumas responsabilidades em arquivos separados para isso vamos ter que come\u00e7ar a usar m\u00f3dulos.</p>"},{"location":"1_3_jogo_blackjack/#modulos","title":"M\u00f3dulos","text":"<p>M\u00f3dulos s\u00e3o estruturas que usamos para agrupar fun\u00e7\u00f5es, vari\u00e1veis, contantes e outras estruturas de dados em um bloco e voc\u00ea deve se perguntar por que dever\u00edamos fazer isso? Respondendo sua pergunta n\u00f3s normalmente criamos m\u00f3dulos para: - Melhorar a organiza\u00e7\u00e3o do nosso c\u00f3digo seja por funcionalidades ou pelo fato da base de c\u00f3digo ser muito grande. - Se nossa base de c\u00f3digo pode ser reutilizado em outros pontos do seu projeto - Separar responsabilidade por exemplo podemos criar m\u00f3dulos espec\u00edficos para testes da nossa base de c\u00f3digo.</p> <p>Para criar um m\u00f3dulo usamos a palavra reservada <code>mod</code></p> <pre><code>mod meu_modulo {\n    fn imprime_nome(nome: &amp;str) -&gt; String {\n        format!(\"Ol\u00e1, {}!\", name)\n    }\n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#visibilidade-de-codigo","title":"Visibilidade de c\u00f3digo","text":"<p>Quando trabalhamos com c\u00f3digo em determinas linguagens podemos atribuir quando determinadas fun\u00e7\u00f5es e atributos s\u00e3o poss\u00edveis ou n\u00e3o de serem lidos, assim como quem pode visualizar. Para facilitar o entendimento vamos fazer uma analogia.</p>"},{"location":"1_3_jogo_blackjack/#casinha","title":"Casinha","text":"<p>Pense numa casa, ela pode ser uma casinha no interior, ou um casar\u00e3o numa grande cidade n\u00e3o importa, normalmente uma casa \u00e9 composta por c\u00f4modos umas tem muitos outras tem poucos.</p> <p>No mundo do c\u00f3digo uma biblioteca a qual chamamos de crates, mas tamb\u00e9m pensando num contexto maior nossa casa pode ser nosso projeto como esse blackjack que estamos desenvolvendo.</p> <p>Cada c\u00f4modo dessa casa ser\u00e1 nossos m\u00f3dulos dependendo da biblioteca ou projeto pode ter muitos ou poucos.</p> <p>Todas as nossas estruturas, vari\u00e1veis, constantes, fun\u00e7\u00f5es e etc. Ser\u00e3o os itens que temos no nosso m\u00f3dulo, assim como uma casa comum a cozinha vai ter itens que correspondem a cozinha e no banheiro v\u00e3o ter itens que correspondem a um banheiro. Nessa mesma linha vamos ter itens no nosso m\u00f3dulo que correspondem ao que aquele m\u00f3dulo representa.</p>"},{"location":"1_3_jogo_blackjack/#acesso-a-casinha","title":"Acesso a casinha","text":"<p>Pensando em visibilidade voc\u00ea pode ser a \u00fanica pessoa na casa que tem a chave do banheiro da casa, se por padr\u00e3o nessa casa quem tem a chave sempre a mant\u00e9m trancada por padr\u00e3o, isso quer dizer que ningu\u00e9m al\u00e9m de voc\u00ea vai ter acesso aquele c\u00f4modo. Levando isso pro Rust cada m\u00f3dulo por padr\u00e3o ter\u00e1 todos os seus itens privados ent\u00e3o ningu\u00e9m de outros c\u00f4modos poder\u00e1 acessar o banheiro. Isso quer dizer que se criarmos um m\u00f3dulo no nosso arquivo <code>main.rs</code> quem est\u00e1 dentro do arquivo ainda consegue acessar o m\u00f3dulo pois est\u00e3o no mesmo \"c\u00f4modo\".</p> <p>Mas, temos uma pegadinha nesse exemplo, pois mesmo vendo que est\u00e1 dentro do banheiro ele n\u00e3o pode usar! Pense que voc\u00ea tem um amigo que precisa usar o banheiro mas, h\u00e1 um poder maior impedindo seu amigo de usa-lo e caso ele precise fazer o n\u00famero 2 no assento sanit\u00e1rio e mesmo que ele enxergue o banheiro (m\u00f3dulo) n\u00e3o consegue fazer a a\u00e7\u00e3o de usar o assento (fun\u00e7\u00e3o) um cen\u00e1rio terr\u00edvel n\u00e3o? Mas isso tem solu\u00e7\u00e3o voc\u00ea pode deixa-lo como p\u00fablico usando a palavra reservada <code>pub</code> e assim ele ficar\u00e1 feliz e aliviado.</p> <pre><code>//casinha.rs\n\nmod banheiro {\n     pub const ROLO_PAPEL_INICIAL: i16 = 5; \n     const MINHA_ESCOVA: String = String::new();\n\n    pub fn usa_assento_sanitario() -&gt; i16 {\n        let mut rolo_papel: i16 = ROLO_PAPEL_INICIAL;\n        println!(\"Usando rolo!\");\n        rolo_papel -= 1;\n        rolo_papel\n    }\n\n\n}\n\nfn main() {\n    println!(\"{}\", banheiro::ROLO_PAPEL_INICIAL);\n    banheiro::usa_assento_sanitario();\n}\n</code></pre> <p>Deixando de lado a inutilidade do c\u00f3digo, se seu amigo for a representa\u00e7\u00e3o da fun\u00e7\u00e3o main, ele consegue ver o rolo de papel e consegue usar o <code>assento_sanit\u00e1rio</code>, por\u00e9m ele n\u00e3o consegue acessar a sua escova de dentes por que ela n\u00e3o \u00e9 p\u00fablica.</p> <p>Mas e se caso eu queira que pessoas de outros c\u00f4modos possam usar o banheiro? F\u00e1cil s\u00f3 deixar ele aberto, ou seja, deixar o m\u00f3dulo p\u00fablico assim todos podem usa-lo.</p> <pre><code>\n// banheiro.rs\n\npub mod banheiro {\n     pub const ROLO_PAPEL_INICIAL: i16 = 5; \n     const MINHA_ESCOVA: String = String::new();\n\n    pub fn usa_assento_sanitario() -&gt; i16 {\n        let mut rolo_papel: i16 = ROLO_PAPEL_INICIAL;\n        println!(\"Usando rolo!\");\n        rolo_papel -= 1;\n        rolo_papel\n    }\n\n}\n\n</code></pre> <p>Assim se a sala for nosso c\u00f4modo principal (main).</p> <pre><code>mod banheiro;\n\nfn main() {\n    println!(\"{}\", banheiro::banheiro::ROLO_PAPEL_INICIAL);\n    banheiro::banheiro::usa_assento_sanitario();\n}\n</code></pre> <p>Importante ressaltar que nesse caso <code>mod banheiro</code> eu fa\u00e7o refer\u00eancia ao arquivo <code>banheiro.rs</code> assim para acessar o m\u00f3dulo dentro do arquivo (que tamb\u00e9m \u00e9 um m\u00f3dulo) preciso chama-lo novamente ou seja <code>banheiro::banheiro</code>. Para facilitar o entendimento vamos pensar que nesse exemplo o assento vai ser um m\u00f3dulo tamb\u00e9m j\u00e1 o papel vai ser um item que est\u00e1 fora assim para usar o banheiro preciso acessar o papel que est\u00e1 no banheiro e depois acessar o assento e a fun\u00e7\u00e3o dele de usar.</p> <pre><code>\n//banheiro.rs\n\npub const ROLO_PAPEL_INICIAL: i16 = 5; \nconst MINHA_ESCOVA: String = String::new();\n\npub mod assento_sanitario {\n\n    pub fn usar(rolo_inicial: i16) -&gt; i16 {\n        let mut rolo_papel: i16 = rolo_inicial;\n        println!(\"Usando rolo!\");\n        rolo_papel -= 1;\n        rolo_papel\n    }\n\n}\n</code></pre> <pre><code>//main.rs\nmod banheiro;\n\nfn main() {\n    println!(\"{}\", banheiro::ROLO_PAPEL_INICIAL);\n    banheiro::assento_sanitario::usar(banheiro::ROLO_PAPEL_INICIAL);\n}\n</code></pre> <p>Acredito que agora ficou mais claro, dentro do meu arquivo <code>banheiro.rs</code> que \u00e9 um m\u00f3dulo eu acesso o outro m\u00f3dulo que \u00e9 o <code>assento_sanitario</code>, perceba que nesse exemplo voc\u00ea tem acesso ao m\u00f3dulo banheiro e assento e tem acesso ao rolo de papel mas, ainda n\u00e3o tem acesso a escova pois ela ainda \u00e9 privada.</p> <p>Tamb\u00e9m poderia ter usado a fun\u00e7\u00e3o usar direto no banheiro n\u00e3o preciso for\u00e7ar a criar um m\u00f3dulo dentro do arquivo, ai vai muito da sua necessidade.</p> <p>Esse exemplo do banheiro era o melhor? Talvez n\u00e3o, mas acredito que com isso eu consiga te dar uma clareza de como funciona a din\u00e2mica dos m\u00f3dulos dentro do rust. Agora finalmente podemos continuar nosso jogo.</p>"},{"location":"1_3_jogo_blackjack/#criando-o-looping-principal-do-jogo","title":"Criando o looping principal do jogo","text":"<p>Bom agora vamos criar nossa main para isso vamos criar um loop.</p> <pre><code>fn main() {\n    loop {\n        game::game_start()\n    }\n}\n</code></pre> <p>Ainda n\u00e3o temos o nosso m\u00f3dulo game ent\u00e3o vamos criar em no nosso diret\u00f3rio <code>src</code> o m\u00f3dulo game.</p> <pre><code>touch src/game.rs\n</code></pre> <p>Agora dentro de game vamos criar alguns prints para mostrar o total da m\u00e3o do jogador e do dealer.</p> <pre><code>//game.rust\n\npub fn game_start() {\n    println!(\"Dealer's hand:\");\n    println!(\"Total value: 0\");\n\n    println!(\"Your hand:\");\n    println!(\"Total value: 0\")\n\n}\n</code></pre> <p>Ainda precisamos importar o m\u00f3dulo no nosso <code>main.rs</code>.</p> <pre><code>mod game;\n\nfn main() {\n    loop {\n        game::game_start()\n    }\n}\n</code></pre> <p>Vamos rodar nosso projeto. Percebemos que ele vai rodar infinitamente ent\u00e3o vamos aprimorar nosso menu para iniciar um jogo.</p> <pre><code>mod game;\n\nfn main() {\n    loop {\n        println!(\"Start game? (y)es or (n)o\");\n        let mut option = String::new();\n        std::io::stdin().read_line(&amp;mut option).unwrap();\n        match option.trim().to_lowercase().as_str() {\n            \"y\" =&gt; {\n                game::game_start();\n                continue;\n            }\n            \"n\" =&gt; {\n                println!(\"Thank you playing.\");\n                break;\n            }\n            _ =&gt; {\n                continue;\n            }\n\n        }\n\n    }\n}\n</code></pre> <p>Certo agora nosso jogo tem um loop b\u00e1sico e toda vez que o nosso jogo acabar <code>game_start</code> se encerra e assim votamos ao menu principal do jogo.</p>"},{"location":"1_3_jogo_blackjack/#representando-uma-carta-com-naipes-e-valores","title":"Representando uma carta com naipes e valores","text":"<p>Vamos criar um novo m\u00f3dulo chamado card, esse m\u00f3dulo vai ser respons\u00e1vel em criar uma representa\u00e7\u00e3o do card no nosso c\u00f3digo. Ent\u00e3o vamos criar um arquivo chamado <code>card.rs</code>.</p> <pre><code>touch src/card.rs\n</code></pre> <p>Dentro do nosso arquivo <code>card.rs</code> vamos criar um m\u00f3dulo chamado test.</p> <pre><code>\n#[cfg(test)]\nmod test {\n    use super::*;\n\n}\n\n</code></pre> <p><code>#[cfg(test)]</code> chamamos de anota\u00e7\u00f5es (annotation) no caso essa em especifico estou especificando para o compilador do rust que esse m\u00f3dulo s\u00f3 precisa ser executado em teste.</p> <p>Agora dentro do nosso m\u00f3dulo usamos o <code>use super::*;</code> que \u00e9 necess\u00e1rio para pode usar as estruturas dentro do nosso m\u00f3dulo <code>card.rs</code>.</p> <p>Agora vamos criar nosso primeiro teste. Onde vamos passar uma carta e verificar se o valor da carta. Sendo que nossa carta precisa ter seu valor e seu naipe. Onde o valor vamos chamar de rank e o naipe vamos chamar de suit. Ou seja nosso card tem 2 valores por hora vamos s\u00f3 anotar aqui. Um ponto importante \u00e9 que para realizar o teste vamos criar uma string para corresponder o naipe de \"cora\u00e7\u00e3o\" para isso vamos precisar criar uma String <code>hearts</code>.</p> <pre><code>\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_get_card_rank() {\n        let hearts = String::from(\"Hearts\");\n        let value = Card {rank: 10, suit: hearts.clone() };\n\n        assert_eq!(value.rank, 10);\n        assert_eq!(value.suit, hearts)\n    }\n}\n</code></pre> <p>Estou usando em hearts a palavra reservada clone, pois nesse contexto quando crio o <code>Card</code> eu preciso usar o <code>clone</code>, por que sen\u00e3o eu passo a refer\u00eancia do hearts para o card, ent\u00e3o o clone \u00e9 necess\u00e1rio para poder testarmos abaixo. Agora vamos rodar nosso teste.</p> <pre><code>cargo test\n</code></pre> <p>Nosso resultado mostra que n\u00e3o teve nenhum teste executado, por que isso aconteceu?</p> <p>Para que nosso teste seja executado precisamos chamar nosso modulo card no main.</p> <pre><code>mod game;\nmod card;\n\n</code></pre> <p>Agora nosso teste roda por\u00e9m temos o erro abaixo:</p> <pre><code>error[E0425]: cannot find function, tuple struct or tuple variant `Card` in this scope\n --&gt; src/card.rs:8:21\n  |\n8 |         let value = Card { rank: 10, suit: hearts.clone() };\n  |                     ^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\n</code></pre> <p>Card n\u00e3o existe ainda ent\u00e3o precisamos criar, e como criar uma estrutura pra representar rank e suit ? Precisamos criar uma <code>struct</code>.</p>"},{"location":"1_3_jogo_blackjack/#structs","title":"Structs","text":"<p>Anteriormente falamos dos tipos primitivos, caso n\u00e3o se lembre volte na parte de [[tipos primitivos em rust]]. H\u00e1 formas de criarmos nossos pr\u00f3prios tipos em rust que chamamos de [[tipos customizados - avan\u00e7ados]], por\u00e9m nesse momento o valor de Card vai ser a composi\u00e7\u00e3o de 2 tipos primitivos que \u00e9 o rank que \u00e9 o valor da carta e o suit que ser\u00e1 o naipe da carta.</p> <p>Se precisarmos de uma vari\u00e1vel composta por 2 ou mais valores vamos usar um tipo de dados chamado <code>_Struct_</code>.</p> <p><code>**Struct**</code> ou structure \u00e9 um tipo de dado customizado onde ele \u00e9 composto de v\u00e1rios tipos de dados, ou seja \u00e9 uma representa\u00e7\u00e3o de agrupamentos de dados.</p>"},{"location":"1_3_jogo_blackjack/#definindo-uma-struct","title":"Definindo uma <code>struct</code>","text":"<p>Para definir uma <code>struct</code> precisamos apenas usar a palavra reserva <code>struct</code>.</p> <pre><code>struct Card;\n</code></pre> <p>Agora inicialmente vamos colocar os campos <code>rank</code> e <code>suit</code>.</p> <pre><code>struct Card {\n    rank: i32,\n    suit: String,\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_get_card_rank() {\n        let hearts = String::from(\"Hearts\");\n        let value = Card { rank: 10, suit: hearts.clone() };\n\n        assert_eq!(value.rank, 10);\n        assert_eq!(value.suit, hearts)\n    }\n}\n</code></pre> <p>Agora vamos rodar ele.</p> <pre><code>\u279c cargo test\n   Compiling blackjack v0.1.0 (/home/feanor/projects/blackjack)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running unittests src/main.rs (target/debug/deps/blackjack-eab3321ecfe99072)\n\nrunning 1 test\ntest card::test::test_get_card_rank ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Tudo certo agora passou.</p>"},{"location":"1_3_jogo_blackjack/#naipes","title":"Naipes","text":"<p>Agora vamos mudar um pouco, nosso naipe \u00e9 uma <code>String</code> simples, mas teremos repetidamente os 4 naipes: espadas, ouros, copas e paus.</p> <p>Ent\u00e3o vamos mudar nosso naipe para se tornar um <code>enum</code>.</p> <pre><code>#[derive(Debug, PartialEq)]\nenum Suit {\n    Hearts,\n    Diamonds,\n    Clubs,\n    Spades,\n}\n\nstruct Card {\n    rank: i32,\n    suit: Suit,\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_get_card_rank_and_suit() {\n        let value = Card { rank: 10, suit: Suit::Hearts };\n\n        assert_eq!(value.rank, 10);\n        assert_eq!(value.suit, Suit::Hearts )\n    }\n}\n</code></pre> <p>Importante como estamos usando uma <code>Struct</code>com um  <code>enum</code> ele n\u00e3o implementa algumas coisas, por isso inicialmente precisamos usar duas trait a <code>Debug</code> e a <code>PartialEq</code>. Isso \u00e9 necess\u00e1rio para podermos fazer a compara\u00e7\u00e3o no nosso teste com a macro <code>assert_eq!</code>. Agora temos a representa\u00e7\u00e3o dos valores do Naipe e do Valor.</p>"},{"location":"1_3_jogo_blackjack/#construindo-um-baralho","title":"Construindo um baralho","text":"<p>Certo agora que temos como representar o valor e o naipe da nossa carta vamos criar um m\u00f3dulo chamado <code>Deck</code> onde vai representar nosso baralho.</p> <pre><code>touch deck.rs\n</code></pre> <p>Agora vamos criar um tipo de vari\u00e1vel que ainda n\u00e3o t\u00ednhamos usados que \u00e9 o Vetor <code>Vec</code>.</p>"},{"location":"1_3_jogo_blackjack/#tipos-basicos-de-dados","title":"Tipos b\u00e1sicos de dados","text":"<p>[[tipos primitivos em rust]]</p> <p>Bom refor\u00e7ando a parte que falamos de tipos de rust no nosso primeiro jogo, agora vamos aprofundar um pouco mais. Cada valor em rust tem um tipo especifico, as vezes preciso anotar diretamente, as vezes ele consegue saber o tipo diretamente o que chamamos de infer\u00eancia. Mesmo assim, rust \u00e9 uma linguagem de <code>tipagem est\u00e1tica</code> ou seja ele precisa saber todos os tipos em tempo de compila\u00e7\u00e3o.</p>"},{"location":"1_3_jogo_blackjack/#tipos-escalares","title":"Tipos escalares","text":"<p>S\u00e3o os tipos que representam um valor \u00fanico, j\u00e1 falamos sobre eles no primeiro jogo da [[Misterious Forest]] e s\u00e3o eles: inteiros, float, <code>booleans</code> e <code>characteres</code>.</p>"},{"location":"1_3_jogo_blackjack/#integer-types","title":"Integer Types","text":"<p>Um integer a grosso modo \u00e9 um n\u00famero sem casas decimais ou seja um numero INTEIRO. Sendo que o tamanho do n\u00famero que ele comporta varia de acordo com seu tipo e se ele aceita n\u00fameros negativos (Signed) conforme a tabela abaixo:</p> Length Signed range Unsigned range 8-bit <code>i8</code> -128 a 127 <code>u8</code> 0 a 255 16-bit <code>i16</code> -32.768 a 32.767 <code>u16</code> 0 a 65.535 32-bit <code>i32</code> -2.147.483.648 a 2.147.483.647 <code>u32</code> 0 a 4.294.967.295 64-bit <code>i64</code> -9.223.372.036.854.775.808 a 9.223.372.036.775.807 <code>u64</code> 0 a 18.446.744.073.709.551.615 128-bit <code>i128</code> -170.141.183.460.469.231.731.687.303.715.884.105.728 a 170.141.183.460.469.231.731.687.303.715.884.105.727 <code>u128</code> 0 a 340.282.366.920.938.463.463.374.607.431.768.211.455 arch <code>isize</code> - <code>usize</code> - Refor\u00e7ando que quando criamos um inteiro com sinal (Signed) ele vai aceitar n\u00fameros negativos e n\u00fameros sem sinal (Unsigned) vai aceitar apenas n\u00fameros positivos, por\u00e9m poder\u00e1 representar n\u00fameros maiores. <p>No caso dos tipos <code>isize</code> e <code>usize</code> s\u00e3o tipos especiais pois eles v\u00e3o depender da arquitetura do computador sendo 64 bits se for uma <code>arch-64</code> e 32 bits se for uma <code>arch-32</code>.</p> <p>H\u00e1 outras formas tamb\u00e9m de escrever inteiros literais. Conforme a tabela abaixo s\u00f3 quero destacar que n\u00fameros muito grandes podemos separar com underscore <code>_</code> para facilitar a visualiza\u00e7\u00e3o.</p> Number literals Example Decimal <code>98_222</code> Hex <code>0xff</code> Octal <code>0o77</code> Binary <code>0b1111_0000</code> Byte (<code>u8</code> only) <code>b'A'</code>"},{"location":"1_3_jogo_blackjack/#integer-overflow","title":"Integer Overflow","text":"<p>Se voc\u00ea criar uma vari\u00e1vel do tipo <code>u8</code> que tem uma range de 0 a 255 e tentar atribuir a ela o n\u00famero 256, voc\u00ea ter\u00e1 um integer overflow, o Rust durante a compila\u00e7\u00e3o far\u00e1 a verifica\u00e7\u00e3o dos tipos e identificar\u00e1 que esse atributo est\u00e1 recebendo um valor n\u00e3o comportado e dar\u00e1 um erro. No caso de tempo de execu\u00e7\u00e3o se isso ocorrer ele lan\u00e7ara um erro chamado <code>panic</code> do qual veremos com mais detalhe mais a frente.</p> <pre><code>fn main() {\n\n    let fuel: i32 = 1_000_000_000;\n    let oxygen: u32 = 2_000_000_000;unidades.\n    let mut food: i16 = 32_767;\n    let auxiliary_ships: u8 = 255;\n    let crew_size: isize = 128;\n    let galactic_resources: u128 = 10_000_000_000_000_000; \n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#floating-point-types","title":"Floating-Point Types","text":"<p>Como j\u00e1 vimos temos dois primitivos de ponto flutuante o <code>f32</code> e o <code>f64</code> com 32 bits e 64 bits respectivamente.</p> <p>Aqui temos um exemplo usando um <code>f32</code>:</p> <pre><code>// src/main.rs\nfn main() {\n    let mut distance_to_target: f64 = 0.5;\n    let mut speed: f32 = 0.01;\n    let gravity: f64 = 3.711;\n    let mut fuel: f32 = 100.0;\n    let fuel_consumption_rate: f32 = 0.5;\n}\n</code></pre> <p>N\u00fameros de ponto flutuante seguem o padr\u00e3o <code>IEEE-754</code>. Sendo o <code>f32</code> de precis\u00e3o simples e o <code>f64</code> de precis\u00e3o dupla.</p>"},{"location":"1_3_jogo_blackjack/#operacoes-numericas","title":"Opera\u00e7\u00f5es num\u00e9ricas","text":"<p>O Rust suporta todas as opera\u00e7\u00f5es mais elementares da matem\u00e1tica, al\u00e9m disso podemos atribuir uma vari\u00e1vel let com o valor de uma opera\u00e7\u00e3o matem\u00e1tica.</p> <pre><code>// src/main.rs\nfn main() {\n    // Adi\u00e7\u00e3o\n    let sword_damage = 25;\n    let fire_spell_damage = 50;\n    let total_damage = sword_damage + fire_spell_damage;\n    println!(\"Dano total causado ao inimigo: {}\", total_damage);\n\n    // Subtra\u00e7\u00e3o\n    let player_health = 100.0;\n    let enemy_attack_damage = 34.5;\n    let remaining_health = player_health - enemy_attack_damage;\n    println!(\"Vida restante do jogador: {:.1}\", remaining_health);\n\n    // Multiplica\u00e7\u00e3o\n    let experience_per_enemy = 200;\n    let enemies_defeated = 3;\n    let total_experience = experience_per_enemy * enemies_defeated;\n    println!(\"Experi\u00eancia total obtida: {}\", total_experience);\n\n    // Divis\u00e3o\n    let total_gold = 120.0;\n    let party_members = 4.0;\n    let gold_per_member = total_gold / party_members;\n    println!(\"Cada membro recebeu {:.2} moedas de ouro.\", gold_per_member);\n\n    // M\u00f3dulo\n    let potions = 17;\n    let potions_per_member = 4;\n    let leftover_potions = potions % potions_per_member;\n    println!(\"Po\u00e7\u00f5es restantes ap\u00f3s a divis\u00e3o: {}\", leftover_potions);\n}\n\n</code></pre>"},{"location":"1_3_jogo_blackjack/#the-boolean-type","title":"The Boolean Type","text":"<p>Temos o tipo primitivo boolean que serve para verificarmos se a express\u00e3o ou vari\u00e1vel \u00e9 verdadeira ou falsa.</p> <pre><code>// src/main.rs\nfn main() {\n\n    let is_door_locked: bool = false;\n    println!(\"A porta est\u00e1 trancada? {}\", is_door_locked);\n\n    let has_key = true;\n    let can_open_door = is_door_locked &amp;&amp; has_key;\n\n    println!(\"O jogador pode abrir a porta? {}\", can_open_door);\n}\n</code></pre> <p>Booleano s\u00e3o boas escolhas quando queremos validar uma condi\u00e7\u00e3o de uma estrutura condicional como os <code>if</code>e <code>match</code>.</p>"},{"location":"1_3_jogo_blackjack/#tipo-charactere","title":"Tipo <code>Charactere</code>","text":"<p>O char \u00e9 o tipo primitivo mais simples para representar um <code>caracter</code>  em rust.</p> <pre><code>// src/main.rs\nfn main() {\n    let player_initial = 'A';\n\n    let rare_item: char = '\u2694';\n    let clan_emblem = '\ud83d\udc09';\n    let clan_name = '\u9f8d';\n    let enemy = '\ud83d\udc7e';\n}\n\n</code></pre> <p>Uma coisa importante \u00e9 que char representamos com aspas simples, sendo aspas duplas para representar um conjunto de caracteres ou strings se preferir.</p> <p>Em rust um caractere consegue representar um character da tabela Unicode dando muita flexibilidade pois podemos representar caracteres como emojis e caracteres em l\u00ednguas como o Japon\u00eas e o Coreano.</p>"},{"location":"1_3_jogo_blackjack/#tipos-compostos","title":"Tipos compostos","text":"<p>Tipos compostos podem agrupar um conjunto de elementos de um tipo (ou v\u00e1rios) no caso de rust temos dois primitivos que ainda n\u00e3o vimos que s\u00e3o os arrays e tuplas.</p>"},{"location":"1_3_jogo_blackjack/#tipo-tupla","title":"Tipo tupla","text":"<p>A tupla \u00e9 um agrupamento especial pois uma vez declarada ela n\u00e3o muda seu tamanho ou seus elementos.</p> <p>Para criar uma tupla n\u00f3s colocamos valores entre parenteses e separados por virgula.</p> <pre><code>// src/main.rs\nfn main() {\n    let item: (i32, f64, u8) = (500, 6.4, 1);\n}\n</code></pre> <p>A vari\u00e1vel <code>tup</code> foi declarado os tipos dentro dela, mas a tupla tamb\u00e9m consegue fazer a infer\u00eancia do tipo sozinha pois a tupla em si \u00e9 considerada um elemento j\u00e1. Se quisermos pegar os valores fora da tupla podemos usar a desestrutura\u00e7\u00e3o conforme o exemplo abaixo.</p> <pre><code>// src/main.rs\nfn main() {\n    let item: (i32, f64, u8) = (500, 6.4, 1);\n\n    // Desestrutura\u00e7\u00e3o para obter os valores\n    let (price, weight, rarity) = item;\n\n    println!(\"Detalhes do item:\");\n    println!(\"Pre\u00e7o: {} moedas\", price);\n    println!(\"Peso: {:.1} kg\", weight);\n    println!(\"Raridade: {} (quanto menor, mais raro)\", rarity);            \n}\n</code></pre> <p>No exemplo acima declaramos nossa tupla <code>tup</code> e desestruturamos ela em 3 vari\u00e1veis para representar os 3 elementos dentro da tupla.</p> <p>Podemos tamb\u00e9m acessar diretamente da tupla, passando o \u00edndice do elemento que queremos conforme abaixo:</p> <pre><code>// src/main.rs\nfn main() {\n    let item: (i32, f64, u8) = (500, 6.4, 1);\n\n    let (price, weight, rarity) = item;\n\n    println!(\"Detalhes do item:\");\n    println!(\"Pre\u00e7o: {} moedas\", price);\n    println!(\"Peso: {:.1} kg\", weight);\n    println!(\"Raridade: {} (quanto menor, mais raro)\", rarity);\n\n    println!(\n        \"Resumo: {} moedas, {:.1} kg, raridade {}.\",\n        item.0, item.1, item.2\n    );\n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#o-tipo-array","title":"O tipo array","text":"<p>Outro tipo que podemos ter uma representa\u00e7\u00e3o de v\u00e1rios elementos \u00e9 o <code>array</code>. Ao contr\u00e1rio da tupla um <code>array</code> precisa que todos os elementos sejam do mesmo tipo, e tamb\u00e9m um array tem um tamanho fixo.</p> <pre><code>// src/main.rs\nfn main() {\n    let recursos_planetas: [i32; 4] = [500, 700, 300, 450];\n}\n\n</code></pre> <p>Arrays s\u00e3o \u00fateis quando voc\u00ea quer elementos que n\u00e3o v\u00e3o mudar com o tempo. Por exemplo podemos fazer um array para representar os meses do ano.</p> <pre><code>let months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n</code></pre> <p>Voc\u00ea escreve um array usando colchetes com o tipo do elemento + ponto e virgula + n\u00famero de elementos.</p> <pre><code>let recursos_planetas: [i32; 5] = [500, 700, 300, 450, 900];\n</code></pre> <p>Aqui representamos um array do tipo <code>i32</code> com 5 elementos.</p> <p>Tamb\u00e9m podemos inciar um array com um valor inicial como abaixo.</p> <pre><code>let energia_inicial = [100; 6];\n</code></pre> <p>Aqui o array a tem 6 elementos e todos come\u00e7am com o valor 3 ou seja seria a mesma coisa que fazer <code>let energia_inicial = [100, 100, 100, 100, 100, 100];</code> mas, de uma forma mais concisa.</p>"},{"location":"1_3_jogo_blackjack/#acessando-elementos-de-um-array","title":"Acessando elementos de um array","text":"<p>Um array \u00e9 um elemento que tem seu tamo fixo e conhecido e pode ser alocado na mem\u00f3ria stack, podemos acessar um array pelo seu \u00edndice entre colchetes como o exemplo abaixo.</p> <pre><code>// src/main.rs\nfn main() {\n    let pontuacoes = [1000, 2000, 1500, 2500];\n\n    let maior_pontuacao = pontuacoes[3];\n    let segunda_pontuacao = pontuacoes[1];\n\n    println!(\"A maior pontua\u00e7\u00e3o foi {}!\", maior_pontuacao);\n}\n\n</code></pre> <p>I##### Tentando acessar um elemento n\u00e3o existente</p> <p>O \u00edndice em rust come\u00e7a com 0 ent\u00e3o no exemplo anterior temos um \u00edndice que vai de 0 at\u00e9 4 ent\u00e3o se tentarmos acessar o \u00edndice 5 ou 10 nesse array vamos ter o erro baixo:</p> <pre><code>thread 'main' panicked at src/main.rs:19:19:\nindex out of bounds: the len is 5 but the index is 10\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Como falado anteriormente quando acessamos um elemento que n\u00e3o existe o programa vai lan\u00e7ar um <code>panic</code> informando o erro.</p>"},{"location":"1_3_jogo_blackjack/#usando-vetores","title":"Usando vetores","text":"<p>O primeiro tipo de cole\u00e7\u00e3o que vamos explorar \u00e9 o <code>Vec&lt;T&gt;</code>, tamb\u00e9m conhecido como vetor. Vetores permitem armazenar mais de um valor em uma \u00fanica estrutura de dados, colocando todos os valores em sequ\u00eancia na mem\u00f3ria. Os vetores podem armazenar apenas valores do mesmo tipo, e s\u00e3o \u00fateis quando voc\u00ea tem uma lista de itens, como os pontos de vida de jogadores, armas ou inimigos em um jogo. Criando um Novo Vetor</p> <p>Para criar um novo vetor vazio, usamos a fun\u00e7\u00e3o <code>Vec::new</code>, como mostrado no exemplo abaixo.</p> <pre><code>let v: Vec&lt;i32&gt; = Vec::new();\n</code></pre> <p>Exemplo: Criando um vetor vazio para armazenar valores do tipo <code>i32</code>, que podem representar, por exemplo, pontos de vida dos personagens.</p> <p>Note que adicionamos uma anota\u00e7\u00e3o de tipo aqui. Como n\u00e3o estamos inserindo valores no vetor, o Rust n\u00e3o sabe que tipo de elementos pretendemos armazenar. Este \u00e9 um ponto importante. Vetores s\u00e3o implementados usando generics, e o tipo <code>**Vec&lt;T&gt;**</code> pode armazenar qualquer tipo. Neste exemplo, o <code>**Vec&lt;i32&gt;**</code> ir\u00e1 armazenar elementos do tipo inteiro <code>**i32**</code>.</p> <p>Na maioria das vezes, voc\u00ea criar\u00e1 um <code>**Vec&lt;T&gt;**</code> com valores iniciais, e o Rust pode inferir automaticamente o tipo dos valores que voc\u00ea quer armazenar, ent\u00e3o n\u00e3o \u00e9 necess\u00e1rio fazer a anota\u00e7\u00e3o de tipo. O Rust fornece o macro <code>**vec!**</code> que cria um vetor com os valores fornecidos. Veja o exemplo abaixo:</p> <pre><code>let v = vec![1, 2, 3];  // Criando um novo vetor com os valores 1, 2 e 3\n</code></pre> <p>Neste caso, como j\u00e1 fornecemos valores iniciais de tipo <code>i32</code>, o Rust pode inferir que o tipo do vetor \u00e9 <code>Vec&lt;i32&gt;</code>, e n\u00e3o \u00e9 necess\u00e1rio adicionar a anota\u00e7\u00e3o de tipo.</p>"},{"location":"1_3_jogo_blackjack/#atualizando-um-vetor","title":"Atualizando um Vetor","text":"<p>Para criar um vetor e adicionar elementos a ele, podemos usar o m\u00e9todo push, como mostrado no exemplo abaixo.</p> <pre><code>let mut v = Vec::new();  // Vetor mut\u00e1vel\n\nv.push(100);  // Adicionando pontos de vida\nv.push(150);  // Adicionando pontos de vida\nv.push(200);  // Adicionando pontos de vida\n\n</code></pre> <p>Aqui, como o vetor \u00e9 mut\u00e1vel <code>mut</code>, podemos adicionar novos elementos a ele. Se o vetor armazenasse as vidas de personagens em um jogo, poder\u00edamos adicionar os pontos de vida de diferentes inimigos ou her\u00f3is.</p>"},{"location":"1_3_jogo_blackjack/#lendo-elementos-de-um-vetor","title":"Lendo Elementos de um Vetor","text":"<p>Existem duas formas de acessar os valores armazenados em um vetor: via indexa\u00e7\u00e3o ou utilizando o m\u00e9todo get. Vamos ver ambos os m\u00e9todos de acesso no c\u00f3digo abaixo.</p> <pre><code>let v = vec![10, 20, 30, 40, 50];\n\n// Usando indexa\u00e7\u00e3o\nlet terceiro: &amp;i32 = &amp;v[2];  // Acessando o 3o valor (come\u00e7ando do \u00edndice 0)\nprintln!(\"O terceiro valor \u00e9 {terceiro}\");\n\n// Usando o m\u00e9todo get\nlet terceiro = v.get(2);\nmatch terceiro {\n    Some(valor) =&gt; println!(\"O terceiro valor \u00e9 {valor}\"),\n    None =&gt; println!(\"N\u00e3o existe um terceiro valor.\"),\n}\n\n</code></pre> <p>Aqui, acessamos o terceiro elemento do vetor <code>v</code> de duas formas: via indexa\u00e7\u00e3o e pelo m\u00e9todo <code>get</code>. A indexa\u00e7\u00e3o come\u00e7a do 0, por isso <code>v[2]</code> nos d\u00e1 o terceiro valor (30). J\u00e1 o m\u00e9todo <code>get</code> retorna um <code>Option&lt;&amp;T&gt;</code>, permitindo tratar casos em que o \u00edndice pode estar fora dos limites.</p>"},{"location":"1_3_jogo_blackjack/#tentando-acessar-um-indice-inexistente","title":"Tentando Acessar um \u00cdndice Inexistente","text":"<p>O c\u00f3digo abaixo tenta acessar um \u00edndice fora dos limites do vetor, o que pode gerar diferentes comportamentos dependendo do m\u00e9todo utilizado:</p> <pre><code>let v = vec![10, 20, 30, 40, 50];\n\n// Tentando acessar o \u00edndice 100\nlet nao_existe = &amp;v[100];  // Isso vai gerar um \"panic!\"\nlet nao_existe = v.get(100);  // Isso retorna \"None\"\n</code></pre> <p>Se voc\u00ea usar a indexa\u00e7\u00e3o <code>v[100]</code>, o programa ir\u00e1 gerar um panic porque o \u00edndice 100 est\u00e1 fora dos limites do vetor. No entanto, se usar o m\u00e9todo <code>get</code>, ele retornar\u00e1 None, e voc\u00ea pode tratar isso sem que o programa falhe.</p>"},{"location":"1_3_jogo_blackjack/#iterando-sobre-os-elementos-do-vetor","title":"Iterando sobre os Elementos do Vetor","text":"<p>Para acessar cada elemento do vetor, voc\u00ea pode iterar sobre os valores. Veja um exemplo de como imprimir todos os elementos de um vetor:</p> <pre><code>let v = vec![100, 200, 300];\nfor i in &amp;v {\n    println!(\"{i}\");\n}\n\n</code></pre> <p>Se voc\u00ea quiser modificar os elementos durante a itera\u00e7\u00e3o, pode usar refer\u00eancias mut\u00e1veis, como no exemplo abaixo:</p> <pre><code>let mut v = vec![100, 200, 300];\nfor i in &amp;mut v {\n    *i += 50;  // Aumentando a vida de cada personagem\n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#usando-um-enum-para-armazenar-tipos-diferentes-em-um-vetor","title":"Usando um Enum para Armazenar Tipos Diferentes em um Vetor","text":"<p>Os vetores em Rust podem armazenar apenas valores do mesmo tipo. No entanto, pode ser necess\u00e1rio armazenar elementos de tipos diferentes, como vidas de inimigos e itens no mesmo vetor. Para isso, podemos usar um <code>enum</code>. Por exemplo:</p> <pre><code>enum ItemJogo {\n    Vida(i32),\n    Arma(String),\n    Ouro(f64),\n}\n\nlet itens = vec![\n    ItemJogo::Vida(100),\n    ItemJogo::Arma(String::from(\"Espada\")),\n    ItemJogo::Ouro(500.75),\n];\n\n</code></pre> <p>Aqui, usamos um <code>enum</code> chamado <code>ItemJogo</code> para representar diferentes tipos de itens no jogo, como vida (um inteiro), arma (uma string) e ouro (um n\u00famero decimal). Esse vetor pode agora armazenar diferentes tipos de valores dentro de um mesmo vetor, desde que todos sejam variantes do <code>enum</code>.</p>"},{"location":"1_3_jogo_blackjack/#destruindo-um-vetor-ao-finalizar-o-jogo","title":"Destruindo um Vetor ao Finalizar o Jogo","text":"<p>Assim como qualquer outro <code>struct</code>, um vetor \u00e9 liberado da mem\u00f3ria quando sai de escopo. Isso significa que seus valores tamb\u00e9m s\u00e3o \"destru\u00eddos\" quando o vetor \u00e9 descartado.</p> <pre><code>{\n    let v = vec![10, 20, 30, 40];\n    // A\u00e7\u00f5es no jogo com o vetor\n} // &lt;- O vetor v sai de escopo aqui e \u00e9 descartado\n\n</code></pre> <p>Quando o vetor sai de escopo, ele libera todos os valores que estava armazenando, permitindo que a mem\u00f3ria seja limpa.</p> <p>Refer\u00eancia: Data Types</p>"},{"location":"1_3_jogo_blackjack/#definindo-o-baralho","title":"Definindo o baralho","text":"<p>Para criar o baralho precisamos usar um vetor <code>Vec</code> de cartas. Para isso precisamos criar uma fun\u00e7\u00e3o que retorne um baralho para o jogo. Vamos criar um teste que receba um baralho.</p> <pre><code>#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_create_deck() {\n\n        // Act\n        let mut deck = create_deck();\n\n    }\n\n}\n\n</code></pre> <p>Precisamos importar o m\u00f3dulo deck no nosso m\u00f3dulo main.</p> <pre><code>mod game;\nmod card;\nmod deck;\n\n</code></pre> <p>Agora rodamos e ter e recebemo o erro abaixo:</p> <pre><code>error[E0425]: cannot find function `create_deck` in this scope\n --&gt; src/deck.rs:9:24\n  |\n9 |         let mut deck = create_deck();\n  |                        ^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\n\n</code></pre> <p>Agora vamos criar a fun\u00e7\u00e3o <code>create_deck</code>. Nesse momento vamos fazer ela retornar um vetor <code>Vec</code> de Strings, n\u00e3o vamos colocar nossa <code>Struct</code> por que nosso objetivo \u00e9 fazer nosso teste passar.</p> <pre><code>fn create_deck() -&gt; Vec&lt;String&gt; {\n    let mut deck = Vec::new();\n    deck\n}\n\n</code></pre> <p>Agora vamos criar um setup e um assert pro nosso teste funcionar.</p> <pre><code>#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_create_deck() {\n        // Setup\n        let deck_compare: Vec&lt;String&gt; = Vec::new();\n\n        // Act\n        let mut deck = create_deck();\n\n        // Assert\n        assert_eq!(deck, deck_compare)\n\n    }\n\n}\n\n</code></pre> <p>Agora vamos rodar os testes.</p> <pre><code>running 2 tests\ntest card::test::test_get_card_rank_and_suit ... ok\ntest deck::test::test_create_deck ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Certo agora que o teste passou, n\u00f3s precisamos fazer com que o deck receba todas as cartas e naipes por conta disso vamos precisar voltar no nosso m\u00f3dulo card e criar uma sequ\u00eancia dos valores para facilitar a constru\u00e7\u00e3o autom\u00e1tica do deck. Para isso vamos dar um nome (em ingl\u00eas) para cada carta e usa-la na nossa <code>struct</code>.</p> <pre><code>enum Rank {\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace,\n}\n</code></pre> <p>Vamos adicionar agora Rank na nossa <code>struct</code> Card.</p> <pre><code>struct Card {\n    rank: Rank,\n    suit: Suit,\n}\n</code></pre> <p>Agora precisamos alterar nosso teste para receber um valor de Rank.</p> <pre><code>#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_get_card_rank_and_suit() {\n        let value = Card { rank: Rank::Ten, suit: Suit::Hearts };\n\n        assert_eq!(value.rank, Rank::Ten);\n        assert_eq!(value.suit, Suit::Hearts)\n    }\n}\n</code></pre> <p>Agora precisamos adicionar algumas traits no nosso Rank assim como fizemos no Suit</p> <pre><code>#[derive(Debug, PartialEq)]\nenum Rank {\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace,\n}\n</code></pre> <p>Vamos rodar nosso teste novamente.</p> <pre><code>--tests` to apply 2 suggestions)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.23s\n     Running unittests src/main.rs (target/debug/deps/blackjack-eab3321ecfe99072)\n\nrunning 2 tests\ntest card::test::test_get_card_rank_and_suit ... ok\ntest deck::test::test_create_deck ... ok\n</code></pre> <p>Certo nossos testes est\u00e3o rodando e agora temos uma estrutura para representar o valor da carta.</p>"},{"location":"1_3_jogo_blackjack/#adicionando-cartas-ao-deck","title":"Adicionando cartas ao deck","text":"<p>Pr\u00f3ximo passo agora \u00e9 adicionarmos as cartas ao baralho. Como revisamos anteriormente os tipos primitivos sabemos que pro baralho tanto a tupla quanto o array n\u00e3o v\u00e3o ajudar, ent\u00e3o vamos usar um novo tipo que \u00e9 o <code>Vec</code>.</p>"},{"location":"1_3_jogo_blackjack/#usando-vec","title":"Usando Vec","text":"<p>O tipo <code>Vec</code> em Rust representa um vetor, que \u00e9 uma estrutura de dados flex\u00edvel, muito \u00fatil no desenvolvimento de jogos para armazenar cole\u00e7\u00f5es de elementos de maneira eficiente e ordenada. Em jogos, precisamos frequentemente manipular conjuntos de dados que mudam dinamicamente, como listas de inimigos, proj\u00e9teis, ou at\u00e9 os elementos de interface gr\u00e1fica. \u00c9 aqui que o<code>Vec</code> brilha.</p> <p>O <code>Vec</code> n\u00e3o possui tamanho fixo ent\u00e3o podemos adicionar, remover e modificar os valores dentro dele, por\u00e9m ele tamb\u00e9m s\u00f3 pode receber valores do mesmo tipo, no nosso caso podemos usar nossa <code>struct</code> Card como o tipo.</p>"},{"location":"1_3_jogo_blackjack/#criando-o-deck","title":"Criando o deck","text":"<p>Vamos alterar nosso teste para receber agora um <code>Vec&lt;Card&gt;</code>e testar se ele vai ter o tamanho do baralho. Para isso vamos modificar o nosso teste para ao inv\u00e9s de comparar um deck ele compare o tamanho do deck.</p> <pre><code>// deck.rs\n    #[test]\n    fn test_create_deck_length() {\n        // Act\n        let deck = create_deck();\n\n        // Assert: Verifica se o deck cont\u00e9m exatamente 52 cartas\n        assert_eq!(deck.len(), 52, \"O deck deve conter 52 cartas\");\n    }\n\n</code></pre> <p>Precisamos fazer algumas modifica\u00e7\u00f5es, nossa <code>struct Card</code> e os <code>enums</code> <code>Rank</code> e <code>Suit</code> precisam ser p\u00fablicos. Al\u00e9m disso preciso agora dar algumas caracter\u00edsticas para eles ent\u00e3o vamos anotar em cada um com <code>#[derive(Debug, Copy, Clone, PartialEq)]</code> assim podemos copiar, clonar e comparar esses elementos. Debug estamos colocando para nos ajudar caso precisemos de alguma log.</p> <pre><code>//card.rs\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum Rank {\n    Two,\n...\n}\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum Suit {\n    Hearts,\n..\n}\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Card {\n...\n}\n</code></pre> <p>Outra altera\u00e7\u00e3o na <code>struct Card</code> \u00e9 que precisamos deixar seus atributos como p\u00fablicos tamb\u00e9m.</p> <pre><code>#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Card {\n    pub rank: Rank,\n    pub suit: Suit,\n}\n</code></pre> <p>Agora precisamos percorrer por todos os naipes e a cada naipe precisamos adicionar todas as cartas do mesmo. Para isso vamos precisar ter 2 la\u00e7os ent\u00e3o vamos percorrer um array de naipes e outro de valores de cartas. Tamb\u00e9m precisamos alterar o retorno da nossa fun\u00e7\u00e3o <code>create_deck</code> para ser <code>Vec&lt;Card&gt;</code> j\u00e1 que criamos agora nossa <code>struct Card</code>.</p> <pre><code>use crate::card::{Card, Rank, Suit};\n\nfn create_deck() -&gt; Vec&lt;Card&gt; {\n    let mut deck = Vec::new();\n    for &amp;suit in &amp;[Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades] {\n        for &amp;rank in &amp;[\n            Rank::Two,\n            Rank::Three,\n            Rank::Four,\n            Rank::Five,\n            Rank::Six,\n            Rank::Seven,\n            Rank::Eight,\n            Rank::Nine,\n            Rank::Ten,\n            Rank::Jack,\n            Rank::Queen,\n            Rank::King,\n            Rank::Ace,\n        ] {\n            deck.push(Card { rank, suit });\n        }\n    }\n    deck\n}\n\n</code></pre> <p>Com isso tamb\u00e9m precisamos alterar nosso teste <code>deck_compare</code> para usar nossa <code>struct</code>.</p> <pre><code>//deck.rs\n    #[test]\n    fn test_create_deck() {\n        //Setup\n        let deck_compare: Vec&lt;Card&gt; = Vec::new();\n        // Act\n        let mut deck = create_deck();\n\n        //Assert\n        assert_eq!(deck, deck_compare)\n    }\n</code></pre> <p>Esse teste ainda n\u00e3o vai rodar pois agora precisamos implementar a trait <code>Debug</code> e <code>PartialEq</code> em <code>Card</code>.</p> <pre><code>#[derive(Debug, PartialEq)]\npub struct Card {\n    pub rank: Rank,\n    pub suit: Suit,\n}\n</code></pre> <p>Agora rodando nosso teste temos:</p> <pre><code>\u2726 \u279c cargo test\nfailures:\n    deck::test::test_create_deck\n\ntest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--bin blackjack`\n</code></pre> <p>O teste que est\u00e1 falhando \u00e9 o pr\u00f3prio <code>test_create_deck</code> por que agora n\u00f3s n\u00e3o criamos um <code>Vec</code> Vazio. Pra isso por hora vamos fazer a mesma estrutura de repeti\u00e7\u00e3o da fun\u00e7\u00e3o <code>create_deck</code> no nosso teste, n\u00e3o \u00e9 o ideal, mas por hora vamos fazer essa implementa\u00e7\u00e3o.</p> <pre><code>    #[test]\n    fn test_create_deck() {\n        //Setup\n        let mut deck_compare: Vec&lt;Card&gt; = Vec::new();\n        for &amp;suit in &amp;[Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades] {\n            for &amp;rank in &amp;[\n                Rank::Two,\n                Rank::Three,\n                Rank::Four,\n                Rank::Five,\n                Rank::Six,\n                Rank::Seven,\n                Rank::Eight,\n                Rank::Nine,\n                Rank::Ten,\n                Rank::Jack,\n                Rank::Queen,\n                Rank::King,\n                Rank::Ace,\n            ] {\n                deck_compare.push(Card { rank, suit });\n            }\n        }\n        // Act\n        let mut deck = create_deck();\n\n        //Assert\n        assert_eq!(deck, deck_compare)\n    }\n</code></pre> <p>Agora vamos rodar nosso teste.</p> <pre><code>running 3 tests\ntest card::test::test_get_card_rank ... ok\ntest deck::test::test_create_deck ... ok\ntest deck::test::test_create_deck_length ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Certo funcionando! Agora vamos verificar se o nosso deck contem todos os naipes e cartas.  Para isso vamos declarar um vetor com os Naipes e outro para o valores das cartas. Ent\u00e3o precisamos fazer uma estrutura similar a que usamos para preencher o baralho por\u00e9m o que queremos fazer \u00e9 apenas verificar se aquela carta (Naipe, Valor) existe dentro do baralho.</p> <pre><code>//deck.rs\n    #[test]\n    fn test_create_deck_contains_all_suits_and_ranks() {\n        // Act\n        let deck = create_deck();\n\n        // Define os naipes e valores esperados\n        let expected_suits = vec![Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades];\n        let expected_ranks = vec![\n            Rank::Two, Rank::Three, Rank::Four, Rank::Five, Rank::Six, Rank::Seven,\n            Rank::Eight, Rank::Nine, Rank::Ten, Rank::Jack, Rank::Queen, Rank::King, Rank::Ace,\n        ];\n\n        // Verifica se todas as combina\u00e7\u00f5es de naipes e valores est\u00e3o presentes no deck\n        for &amp;suit in &amp;expected_suits {\n            for &amp;rank in &amp;expected_ranks {\n                let card = Card { suit, rank };\n                assert!(\n                    deck.contains(&amp;card),\n                    \"O deck deve conter a carta {:?} de {:?}\", rank, suit\n                );\n            }\n        }\n    }\n</code></pre> <p>Rodamos o teste.</p> <pre><code>\u2726 \u279c cargo test\n   Compiling blackjack v0.1.0 (/home/feanor/projects/blackjack)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running unittests src/main.rs (target/debug/deps/blackjack-eab3321ecfe99072)\n\nrunning 3 tests\ntest deck::test::test_create_deck_contains_all_suits_and_ranks ... ok\ntest card::test::test_get_card_rank_and_suit ... ok\ntest deck::test::test_create_deck_length ... ok\n\n</code></pre> <p>Certo tudo funcionando, poder\u00edamos agora criar outros tipos de teste como ver se n\u00e3o tem duplicadas, mas, pra isso precisar\u00edamos usar um <code>HashSet</code> mas, n\u00e3o vamos mexer com isso agora, fica como desafio para voc\u00ea.</p>"},{"location":"1_3_jogo_blackjack/#criando-a-mao-do-jogador","title":"Criando a m\u00e3o do jogador","text":"<p>Vamos fazer por hora um ajuste no nosso c\u00f3digo que na hora de criar nosso baralho ele j\u00e1 seja embaralhado para isso vamos adicionar a biblioteca rand.</p> <pre><code>cargo add rand\n</code></pre> <p>Agora criamos uma vari\u00e1vel com o m\u00e9todo rand\u00f4mico e chamamos a fun\u00e7\u00e3o <code>shuffle</code> que existe dentro do da biblioteca <code>rand</code> para ele embaralhar as cartas.</p> <pre><code>//deck.rs\nuse crate::card::{Card, Rank, Suit};\nuse rand::thread_rng;\nuse rand::seq::SliceRandom;\n\n\npub fn create_deck() -&gt; Vec&lt;Card&gt; {\n    let mut deck = Vec::new();\n    for &amp;suit in &amp;[Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades] {\n        for &amp;rank in &amp;[\n            Rank::Two,\n            Rank::Three,\n            Rank::Four,\n            Rank::Five,\n            Rank::Six,\n            Rank::Seven,\n            Rank::Eight,\n            Rank::Nine,\n            Rank::Ten,\n            Rank::Jack,\n            Rank::Queen,\n            Rank::King,\n            Rank::Ace,\n        ] {\n            deck.push(Card { rank, suit });\n        }\n    }\n    let mut rng = thread_rng();\n    deck.shuffle(&amp;mut rng);\n    deck\n}\n</code></pre> <p>\u00c9 importante aqui que usemos o import <code>SliceRandom</code> por que o m\u00e9todo shuffle faz parte da trait <code>SliceRandom</code> da biblioteca rand, e esta trait precisa ser importada explicitamente para que o m\u00e9todo seja acess\u00edvel no seu c\u00f3digo.</p> <p>Agora vamos criar outro m\u00f3dulo chamado <code>hand.rs</code> para ser a estrutura que vai organizar tanto a m\u00e3o do jogador quanto a m\u00e3o do dealer do jogo.</p> <pre><code>touch src/hand.rs\n</code></pre> <p>Agora vamos criar nossa <code>struct</code>para representar a m\u00e3o de cartas.</p> <pre><code>#[derive(Debug)]\npub struct Hand {\n    cards: Vec&lt;Card&gt;,\n}\n</code></pre> <p>Vamos deixar a <code>struct Hand</code> p\u00fablica para podermos acessa em outros m\u00f3dulos do nosso jogo. Agora precisamos dar mais recursos para nossa <code>struct</code> para isso precisamos ter uma forma de quando o nosso jogador criar uma m\u00e3o sem cartas e uma forma de adicionar uma carta do nosso deck a m\u00e3o do jogador, para isso vamos aprender a criar m\u00e9todos a nossa <code>struct</code> usando a palavra reservada <code>impl</code>.</p>"},{"location":"1_3_jogo_blackjack/#sintaxe-de-metodo","title":"Sintaxe de M\u00e9todo","text":"<p>M\u00e9todos s\u00e3o muito parecidos como fun\u00e7\u00f5es, eles possuem a mesma estrutura, usam a mesma palavra reservada para serem declarados <code>fn</code>, podem receber par\u00e2metros e retornar valores. Por\u00e9m m\u00e9todos s\u00e3o criados dentro de uma <code>struct</code> e pode manipular o comportamento da <code>struct</code>.</p> <p>M\u00e9todos podem ser implementados dentro de outras estruturas tamb\u00e9m os <code>enums</code> do qual j\u00e1 vimos por aqui e em <code>traits</code> que ainda vamos ver.</p> <p>A principal vantagem de criarmos m\u00e9todos para nossa <code>struct</code> ao inv\u00e9s de uma fun\u00e7\u00e3o \u00e9 que podemos alterar seu comportamento diretamente dentro da <code>struct</code> isso \u00e9 \u00fatil para centralizarmos tudo que seja relacionado a nossa <code>struct Hand</code> fique apenas limitado aos m\u00e9todos da sua pr\u00f3pria <code>struct</code> assim al\u00e9m de ajudar nos testes facilita a reutiliza\u00e7\u00e3o desses m\u00e9todos e tamb\u00e9m evita ficar emprestando nossas vari\u00e1veis o tempo todo.</p> <p>Para criar m\u00e9todos para uma <code>struct</code> precisamos usar a palavra reservada <code>impl</code> e o nome da nossa <code>struct</code> ent\u00e3o no caso do nossa <code>struct Hand</code> fica assim:</p> <pre><code>impl Hand {\n\n}\n</code></pre> <p>Com a estrutura acima podemos agora criar nossa \"fun\u00e7\u00f5es\" dentro desse bloco de c\u00f3digo.</p>"},{"location":"1_3_jogo_blackjack/#metodo-inicializador","title":"M\u00e9todo inicializador","text":"<p>O primeiro m\u00e9todo que vamos criar \u00e9 um m\u00e9todo para inicializar nossa m\u00e3o com um vetor vazio de cartas, ent\u00e3o vamos chama-lo  de <code>new</code> podemos criar a estrutura conforme abaixo.</p> <pre><code>impl Hand {\n    fn new() -&gt; Self {\n        Hand { cards: Vec::new() }\n    }\n}\n</code></pre> <p>Bom agora que voc\u00ea entendeu a din\u00e2mica de um m\u00e9todo dentro da <code>struct</code> vamos criar um teste para checar que a m\u00e3o existe. Mas, primeiro vamos importar nosso m\u00f3dulo hand na main para os testes funcionarem.  ```rust  //main.rs mod card; mod deck; mod game; mod hand;</p> <pre><code>\nAgora criamos o teste.\n\n```rust\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_hand_should_created() {\n        // Setup\n        let hand: Hand = Hand::new();\n\n\n        //Assert /Act\n\n        assert_eq!(hand, Hand::new());\n    }\n}\n</code></pre> <p>Vale ressaltar aqui que estamos criando uma vari\u00e1vel chamada <code>hand</code> ela vai receber uma inst\u00e2ncia do nosso m\u00e9todo <code>new</code> que n\u00f3s criamos, mas me diga que diabos \u00e9 uma inst\u00e2ncia?</p> <p>[!tip] Uma inst\u00e2ncia \u00e9 uma ocorr\u00eancia concreta de uma estrutura ou objeto definida por uma <code>_struct_</code> (ou classe, em linguagens orientadas a objetos). Em outras palavras, quando voc\u00ea chama um m\u00e9todo como <code>Hand::new()</code>, voc\u00ea est\u00e1 criando um novo exemplo (ou inst\u00e2ncia) da estrutura <code>Hand</code> com seus valores iniciais definidos. Essa inst\u00e2ncia cont\u00e9m os dados (neste caso, um vetor vazio de cartas) e pode ser utilizada para acessar m\u00e9todos e manipular os dados conforme necess\u00e1rio.</p> <p>Defini\u00e7\u00e3o da Estrutura: Aqui, Hand \u00e9 como um molde que define como uma \"m\u00e3o de cartas\" deve ser. Ela possui um campo cards que \u00e9 um vetor de cartas. M\u00e9todo <code>new</code>: O m\u00e9todo <code>new</code> \u00e9 um construtor que cria uma nova inst\u00e2ncia da estrutura Hand com um vetor vazio.</p> <p>Logo quando fazemos isso</p> <pre><code>let hand: Hand = Hand::new();\n</code></pre> <p>Voc\u00ea est\u00e1 criando uma inst\u00e2ncia de <code>Hand</code>. Essa inst\u00e2ncia \u00e9 um objeto real que vive na mem\u00f3ria do computador, contendo seus pr\u00f3prios dados (no caso, o vetor vazio de cartas). A partir dessa inst\u00e2ncia, voc\u00ea pode chamar outros m\u00e9todos para manipular os dados contidos nela. Mas, n\u00f3s n\u00e3o criamos eles ainda.</p> <p>Agora antes de rodar os testes, vamos comentar o shuffle do deck pois, vai quebrar o teste, vamos lidar com isso um pouco mais a frente.</p> <pre><code>    //let mut rng = thread_rng();\n    //deck.shuffle(&amp;mut rng);\n</code></pre> <p>Agora executando os teste todos devem continuar passando.</p> <pre><code>warning: `blackjack` (bin \"blackjack\" test) generated 3 warnings (run `cargo fix --bin \"blackjack\" --tests` to apply 2 suggestions)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s\n     Running unittests src/main.rs (target/debug/deps/blackjack-10500accf0b94805)\n\nrunning 5 tests\ntest card::test::test_get_card_rank_and_suit ... ok\ntest deck::test::test_create_deck ... ok\ntest deck::test::test_create_deck_contains_all_suits_and_ranks ... ok\ntest hand::test::test_hand_should_created ... ok\ntest deck::test::test_create_deck_length ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>"},{"location":"1_3_jogo_blackjack/#metodo-para-adicionar-a-carta-a-mao","title":"M\u00e9todo para adicionar a carta a m\u00e3o","text":"<p>Certo agora j\u00e1 temos uma representa\u00e7\u00e3o de uma m\u00e3o, por\u00e9m precisamos ter formas de adicionar cartas a essa m\u00e3o, pra isso precisamos criar um m\u00e9todo <code>add_card</code>, ent\u00e3o primeiro vamos criar um teste que adiciona uma carta a m\u00e3o.</p> <pre><code>    #[test]\n    fn test_add_card_in_hand() {\n        // Setup\n        let mut hand: Hand = Hand::new();\n        let card: Card= Card {\n            rank: Rank::Two,\n            suit: Suit::Diamonds,\n        };\n        let mut hand_compare: Vec&lt;Card&gt; = Vec::new();\n        hand_compare.push(card);\n\n\n        // Act\n        hand.add_card(card);\n\n        // Assert\n        assert_eq!(hand.cards, hand_compare)\n    }\n</code></pre> <p>Agora vamos rodar nosso teste e vamos receber esse erro:</p> <pre><code>error[E0599]: no method named `add_card` found for struct `hand::Hand` in the current scope\n  --&gt; src/hand.rs:44:14\n   |\n4  | pub struct Hand {\n   | --------------- method `add_card` not found for this struct\n...\n44 |         hand.add_card(card);\n   |              ^^^^^^^^ method not found in `hand::Hand`\n</code></pre> <p>O erro \u00e9 claro n\u00e3o temos um m\u00e9todo chamado <code>add_card</code> ent\u00e3o vamos criado agora:</p> <pre><code>    fn add_card(&amp;mut self, card: Card) {\n        self.cards.push(card);\n    }\n</code></pre> <p>Agora vamos rodar os testes novamente:</p> <pre><code>warning: `blackjack` (bin \"blackjack\" test) generated 3 warnings (run `cargo fix --bin \"blackjack\" --tests` to apply 2 suggestions)\n    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s\n     Running unittests src/main.rs (target/debug/deps/blackjack-10500accf0b94805)\n\nrunning 6 tests\ntest hand::test::test_hand_should_created ... ok\ntest card::test::test_get_card_rank_and_suit ... ok\ntest hand::test::test_add_card_in_hand ... ok\ntest deck::test::test_create_deck_length ... ok\ntest deck::test::test_create_deck ... ok\ntest deck::test::test_create_deck_contains_all_suits_and_ranks ... ok\n\n</code></pre> <p>Maravilha tudo funcionando!</p>"},{"location":"1_3_jogo_blackjack/#criando-a-mao-do-jogador_1","title":"Criando a m\u00e3o do jogador","text":"<p>Agora que temos uma forma de ter um baralho e criar uma m\u00e3o, vamos criar a primeira l\u00f3gica pro nosso jogo no loop de gameplay, dentro do loop vamos criar a m\u00e3o do jogador usando <code>player_hand</code>. </p> <pre><code>//game.rs\npub fn game_start() {\n    loop {\n        let deck = create_deck();\n        let mut player_hand = Hand::new();\n        println!(\"Dealer's hand:\");\n        println!(\"Total value: 0\");\n\n        println!(\"Your hand:\");\n        println!(\"Total value: 0\")\n\n    }\n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#criando-a-mao-do-dealer","title":"Criando a m\u00e3o do dealer","text":"<p>Vamos aproveitar e criar a m\u00e3o do dealer, como vamos s\u00f3 adicionar uma nova vari\u00e1vel chamada dealer_hand, vamos tamb\u00e9m j\u00e1 adicionar mais uma l\u00f3gica do jogo que \u00e9 dar as duas primeiras cartas para cada jogador.</p> <pre><code>use crate::{deck::create_deck, hand::Hand};\n\npub fn game_start() {\n    loop {\n        let deck = create_deck();\n        let mut player_hand = Hand::new();\n        let mut dealer_hand = Hand::new();\n\n        // Initial deal\n        player_hand.add_card(deck.pop().unwrap());\n        dealer_hand.add_card(deck.pop().unwrap());\n        player_hand.add_card(deck.pop().unwrap());\n        dealer_hand.add_card(deck.pop().unwrap());\n\n        println!(\"Dealer's hand:\");\n        println!(\"Total value: 0\");\n\n        println!(\"Your hand:\");\n        println!(\"Total value: 0\")\n\n    }\n}\n</code></pre> <p>No c\u00f3digo, usamos <code>pop().unwrap()</code> para retirar a \u00faltima carta do deck e obter o valor dela. Vamos dividir essa opera\u00e7\u00e3o em duas partes:</p> <ol> <li> <p><code>pop()</code>:</p> <ul> <li>Esse m\u00e9todo \u00e9 chamado em um <code>Vec&lt;T&gt;</code> e remove (pop) o \u00faltimo elemento do vetor, retornando-o como um valor do tipo <code>Option&lt;T&gt;</code>.</li> <li>Se o vetor n\u00e3o estiver vazio, <code>pop()</code> retorna <code>Some(elemento)</code>.</li> <li>Se o vetor estiver vazio, ele retorna <code>None</code>.</li> <li> <p><code>unwrap()</code>:</p> </li> <li> <p>Esse m\u00e9todo \u00e9 usado para extrair o valor dentro de um <code>Option&lt;T&gt;</code> quando temos certeza de que ele \u00e9 <code>Some(valor)</code>.</p> </li> <li>Se for <code>Some(valor)</code>, <code>unwrap()</code> retorna o <code>valor</code>.</li> <li>Se for <code>None</code>, <code>unwrap()</code> causar\u00e1 um panic, interrompendo a execu\u00e7\u00e3o do programa.</li> </ul> </li> </ol> <p>No contexto do jogo, assumimos que o deck sempre possui cartas suficientes para distribuir (por isso usamos <code>unwrap()</code> com confian\u00e7a). Assim, a chamada:</p> <pre><code>player_hand.add_card(deck.pop().unwrap());\n</code></pre> <ul> <li><code>deck.pop()</code> retira a \u00faltima carta do vetor <code>deck</code> e a retorna como <code>Some(carta)</code>.</li> <li><code>unwrap()</code> extrai a carta de dentro do <code>Some</code> e a passa para o m\u00e9todo <code>add_card</code>.</li> </ul> <p>Se, por algum motivo, o deck estiver vazio, <code>pop()</code> retornar\u00e1 <code>None</code> e o <code>unwrap()</code> causar\u00e1 um panic, interrompendo o jogo.</p> <p>Essa combina\u00e7\u00e3o de <code>pop().unwrap()</code> \u00e9 comum em situa\u00e7\u00f5es onde se tem certeza que a cole\u00e7\u00e3o n\u00e3o estar\u00e1 vazia, mas deve ser usada com cuidado para evitar panics inesperados.</p> <p>Agora vamos fazer alguns ajustes, o primeiro \u00e9 que nossa vari\u00e1vel deck precisar ser mut\u00e1vel.</p> <pre><code>pub fn game_start() {\n    loop {\n        let mut deck = create_deck();\n        let mut player_hand = Hand::new();\n        let mut dealer_hand = Hand::new();\n\n</code></pre> <p>O pr\u00f3ximo passo \u00e9 deixar nossos m\u00e9todos dentro <code>Hand</code> p\u00fablicos, isso \u00e9 um ponto de aten\u00e7\u00e3o muito importante pra voc\u00ea, pois n\u00e3o basta a <code>Struct</code> ser publica, se nossos m\u00f3dulos n\u00e3o forem, eles n\u00e3o funcionar\u00e3o em outros m\u00f3dulos. Voltando a quest\u00e3o da casa, \u00e9 como voc\u00ea pudesse entrar no c\u00f4modo mas, n\u00e3o pode mexer em nada. Ent\u00e3o vamos deixa-los p\u00fablicos.</p> <pre><code>#[derive(Debug, PartialEq)]\npub struct Hand {\n    cards: Vec&lt;Card&gt;,\n}\nimpl Hand {\n    pub fn new() -&gt; Self {\n        Hand { cards: Vec::new() }\n    }\n\n    pub fn add_card(&amp;mut self, card: Card) {\n        self.cards.push(card);\n    }\n}\n</code></pre> <p>Ainda, n\u00e3o criamos nenhum teste no nosso m\u00f3dulo game, mas vamos cria-lo mais adiante, agora vamos testar nosso jogo executando ele.</p> <pre><code>ons)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s\n     Running `target/debug/blackjack`\nStart game? (y)es or (n)o\n</code></pre> <p>Se executarmos vamos ver que ele n\u00e3o vai dar erro, por\u00e9m est\u00e1 num loop infinito. Bom uma ultima coisa que podemos fazer ainda \u00e9 mover por hora nosso m\u00e9todo de embaralhar o baralho para nossa fun\u00e7\u00e3o <code>game</code>, logo mais vamos melhorar essa organiza\u00e7\u00e3o.</p> <pre><code>use rand::{seq::SliceRandom, thread_rng};\n\nuse crate::{deck::create_deck, hand::Hand};\n\npub fn game_start() {\n    loop {\n        let mut deck = create_deck();\n        let mut rng = thread_rng();\n        deck.shuffle(&amp;mut rng);\n        let mut player_hand = Hand::new();\n        let mut dealer_hand = Hand::new();\n\n        // Initial deal\n        player_hand.add_card(deck.pop().unwrap());\n        dealer_hand.add_card(deck.pop().unwrap());\n        player_hand.add_card(deck.pop().unwrap());\n        dealer_hand.add_card(deck.pop().unwrap());\n\n        println!(\"Dealer's hand:\");\n        println!(\"Total value: 0\");\n\n        println!(\"Your hand:\");\n        println!(\"Total value: 0\")\n\n    }\n}\n</code></pre> <p>Agora se testarmos vamos ver que continua a mesma coisa, fora o ajuste do loop temos um grande problema que \u00e9 como vamos representar nossas cartas? Simples vamos come\u00e7ar a trabalhar com a artes <code>ascii</code> neles!</p>"},{"location":"1_3_jogo_blackjack/#falando-sobre-arte-ascii","title":"Falando sobre Arte ASCII","text":"<p>Bom vamos falar um pouco sobre a forma de arte que vamos usar nos nossos jogos que \u00e9 a arte ASCII.</p>"},{"location":"1_3_jogo_blackjack/#o-que-e-ascii","title":"O que \u00e9 ASCII?","text":"<p>ASCII (American Standard Code for Information Interchange) \u00e9 um padr\u00e3o de codifica\u00e7\u00e3o de caracteres para comunica\u00e7\u00e3o digital. Ele representa texto em computadores, equipamentos de comunica\u00e7\u00e3o e outros dispositivos que trabalham com texto.</p> <p>Em ess\u00eancia, cada letra, n\u00famero, s\u00edmbolo de pontua\u00e7\u00e3o e outros caracteres (como espa\u00e7os e novas linhas) recebem um c\u00f3digo num\u00e9rico \u00fanico. Por exemplo, a letra \"A\" mai\u00fascula \u00e9 representada pelo n\u00famero 65 em ASCII.</p>"},{"location":"1_3_jogo_blackjack/#por-que-o-ascii-e-importante","title":"Por que o ASCII \u00e9 importante?","text":"<p>Permite que diferentes dispositivos e softwares interpretem texto da mesma forma, facilitando a troca de informa\u00e7\u00f5es. Base para outras codifica\u00e7\u00f5es: Muitas codifica\u00e7\u00f5es modernas, como o UTF-8, s\u00e3o baseadas no ASCII para os caracteres mais comuns. O conjunto original do ASCII \u00e9 pequeno e f\u00e1cil de entender, o que o torna ideal para aplica\u00e7\u00f5es b\u00e1sicas de texto.</p>"},{"location":"1_3_jogo_blackjack/#limitacoes-do-ascii","title":"Limita\u00e7\u00f5es do ASCII:","text":"<p>O ASCII original suporta apenas 128 caracteres, o que \u00e9 insuficiente para representar todos os caracteres de muitos idiomas, incluindo acentos e s\u00edmbolos especiais.</p>"},{"location":"1_3_jogo_blackjack/#tabela-ascii","title":"Tabela ASCII","text":""},{"location":"1_3_jogo_blackjack/#um-breve-historico","title":"Um breve hist\u00f3rico","text":"<p>1963: O padr\u00e3o ASCII (American Standard Code for Information Interchange) \u00e9 estabelecido, atribuindo c\u00f3digos num\u00e9ricos a caracteres alfanum\u00e9ricos, s\u00edmbolos de pontua\u00e7\u00e3o e caracteres de controle. Essa codifica\u00e7\u00e3o universal torna-se a base para a comunica\u00e7\u00e3o digital de texto.</p> <p>D\u00e9cada de 1960: Surgem as primeiras manifesta\u00e7\u00f5es da Arte ASCII, com artistas como Kenneth Knowlton utilizando impressoras para criar padr\u00f5es visuais com caracteres. A limita\u00e7\u00e3o dos primeiros computadores, com telas de baixa resolu\u00e7\u00e3o e sem capacidade gr\u00e1fica avan\u00e7ada, impulsiona a criatividade em ASCII.</p> <p>D\u00e9cada de 1970: Com o aumento da popularidade dos computadores pessoais, a arte ASCII come\u00e7ou a surgir nos terminais de texto. Artistas usavam os caracteres dispon\u00edveis no teclado para criar imagens, logotipos e representa\u00e7\u00f5es gr\u00e1ficas.</p> <p>D\u00e9cadas de 1980: A populariza\u00e7\u00e3o dos BBS (Bulletin Board Systems) impulsiona a Arte ASCII, com a cria\u00e7\u00e3o de comunidades online dedicadas \u00e0 pr\u00e1tica e ao compartilhamento de obras. Artistas exploram diferentes t\u00e9cnicas e estilos, desde o minimalismo at\u00e9 a complexidade de detalhes.</p> <p>Atualmente: A Arte ASCII transcende suas origens e se torna uma forma de express\u00e3o art\u00edstica por direito pr\u00f3prio. Ela influencia a cultura digital, a est\u00e9tica de jogos eletr\u00f4nicos e at\u00e9 mesmo a comunica\u00e7\u00e3o online. A comunidade de entusiastas da Arte ASCII continua ativa, mantendo viva essa forma \u00fanica de arte digital.</p>"},{"location":"1_3_jogo_blackjack/#exemplos","title":"Exemplos","text":"<p>A arte ASCII pode ser simples: </p> <p>Como mais complexa:</p> <p></p> <p>E aqui um exemplo da arte do Kenneth Knowlton:</p> <p></p>"},{"location":"1_3_jogo_blackjack/#arte-ascii-em-jogos","title":"Arte ASCII em jogos","text":"<p>Os primeiros jogos de computador, como \"Rogue\" (1980) e \"Moria\" (1975), utilizavam arte ASCII para representar masmorras, monstros e tesouros. A falta de recursos gr\u00e1ficos n\u00e3o impediu a cria\u00e7\u00e3o de mundos imersivos e aventuras \u00e9picas.</p> <p>A era de ouro dos jogos de texto e aventura viu a arte ASCII florescer. Jogos como \"Zork\" (1977) e \"The Hitchhiker's Guide to the Galaxy\" (1984) utilizavam descri\u00e7\u00f5es textuais detalhadas e mapas em ASCII para transportar os jogadores para mundos imagin\u00e1rios.</p> <p>Mesmo com o avan\u00e7o dos gr\u00e1ficos, a arte ASCII manteve seu espa\u00e7o. Jogos como \"Dwarf Fortress\" (2006) e \"Linley's Dungeon Crawl\" (1997) continuaram a usar a arte ASCII para criar mundos complexos e desafiadores.</p> <p>Atualmente: A arte ASCII vive um renascimento nos jogos independentes e retr\u00f4. Jogos como \"Cataclysm: Dark Days Ahead\" (2010) e \"Cogmind\" (2017) celebram a est\u00e9tica cl\u00e1ssica da arte ASCII, mostrando que a simplicidade pode ser t\u00e3o cativante quanto os gr\u00e1ficos modernos.</p> <p> </p>"},{"location":"1_3_jogo_blackjack/#construindo-a-representacao-do-baralho-em-ascii","title":"Construindo a representa\u00e7\u00e3o do baralho em ASCII","text":"<p>Para representar nossa carta vamos implementar um m\u00e9todo no elementos que precisam ser exibidos na tela, ou seja, vamos criar um m\u00e9todo em <code>CARD</code>, <code>RANK</code> e <code>Suit</code>, vamos chamar esse m\u00e9todo de <code>to_asci</code> seu objetivo ser\u00e1 criar uma <code>String</code> que representa a carta.</p> <p>Paus: Club Suit (\u2663) Ouros: Diamond Suit (\u2666) Copas: Heart Suit (\u2665) Espadas: Spade Suit (\u2660)</p> <p>Ent\u00e3o o primeiro ponto ser\u00e1 criar uma <code>String</code>que represente nosso naipe. Como temos um <code>enum</code> n\u00f3s podemos implementar um m\u00e9todo a ele, assim como fizemos com <code>struct</code>. Usando a palavra reservada <code>impl</code> e o nome do nosso <code>enum</code> que no caso \u00e9 <code>Suit</code>. N\u00f3s vamos chamar nosso m\u00e9todo de <code>to_ascii</code> que precisa ser p\u00fablico:</p> <pre><code>pub enum Suit {\n    Hearts,\n    Diamonds,\n    Clubs,\n    Spades,\n}\n\nimpl Suit {\n    pub fn to_ascii(&amp;self) {\n\n    }\n}\n</code></pre> <p>Ent\u00e3o por hora s\u00f3 vamos receber como par\u00e2metro <code>&amp;self</code> que \u00e9 o contexto do nosso objeto. Agora precisamos selecionar o naipe e devolver o simbolo que o representa no caso: \u2665 \u2666\u2663\u2660</p> <p>Como essa \u00e9 uma <code>String</code> que n\u00e3o vai variar n\u00f3s podemos retornar no nosso m\u00e9todo um <code>str</code>.</p> <pre><code>impl Suit {\n    pub fn to_ascii(&amp;self) -&gt; &amp;'static str {\n        match *self {\n            Suit::Hearts =&gt; \"\u2665\",\n            Suit::Diamonds =&gt; \"\u2666\",\n            Suit::Clubs =&gt; \"\u2663\",\n            Suit::Spades =&gt; \"\u2660\",\n        }\n    }\n}\n</code></pre> <p>Ent\u00e3o criamos um <code>pattern match</code> pra selecionar qual \u00e9 o naipe correto e ele j\u00e1 nos retorna o naipe.</p> <p>Voc\u00ea percebeu que nosso retorno est\u00e1 usando o <code>str</code> por\u00e9m especificamos como <code>&amp;'static str</code>, isso n\u00f3s indicamos um lifetime do nosso retorno que \u00e9 um <code>Static Lifetime</code>, n\u00f3s n\u00e3o vamos entrar a fundo em <code>lifetimes</code>agora mas, para voc\u00ea entender o <code>lifetime</code>n\u00f3s damos uma \"sobrevida\" aos objetos da fun\u00e7\u00e3o ou seja quando o bloco terminar ele n\u00e3o vai destruir os objetos. Pois se voc\u00ea se lembrar no fim de um bloco de c\u00f3digo Rust remove os objetos da mem\u00f3ria, assim que ele trabalha fazendo que ele n\u00e3o precise nem gerenciar a mem\u00f3ria e nem usar um <code>Garbage Colector</code>. No caso do <code>lifetime 'static</code> n\u00f3s dizemos pro compilador que aquele retorno vai durar at\u00e9 o fim da execu\u00e7\u00e3o do programa, mas no nosso caso em especial ele est\u00e1 dizendo que o valor que vamos retornar n\u00e3o \u00e9 um valor que vem do objeto mas, um objeto est\u00e1tico.</p> <p>Certo agora vamos fazer a mesma coisa para os valores das cartas.</p> <pre><code>#[derive(Debug, Copy, Clone, PartialEq)]\nenum Rank {\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace,\n}\n\nimpl Rank {\n    pub fn to_ascii(&amp;self) -&gt; &amp;'static str {\n        match *self {\n            Rank::Two =&gt; \"2\",\n            Rank::Three =&gt; \"3\",\n            Rank::Four =&gt; \"4\",\n            Rank::Five =&gt; \"5\",\n            Rank::Six =&gt; \"6\",\n            Rank::Seven =&gt; \"7\",\n            Rank::Eight =&gt; \"8\",\n            Rank::Nine =&gt; \"9\",\n            Rank::Ten =&gt; \"10\",\n            Rank::Jack =&gt; \"J\",\n            Rank::Queen =&gt; \"Q\",\n            Rank::King =&gt; \"K\",\n            Rank::Ace =&gt; \"A\",\n        }\n    }\n}\n\n</code></pre> <p>Esse m\u00e9todo \u00e9 muito parecido com o anterior com a diferen\u00e7a que precisamos representar o nome das cartas com seus s\u00edmbolos seja eles um n\u00famero ou uma letra \"J, Q, K  e A\".</p> <p>E agora fazemos a representa\u00e7\u00e3o da carta para isso vamos desenha usando apenas os s\u00edmbolos \"-\" \"|\" e vamos concatenar as representa\u00e7\u00f5es de naipes e valores.</p> <p>Agora vamos trabalhar com uma <code>String</code> e vamos esculpir a carta inserindo s\u00edmbolos e quebras de linhas \"\\n\". Para isso usamos uma fun\u00e7\u00e3o da inst\u00e2ncia de <code>String</code> chamada <code>push_str</code>.</p> <p>Tamb\u00e9m para concatenar um <code>str</code> numa <code>String</code> vamos usar a macro <code>format!</code> da qual passamos a <code>String</code> e dentro das chaves \"{}\" ele vai inserir a nossa <code>str</code>.  Por\u00e9m a macro vai retornar uma <code>String</code>e n\u00f3s queremos mandar um <code>str</code>, podemos usar uma fun\u00e7\u00e3o da inst\u00e2ncia de <code>String</code> que \u00e9 o <code>as_str()</code> isso vai converter uma <code>S tring</code> em <code>str</code>.  Vamos ter algo assim:</p> <pre><code>let mut nome: String = String::new();\nlet jonatas = \"Jonatas\";\n\nnome.push_str(format!(\"Meu nome \u00e9 {}\", jonatas).as_str();\n</code></pre> <pre><code>impl Card {\n    pub fn to_ascii(&amp;self) -&gt; String {\n        let mut ascii_card = String::new();\n        ascii_card.push_str(\" _____\\n\");\n        ascii_card.push_str(format!(\"|{}    |\\n\", self.rank.to_ascii()).as_str());\n        ascii_card.push_str(format!(\"|  {}  |\\n\", self.suit.to_ascii()).as_str());\n        ascii_card.push_str(\"|_____|\\n\");\n        ascii_card\n    }\n}\n\n</code></pre> <p>Agora precisamos fazer um teste com a carta pra isso vamos inserir em <code>game.rs</code> a representa\u00e7\u00e3o da segunda carta do dealer.</p> <pre><code>...\n        println!(\"Dealer's hand:\");\n        println!(\"{}\", dealer_hand.cards[1].to_ascii());\n...\nbreak;\n</code></pre> <p>Vamos criar um break no final do nosso loop s\u00f3 pra poder visualizar o teste, agora se rodarmos vamos ter um erro, pois precisamo transformar <code>cards</code> em publico na <code>struct Hand</code>.</p> <pre><code>pub struct Hand {\n    pub cards: Vec&lt;Card&gt;,\n}\n\n</code></pre> <p>Agora se rodarmos vamos ver algo assim no nosso termina:</p> <pre><code>Start game? (y)es or (n)o\ny\nDealers hand:\n _____\n|9    |\n|  \u2663  |\n|_____|\n\nTotal value: 0\nYour hand:\nTotal value: 0\nStart game? (y)es or (n)o\nn\nThank you playing.\n\n</code></pre> <p>Agora que funcionou vamos representar tanto as cartas do dealer quanto do player.</p> <p>Para mostrar toda a m\u00e3o player precisamos fazer um loop, como atributo <code>cards</code> em <code>Hand</code> \u00e9 um <code>Vec</code> queremos percorrer cada elemento, para isso podemos usar a fun\u00e7\u00e3o <code>.iter()</code> que vai nos possibilitar acessar cada elemento do <code>Vec</code> dentro do <code>for</code>.</p> <pre><code>        println!(\"Dealer's hand:\");\n        println!(\"{}\", dealer_hand.cards[1].to_ascii());\n        println!(\"Total value: 0\");\n\n        println!(\"Your hand:\");\n        for card in player_hand.cards.iter() {\n            println!(\"{}\", card.to_ascii());\n        }\n</code></pre> <p>Agora ainda vamos testar usando o <code>break</code>.</p> <pre><code>Start game? (y)es or (n)o\ny\nDealer's hand:\n _____\n|6    |\n|  \u2660  |\n|_____|\n\nTotal value: 0\nYour hand:\n _____\n|A    |\n|  \u2666  |\n|_____|\n\n _____\n|7    |\n|  \u2665  |\n|_____|\n\nTotal value: 0\nStart game? (y)es or (n)o\n</code></pre> <p>Tudo certo, temos a representa\u00e7\u00e3o da nossa carta.</p>"},{"location":"1_3_jogo_blackjack/#criando-um-sistema-de-turnos","title":"Criando um sistema de turnos","text":"<p>No blackjack temos um sistema de turnos no jogo, uma vez o dealer pega uma carta no outro escolhemos se vamos pegar ou n\u00e3o uma carta. Ent\u00e3o precisamos simular esse sistema no nosso jogo. S\u00f3 que h\u00e1 um detalhe o dealer depois que o jogador para continua pegando cartas at\u00e9 ter um valor maior que o jogador, ent\u00e3o precisamos primeiro somar as cartas de cada m\u00e3o, pra isso vamos ter que criar um m\u00e9todo para somar a m\u00e3o e dar o valor de cada carta.</p> <p>Primeiro vamos definir o valor de cada carta, usando um <code>pattern matching</code> no nosso <code>enum Rank</code>.</p> <pre><code>    fn value(&amp;self) -&gt; u32 {\n        match *self {\n            Rank::Two =&gt; 2,\n            Rank::Three =&gt; 3,\n            Rank::Four =&gt; 4,\n            Rank::Five =&gt; 5,\n            Rank::Six =&gt; 6,\n            Rank::Seven =&gt; 7,\n            Rank::Eight =&gt; 8,\n            Rank::Nine =&gt; 9,\n            Rank::Ten | Rank::Jack | Rank::Queen | Rank::King =&gt; 10,\n            Rank::Ace =&gt; 11,\n        }\n    }\n</code></pre> <p>Dentro do <code>pattern maching</code> precisamos usar um or \"|\" pois o reis, dama e valete possuem valor 10 e o \u00c0s pode ser 11 ou 1, por hora vamos deixar ele com o valor 11.</p> <p>Agora a nossa<code>struct Card</code> precisa ter um m\u00e9todo para representar o valor da carta, que \u00e9 simplesmente chamar o m\u00e9todo dentro de <code>Rank</code>.</p> <pre><code>    pub fn value(&amp;self) -&gt; u32 {\n        self.rank.value()\n    }\n</code></pre> <p>Agora precisamos somar os valores da m\u00e3o do dealer e do jogador. Pra isso vamos usar nossa <code>struct Hand</code> para somar a sua pr\u00f3pria m\u00e3o.</p> <p>Para fazermos essa soma vamos entrar em algumas possibilidades que temos quando trabalhamos com <code>Vec</code>.</p>"},{"location":"1_3_jogo_blackjack/#closures","title":"Closures","text":""},{"location":"1_3_jogo_blackjack/#vec-iter-map-filter-e-sum","title":"Vec - iter, map, filter e sum","text":"<p>Quando trabalhos com algumas estruturas no rust que podem ser iter\u00e1veis como o <code>Vec</code> podemos usar fun\u00e7\u00f5es especiais.</p> <p><code>iter</code> que \u00e9 um iterador de refer\u00eancias ou seja, dentro de um loop podemos navegar pelos elementos dentro de uma estrutura sem ser necess\u00e1rio consumi-la. Pois se usamos um for precisar\u00edamos consumir o elemento ou ficar usando <code>copy</code>ou <code>clone</code>. </p> <p><code>map</code> \u00e9 uma fun\u00e7\u00e3o dentro de um <code>Iterator</code> que transforma cada elemento em uma <code>closure</code>.</p> <p><code>sum</code> \u00e9 uma fun\u00e7\u00e3o que consegue acumular valores dentro do <code>Iterator</code>.</p> <p><code>filter</code> basicamente \u00e9 como o nome j\u00e1 diz \u00e9 um filtro onde colocamos uma condi\u00e7\u00e3o da qual queremos, onde tamb\u00e9m \u00e9 poss\u00edvel usar uma <code>closure</code>.</p> <p>No nosso caso \u00e9 um <code>Vec</code> por isso precisamos somar cada valor dentro dele sem consumi-lo. Ent\u00e3o usando o <code>map</code>definimos a <code>closure</code> que seria o valor de cada carta e no retorno somamos os elementos que foram iterados.</p> <pre><code>let mut total = self.cards.iter().map(|card| card.value()).sum::&lt;u32&gt;();\n</code></pre> <p>Com isso podemos somar os elementos sem precisar consumir os elementos dentro do <code>Vec</code> Outro ponto que \u00e9 importante refor\u00e7ar \u00e9 que no 21 o A vale 11 por\u00e9m se o valor total for maior que 21 o \u00e0s muda pra 1, ou seja, se voc\u00ea tirar duas cartas de valor 10 e um \u00e0s o valor \u00e9 21 ou se voc\u00ea parar com um 9 e um \u00e0s seu valor vai ser 20.</p> <pre><code>impl Hand {\n    pub fn new() -&gt; Self {\n        Hand { cards: Vec::new() }\n    }\n\n    pub fn add_card(&amp;mut self, card: Card) {\n        self.cards.push(card);\n    }\n\n    pub fn value(&amp;self) -&gt; u32 {\n        let mut total = self.cards.iter().map(|card| card.value()).sum::&lt;u32&gt;();\n\n        let num_aces = self\n            .cards\n            .iter()\n            .filter(|&amp;&amp;card| card.rank == Rank::Ace)\n            .count();\n        for _ in 0..num_aces {\n            if total &gt; 21 {\n                total -= 10; // Convert Ace from 11 to 1\n            }\n        }\n        total\n    }\n}\n</code></pre>"},{"location":"1_3_jogo_blackjack/#colocando-a-dinamica-do-jogo","title":"Colocando  a din\u00e2mica do jogo","text":"<p>Agora vamos fazer o jogo funcionar dentro dessa l\u00f3gica para adicionar o valor as cartas.</p> <pre><code>        println!(\"Dealer's hand:\");\n        println!(\"{}\", dealer_hand.cards[1].to_ascii());\n        println!(\"Total value: {}\", dealer_hand.cards[1].value());\n\n        println!(\"Your hand:\");\n        for card in player_hand.cards.iter() {\n            println!(\"{}\", card.to_ascii());\n        }\n        println!(\"Total value: {}\", player_hand.value());\n        break\n\n</code></pre> <p>Agora nosso jogo consegue mostrar os valores da m\u00e3o. O pr\u00f3ximo passo \u00e9 preparar nosso ambiente pra ter mais testes.</p>"},{"location":"1_3_jogo_blackjack/#quebrando-nosso-jogo-e-funcoes-testaveis","title":"Quebrando nosso jogo e fun\u00e7\u00f5es test\u00e1veis","text":""},{"location":"1_3_jogo_blackjack/#cards","title":"Cards","text":"<p>Vamos fazer agora um parenteses e come\u00e7ar a usar novas ferramentas para melhorar nossos testes vamos instalar algumas ferramentas:</p> <ul> <li> <p><code>test_case</code> \u2014 parametriza\u00e7\u00e3o simples baseada em atributos: criar v\u00e1rios casos de teste com pouco boilerplate.</p> </li> <li> <p><code>rstest</code> \u2014 fixtures reutiliz\u00e1veis e parametriza\u00e7\u00e3o avan\u00e7ada (casos com <code>#[case]</code>, fixtures com <code>#[fixture]</code>).</p> </li> <li> <p><code>fake</code> \u2014 gera\u00e7\u00e3o de dados \u201crealistas\u201d pseudo-aleat\u00f3rios para testes (\u00fatil em simula\u00e7\u00f5es e testes de integra\u00e7\u00e3o). Vamos instalar e durante o uso vamos aprofundando:</p> </li> </ul> <pre><code>cargo add rstest test-case --dev &amp;&amp; cargo add fake --features derive --dev\n</code></pre> <p>Tudo bem pra come\u00e7ar vamos executar um teste para verificar o m\u00e9todo <code>suit.to_ascii()</code> aceita todos os naipes.</p> <pre><code>fn test_suit_to_ascii_parametrized(suit: Suit, expected: &amp;str) { \n    assert_eq!(suit.to_ascii(), expected); \n}\n</code></pre> <p>Agora vamos usar primeiro o <code>test_case</code></p> <pre><code>#[cfg(test)]\nmod test {\n    use test_case::test_case;\n    use super::*;\n\n    #[test_case(Suit::Spades, \"\u2660\"; \"spades symbol\")]\n    fn test_suit_to_ascii_parametrized(suit: Suit, expected: &amp;str) {\n        assert_eq!(suit.to_ascii(), expected);\n    }\n\n</code></pre> <pre><code>running 6 tests\ntest card::test::test_get_card_rank ... ok\ntest card::test::test_suit_to_ascii_parametrized::spades_symbol ... ok\ntest deck::test::test_create_deck ... ok\ntest deck::test::test_create_deck_contains_all_suits_and_ranks ... ok\ntest hand::test::test_add_card_in_hand ... ok\ntest hand::test::test_hand_should_created ... ok\n\ntest result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Agora o teste passou vamos adicionar outros casos de testes.</p> <pre><code>use test_case::test_case;\n...\n#[test_case(Suit::Hearts, \"\u2665\"; \"hearts symbol\")] \n#[test_case(Suit::Diamonds, \"\u2666\"; \"diamonds symbol\")] \n#[test_case(Suit::Clubs, \"\u2663\"; \"clubs symbol\")] \n#[test_case(Suit::Spades, \"\u2660\"; \"spades symbol\")]\nfn test_suit_to_ascii_parametrized(suit: Suit, expected: &amp;str) {\n    assert_eq!(suit.to_ascii(), expected); \n}\n</code></pre> <p>O que o test_case faz? Permite que possamos escrever testes parametrizados com uma sintaxe mais simples. Nesse caso podemos testar todos os naipes. Vantagens</p> <ul> <li>Sintaxe enxuta e leg\u00edvel.</li> <li>Cada caso \u00e9 mostrado com um nome (\u00fatil em relat\u00f3rios de CI).</li> <li>Muito simples de adotar quando voc\u00ea tem pequenas varia\u00e7\u00f5es de entrada.</li> </ul> <p>Cuidados</p> <ul> <li>N\u00e3o \u00e9 para propriedades infinitas \u2014 apenas para casos enumer\u00e1veis/pequenos.</li> <li>Mant\u00e9m testes r\u00e1pidos \u2014 bom para unit tests.</li> </ul> <p>Vamos agora fazer a mesma coisa pra testar os valores das cartas:</p> <pre><code>    #[test_case(Rank::Two, \"2\", 2; \"rank two\")]\n    #[test_case(Rank::Three, \"3\", 3; \"rank three\")]\n    #[test_case(Rank::Four, \"4\", 4; \"rank four\")]\n    #[test_case(Rank::Five, \"5\", 5; \"rank five\")]\n    #[test_case(Rank::Six, \"6\", 6; \"rank six\")]\n    #[test_case(Rank::Seven, \"7\", 7; \"rank seven\")]\n    #[test_case(Rank::Eight, \"8\", 8; \"rank eight\")]\n    #[test_case(Rank::Nine, \"9\", 9; \"rank nine\")]\n    #[test_case(Rank::Ten, \"10\", 10; \"rank ten\")]\n    #[test_case(Rank::Jack, \"J\", 10; \"rank jack\")]\n    #[test_case(Rank::Queen, \"Q\", 10; \"rank queen\")]\n    #[test_case(Rank::King, \"K\", 10; \"rank king\")]\n    #[test_case(Rank::Ace, \"A\", 11; \"rank ace\")]\n    fn test_rank_ascii_and_value(rank: Rank, expected_ascii: &amp;str, expected_value: u32) {\n        assert_eq!(rank.to_ascii(), expected_ascii);\n        assert_eq!(rank.value(), expected_value);\n    }\n\n</code></pre> <pre><code>    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s\n     Running unittests src/main.rs (target/debug/deps/blackjack-29f7206e07c21b4b)\n\nrunning 22 tests\ntest card::test::test_get_card_rank ... ok\ntest card::test::test_rank_ascii_and_value::rank_ace ... ok\ntest card::test::test_rank_ascii_and_value::rank_four ... ok\ntest card::test::test_rank_ascii_and_value::rank_jack ... ok\ntest card::test::test_rank_ascii_and_value::rank_eight ... ok\ntest card::test::test_rank_ascii_and_value::rank_king ... ok\ntest card::test::test_rank_ascii_and_value::rank_five ... ok\ntest card::test::test_rank_ascii_and_value::rank_nine ... ok\ntest card::test::test_rank_ascii_and_value::rank_seven ... ok\ntest card::test::test_rank_ascii_and_value::rank_six ... ok\ntest card::test::test_rank_ascii_and_value::rank_ten ... ok\ntest card::test::test_rank_ascii_and_value::rank_queen ... ok\ntest card::test::test_rank_ascii_and_value::rank_three ... ok\ntest card::test::test_rank_ascii_and_value::rank_two ... ok\ntest card::test::test_suit_to_ascii_parametrized::diamonds_symbol ... ok\ntest card::test::test_suit_to_ascii_parametrized::hearts_symbol ... ok\ntest card::test::test_suit_to_ascii_parametrized::clubs_symbol ... ok\ntest card::test::test_suit_to_ascii_parametrized::spades_symbol ... ok\ntest deck::test::test_create_deck ... ok\ntest deck::test::test_create_deck_contains_all_suits_and_ranks ... ok\ntest hand::test::test_add_card_in_hand ... ok\ntest hand::test::test_hand_should_created ... ok\n\ntest result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Agora vamos testar as propriedades para algumas cartas como o \u00e0s e reis individualmente, pra isso vamos criar uma configura\u00e7\u00e3o padr\u00e3o usando a lib do rtest.</p> <p>Antes de montar as fixture vamos criar  um m\u00e9todo new nosso <code>struct Card</code>.</p> <pre><code>impl Card {\n\n    pub fn new(rank: Rank, suit: Suit) -&gt; Self {\n        Card { rank, suit }\n    }\n\n</code></pre> <p>Agora vamos montar as fixtures, que nada mais s\u00e3o um objeto pr\u00e9 pronto para usarmos no nosso teste:</p> <pre><code>#[cfg(test)]\nmod test {\n    use test_case::test_case;\n    use rstest::*;\n    use super::*;\n\n    #[fixture]\n    fn ace_of_spades() -&gt; Card {\n        Card::new(Rank::Ace, Suit::Spades)\n    }\n\n    #[fixture]\n    fn king_of_hearts() -&gt; Card {\n        Card::new(Rank::King, Suit::Hearts)\n    }\n</code></pre> <p>Agora vamos criar os testes:</p> <pre><code>    #[rstest]\n    fn test_ace_properties(ace_of_spades: Card) {\n        assert_eq!(ace_of_spades.rank, Rank::Ace);\n        assert_eq!(ace_of_spades.suit, Suit::Spades);\n        assert_eq!(ace_of_spades.value(), 11);\n    }\n\n    #[rstest]\n    fn test_king_properties(king_of_hearts: Card) {\n        assert_eq!(king_of_hearts.rank, Rank::King);\n        assert_eq!(king_of_hearts.suit, Suit::Hearts);\n        assert_eq!(king_of_hearts.value(), 10);\n    }\n\n</code></pre> <p>```bash  test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</p> <pre><code>\nFalando um pouco mais do [rtest](https://crates.io/crates/rstest) ele nos d\u00e1 a trait `#[fixture]` e  `#[case]`\nEle \u00e9 bom usar quando:\n\n- V\u00e1rias fun\u00e7\u00f5es de teste precisam de _setup_ semelhante (ex.: montar um deck padr\u00e3o). \n- Quer parametrizar com casos e ainda reutilizar fixtures.\n\n**Vantagens**\n\n- Reduz duplica\u00e7\u00e3o de setup em muitos testes.\n- Combina bem com `#[case]` para cen\u00e1rios complexos (por exemplo: testar v\u00e1rias combina\u00e7\u00f5es de rank/suit com diferentes fixtures).\n- Aumenta legibilidade (nome do fixture / caso no teste).\n\n**Cuidados**\n\n- \u00c9 uma depend\u00eancia extra \u2014 evite mixar _tudo_ sem necessidade.\n- Para testes simples `test_case` \u00e0s vezes \u00e9 mais direto.\n\nAgora vamos criar uma nova fixture que gera um deck padr\u00e3o pra n\u00f3s, e gerar um teste, pra isso vamos fazer mais um refactor  no nosso m\u00f3dulo e gerar um m\u00e9todo que j\u00e1 nos d\u00ea todos os suit e todos os rank:\n\n```rust\nimpl Suit {\n    pub fn all() -&gt; Vec&lt;Suit&gt; {\n        vec![Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades]\n    }\n\n    pub fn to_ascii(&amp;self) -&gt; &amp;'static str {\n        match *self {\n            Suit::Hearts =&gt; \"\u2665\",\n            Suit::Diamonds =&gt; \"\u2666\",\n            Suit::Clubs =&gt; \"\u2663\",\n            Suit::Spades =&gt; \"\u2660\",\n        }\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum Rank {\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n    Ace,\n}\nimpl Rank {\n\n    ...\n\n    pub fn all() -&gt; Vec&lt;Rank&gt; {\n        vec![\n            Rank::Two,\n            Rank::Three,\n            Rank::Four,\n            Rank::Five,\n            Rank::Six,\n            Rank::Seven,\n            Rank::Eight,\n            Rank::Nine,\n            Rank::Ten,\n            Rank::Jack,\n            Rank::Queen,\n            Rank::King,\n            Rank::Ace,\n        ]\n    }\n}\n\n</code></pre> <p>Agora geramos a fixture  e o teste.</p> <pre><code>    #[fixture]\n    fn standard_deck() -&gt; Vec&lt;Card&gt; {\n        let mut deck = Vec::new();\n        for suit in Suit::all() {\n            for rank in Rank::all() {\n                deck.push(Card::new(rank, suit));\n            }\n        }\n        deck\n    }\n\n    #[rstest]\n    fn test_standard_deck_size(standard_deck: Vec&lt;Card&gt;) {\n        assert_eq!(standard_deck.len(), 52);\n    }\n\n</code></pre> <pre><code>test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Vamos agora usar a trait <code>case</code> do <code>rstest</code> para gerar cartas especificas, essa trait \u00e9 interessante sempre que precisamos criar um cen\u00e1rio especifico. No nosso caso vamos especificar alguns naipes e testar algumas cartas e tamb\u00e9m testar as cartas que possuem valor 10.</p> <pre><code>    #[rstest]\n    #[case(Rank::Two, Suit::Hearts)]\n    #[case(Rank::Ace, Suit::Spades)]\n    #[case(Rank::King, Suit::Diamonds)]\n    #[case(Rank::Ten, Suit::Clubs)]\n    fn test_card_creation_with_cases(#[case] rank: Rank, #[case] suit: Suit) {\n        let card = Card::new(rank, suit);\n        assert_eq!(card.rank, rank);\n        assert_eq!(card.suit, suit);\n    }\n\n    #[rstest]\n    #[case(Rank::Jack, 10)]\n    #[case(Rank::Queen, 10)]\n    #[case(Rank::King, 10)]\n    #[case(Rank::Ten, 10)]\n    fn test_face_cards_value_10(#[case] rank: Rank, #[case] expected_value: u32) {\n        assert_eq!(rank.value(), expected_value);\n    }\n</code></pre> <pre><code>test result: ok. 33 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>E se eu quiser fazer testes com casos aleat\u00f3rios? Pra isso vamos usar agora o <code>fake</code> e gerar alguns casos mais realistas. Vamos tentar gerar alguns dados e vamos precisar gerar dados pseudo-realistas (strings, n\u00fameros, \u00edndices) de forma simples. Ex.: <code>(0..13).fake()</code>  para gerar um n\u00famero aleat\u00f3rio no intervalo. Pode ajudar a simular embaralhamento/inputs variados sem construir estrat\u00e9gias do zero.</p> <p>No seu c\u00f3digo: voc\u00ea usou <code>fake</code> para:</p> <ul> <li>criar \u00edndices aleat\u00f3rios de rank/suit em testes de \u201cembaralhamento simulado\u201d.</li> <li>gerar m\u00faltiplos decks aleat\u00f3rios para validar invariantes.</li> </ul> <p>Vantagens</p> <ul> <li>F\u00e1cil de usar: sintaxe curta para gerar valores.</li> <li>\u00datil em testes de integra\u00e7\u00e3o/simula\u00e7\u00e3o quando n\u00e3o precisa do poder do <code>proptest</code>.</li> <li>Mais \u201creal\u00edstico\u201d pra testes que querem varia\u00e7\u00e3o simples, n\u00e3o necessariamente exaustiva.</li> </ul> <p>Cuidados</p> <ul> <li>\u00c9 pseudo-aleat\u00f3rio: se precisar reproduzir uma falha, capture a seed ou imprima os inputs.</li> <li>N\u00e3o substitui proptest para encontrar casos limite.</li> </ul> <pre><code>#[cfg(test)]\nmod test {\n    use test_case::test_case;\n    use rstest::*;\n    use fake::{Fake, Faker};\n    use super::*;\n\n ...\n\n    #[test]\n    fn test_card_ascii_with_fake_data() {\n        for _ in 0..10 {\n            // Setup\n            let rank_index: usize = (0..13).fake();\n            let suit_index: usize = (0..4).fake();\n\n            let rank = Rank::all()[rank_index];\n            let suit = Suit::all()[suit_index];\n\n            // Act\n            let card = Card::new(rank, suit);\n            let ascii = card.to_ascii();\n\n            // Assert\n            assert!(ascii.contains(\" _____\"));\n            assert!(ascii.contains(\"|_____|\"));\n            assert!(ascii.contains(rank.to_ascii()));\n            assert!(ascii.contains(suit.to_ascii()));\n        }\n    }\n\n}\n\n</code></pre> <p>Agora vamos remover o primeiro teste que j\u00e1 temos outros testes que cobrem melhor nosso m\u00f3dulo e falta mais um teste que \u00e9 verificar  a quebra de linha da nossa carta ASCII.</p> <pre><code>    #[test]\n    fn test_ascii_line_endings_consistent() {\n        // Setup\n        let card = Card::new(Rank::King, Suit::Hearts);\n\n        //Act\n        let ascii = card.to_ascii();\n\n        // Assert\n        let lines: Vec&lt;&amp;str&gt; = ascii.split('\\n').collect();\n        assert_eq!(lines.len(), 5);\n        assert_eq!(lines[4], \"\");\n    }\n</code></pre> <p>Aqui verificamos em lines se todas as linhas exceto a ultima terminam com \"\\n\" depois verificamos se temos 4 linhas + 1 string vazia ap\u00f3s o \u00faltimo \"\\n\" e por ultimo se a ultima linha est\u00e1 vazia.</p> <p>Rodando nossos testes vemos que tudo passou:</p> <pre><code>test result: ok. 34 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>"},{"location":"1_3_jogo_blackjack/#melhorando-o-deckrs","title":"Melhorando o deck.rs","text":"<p>Agora vamos melhorar nosso <code>deck.rs</code> primeira coisa que vamos fazer \u00e9  voltar o deck pra uma fun\u00e7\u00e3o em deck e criar os testes. Tamb\u00e9m vamos criar um m\u00e9todo que j\u00e1 crie e embaralhe o nosso deck sua fun\u00e7\u00e3o vai ser apenas agregar as duas fun\u00e7\u00f5es e usar apenas uma fun\u00e7\u00e3o no nosso game.</p> <pre><code>pub fn shuffle_deck(deck: &amp;mut Vec&lt;Card&gt;) {\n    let mut rng = thread_rng();\n    deck.shuffle(&amp;mut rng);\n}\n\npub fn create_and_shuffle_deck() -&gt; Vec&lt;Card&gt; {\n    let mut deck = create_deck();\n    shuffle_deck(&amp;mut deck);\n    deck\n}\n</code></pre> <p>Agora vamos criar uma fixture pra representar o deck para usarmos em nossos testes:</p> <pre><code>#[cfg(test)]\nmod test {\n    use super::*;\n    use rstest::*;\n\n    #[fixture]\n    fn full_deck() -&gt; Vec&lt;Card&gt; {\n        create_deck()\n    }\n</code></pre> <p>O primeiro teste que vamos fazer \u00e9 verificar se em nosso deck depois de embaralhar se ele mantem o mesmo tamanho e rodamos nosso teste:</p> <pre><code>    #[rstest]\n    fn test_shuffle_deck_preserves_size(mut full_deck: Vec&lt;Card&gt;) {\n        // Setup\n        let original_size = full_deck.len();\n\n        // Act\n        shuffle_deck(&amp;mut full_deck);\n\n        // Assert\n        assert_eq!(full_deck.len(), original_size);\n    }\n\n</code></pre> <p>O pr\u00f3ximo vai ser se depois de embaralhar o deck ainda temos todas as caras ou seja se nenhuma foi duplicada e rodar os testes.</p> <pre><code>    #[rstest]\n    fn test_shuffle_deck_preserves_all_cards(mut full_deck: Vec&lt;Card&gt;) {\n        // Setup\n        let original_deck = full_deck.clone();\n\n        // Act\n        shuffle_deck(&amp;mut full_deck);\n\n        // Assert\n        for card in &amp;original_deck {\n            assert!(full_deck.contains(card), \"Card {:?} should still be in shuffled deck\", card);\n        }\n\n        // Assert\n        for card in &amp;full_deck {\n            assert!(original_deck.contains(card), \"Shuffled deck should not contain new cards\");\n        }\n    }\n</code></pre> <p>Precisamos garantir que se as cartas forem embaralhadas mais de uma vez que a ordem mude ent\u00e3o vamos criar mais um teste pra garantir isso.</p> <pre><code>    #[test]\n    fn test_multiple_shuffles_produce_different_results() {\n        // Setup - Create multiple shuffled decks\n        let mut shuffled_decks = Vec::new();\n        for _ in 0..5 {\n            let mut deck = create_deck();\n            shuffle_deck(&amp;mut deck);\n            shuffled_decks.push(deck);\n        }\n\n        // Assert - Very unlikely that any two shuffles are identical\n        for i in 0..shuffled_decks.len() {\n            for j in i + 1..shuffled_decks.len() {\n                assert_ne!(shuffled_decks[i], shuffled_decks[j], \n                    \"Two different shuffles should not produce identical results\");\n            }\n        }\n    }\n\n</code></pre> <p>Pra finalizar a bateria de testes das nossas novas fun\u00e7\u00f5es vamos testar se o nossa fun\u00e7\u00e3o que cria e embaralha um deck e tamb\u00e9m uma condi\u00e7\u00e3o em que foi tentado criar um embaralhamento de um deck vazio.</p> <pre><code>    #[rstest]\n    fn test_create_and_shuffle_deck_function() {\n        // Act\n        let shuffled_deck = create_and_shuffle_deck();\n\n        // Assert\n        assert_eq!(shuffled_deck.len(), 52);\n\n        // Verify all cards are present\n        for suit in Suit::all() {\n            for rank in Rank::all() {\n                let card = Card::new(rank, suit);\n                assert!(shuffled_deck.contains(&amp;card), \"Shuffled deck should contain {:?} of {:?}\", rank, suit);\n            }\n        }\n    }\n\n    #[test]\n    fn test_shuffle_empty_deck() {\n        // Setup\n        let mut empty_deck: Vec&lt;Card&gt; = Vec::new();\n\n        // Act - Should not panic\n        shuffle_deck(&amp;mut empty_deck);\n\n        // Assert\n        assert!(empty_deck.is_empty());\n    }\n\n</code></pre> <pre><code>test result: ok. 40 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Vamos melhorar agora nosso teste que analisa todos os naipes e valores pra isso vamos criar fixtures para validar.</p> <pre><code>    #[fixture]\n    fn expected_suits() -&gt; Vec&lt;Suit&gt; {\n        Suit::all()\n    }\n\n    #[fixture]\n    fn expected_ranks() -&gt; Vec&lt;Rank&gt; {\n        Rank::all()\n    }\n</code></pre> <p>Agora vamos refatorar nosso teste com o <code>rstest</code> e as <code>fixtures</code>.</p> <pre><code>#[cfg(test)]\nmod test {\n    use super::*;\n    use rstest::*;\n...\n\n    #[rstest]\n    fn test_create_deck_contains_all_suits_and_ranks(\n        full_deck: Vec&lt;Card&gt;,\n        expected_suits: Vec&lt;Suit&gt;,\n        expected_ranks: Vec&lt;Rank&gt;\n    ) {\n        for &amp;suit in &amp;expected_suits {\n            for &amp;rank in &amp;expected_ranks {\n                let card = Card { suit, rank };\n                assert!(\n                    full_deck.contains(&amp;card),\n                    \"O deck deve conter a carta {:?} de {:?}\",\n                    rank,\n                    suit\n                );\n            }\n        }\n    }\n\n</code></pre> <p>No <code>test_create_deck</code> podemos remover por que ele est\u00e1 dentro da nossa fixture. E podemos agora criar um deck para verificar see temos o total correto de cartas que no caso a soma de todas as cartas deve dar 380.</p> <pre><code>    #[rstest]\n    fn test_total_deck_value(full_deck: Vec&lt;Card&gt;) {\n        // Setup &amp; Act\n        let total_value: u32 = full_deck.iter().map(|card| card.value()).sum();\n\n        // Assert\n        // Expected: 4 suits \u00d7 (2+3+4+5+6+7+8+9+10+10+10+10+11) = 4 \u00d7 95 = 380\n        assert_eq!(total_value, 380);\n    }\n\n</code></pre> <p>Poder\u00edamos criar mais casos de teste mas, vamos por hora modificar nosso <code>game.rs</code> para continuar funcionando agora com nossa fun\u00e7\u00e3o.</p> <pre><code>use crate::{deck::create_deck, hand::Hand};\n\npub fn game_start() {\n    loop {\n        let mut deck = create_and_shuffle_deck();\n\n</code></pre>"},{"location":"1_3_jogo_blackjack/#melhorando-o-handrs","title":"Melhorando o hand.rs","text":"<p>No nosso m\u00f3dulo <code>hand.rs</code> vamos criar mais alguns testes, primeiro vamos fazer um teste para calcular os valores de uma m\u00e3o, pra isso vamos criar algumas features para alguns casos de teste depois rodamos os testes.</p> <pre><code>#[cfg(test)]\nmod test {\n    use crate::card::{Rank, Suit};\n    use test_case::test_case;\n    use rstest::*;\n\n    use super::*;\n\n\n    #[fixture]\n    fn empty_hand() -&gt; Hand {\n        Hand::new()\n    }\n\n    #[test_case(vec![], 0; \"empty hand\")]\n    #[test_case(vec![Card::new(Rank::Five, Suit::Hearts)], 5; \"single card\")]\n    #[test_case(vec![Card::new(Rank::King, Suit::Hearts), Card::new(Rank::Five, Suit::Spades)], 15; \"king and five\")]\n    #[test_case(vec![Card::new(Rank::Ace, Suit::Hearts), Card::new(Rank::Nine, Suit::Spades)], 20; \"ace and nine\")]\n    #[test_case(vec![Card::new(Rank::Ace, Suit::Hearts), Card::new(Rank::King, Suit::Spades)], 21; \"blackjack\")]\n    fn test_hand_value_calculation(cards: Vec&lt;Card&gt;, expected_value: u32) {\n        // Setup\n        let mut hand = Hand::new();\n        for card in cards {\n            hand.add_card(card);\n        }\n\n        // Assert\n        assert_eq!(hand.value(), expected_value);\n    }\n</code></pre> <p>Vamos agora criar um testes para testar as condi\u00e7\u00f5es onde o \u00e0s muda de valor.</p> <p>```rust      #[test_case(vec![], 0; \"empty hand\")]     #[test_case(vec![Card::new(Rank::Five, Suit::Hearts)], 5; \"single card\")]     #[test_case(vec![Card::new(Rank::King, Suit::Hearts), Card::new(Rank::Five, Suit::Spades)], 15; \"king and five\")]     #[test_case(vec![Card::new(Rank::Ace, Suit::Hearts), Card::new(Rank::Nine, Suit::Spades)], 20; \"ace and nine\")]     #[test_case(vec![Card::new(Rank::Ace, Suit::Hearts), Card::new(Rank::King, Suit::Spades)], 21; \"blackjack\")]     fn test_hand_value_calculation(cards: Vec, expected_value: u32) {         // Setup         let mut hand = Hand::new();         for card in cards {             hand.add_card(card);         } <pre><code>    // Assert\n    assert_eq!(hand.value(), expected_value);\n}\n</code></pre> <pre><code>\nAgora vamos refatorar nosso teste `test_hand_should_created` para verificar se uma m\u00e3o vazia permanece com o valor 0 e vamos tamb\u00e9m usar o `rstest` nesse caso pra usar nossa feature `hand_empty`.\n\n```rust\n    #[rstest]\n    fn test_hand_should_created(empty_hand: Hand) {\n        // Assert\n        assert_eq!(empty_hand, Hand::new());\n        assert_eq!(empty_hand.cards.len(), 0);\n        assert!(empty_hand.cards.is_empty());\n        assert_eq!(empty_hand.value(), 0);\n    }\n\n</code></pre> <p>Agora vamos refatorar nosso teste  de adicionar uma carta na m\u00e3o usando o <code>rstest</code> e nossa fixture.</p> <pre><code>    #[rstest]\n    fn test_add_card_in_hand(mut empty_hand: Hand) {\n        // Setup\n        let card = Card::new(Rank::Two, Suit::Diamonds);\n\n        // Act\n        empty_hand.add_card(card);\n\n        // Assert\n        assert_eq!(empty_hand.cards.len(), 1);\n        assert!(!empty_hand.cards.is_empty());\n        assert!(empty_hand.cards.contains(&amp;card));\n        assert_eq!(empty_hand.value(), 2);\n    }\n</code></pre> <p>Agora vamos rodar nossos testes mais uma vez:</p> <pre><code>test result: ok. 45 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Com nossos testes rodando podemos trabalhar na nossa condi\u00e7\u00e3o de vit\u00f3ria e derrota.</p>"},{"location":"1_3_jogo_blackjack/#condicao-de-derrota","title":"Condi\u00e7\u00e3o de derrota","text":"<p>Para a condi\u00e7\u00e3o de derrota vamos criar duas vari\u00e1veis que v\u00e3o ser o score do nosso dealer e do jogador, eles v\u00e3o ser o retorno do nosso m\u00e9todo <code>value</code> da nossa hand.</p> <pre><code>    println!(\"Total value: {}\", player_hand.value());\n\n    // Determine winner\n    let player_score = player_hand.value();\n    let dealer_score = dealer_hand.value();\n\n</code></pre> <p>Agora vamos fazer um <code>condicional</code> com as nossas condi\u00e7\u00f5es de derrota onde n\u00f3s estouramos o valor da nossa m\u00e3o ou seja ela foi maior que 21 ou a m\u00e3o do dealer \u00e9 maior que a nossa.</p> <pre><code>        if player_score &gt; 21 {\n            println!(\"Bust! You lose.\");\n        } else if player_score &lt; dealer_score {\n            println!(\"Dealer wins.\");\n        } else {\n            println!(\"It's a tie.\");\n        }\n</code></pre> <p>O nosso ultimo else \u00e9 apenas para analisarmos durante o jogo se houve algum problema a frase \"It's a tie\" \u00e9 um status http que \u00e9 uma piada mas, est\u00e1 dentro da documenta\u00e7\u00e3o oficial, ent\u00e3o n\u00e3o leve a s\u00e9rio, poder\u00edamos lan\u00e7ar um erro, mas nesse projeto vamos seguir assim mesmo.</p> <p>Agora precisamos fazer um refactor no nosso jogo o dealer e o jogador v\u00e3o receber cartas at\u00e9 o jogador parar ou o valor for maior que 21. </p> <pre><code>        while player_hand.value() &lt; 21 {\n    }\n</code></pre> <p>Agora precisamos capturar uma op\u00e7\u00e3o do nosso jogador se ele quer mais uma carta hit ou se quer parar stand.</p> <pre><code>        while player_hand.value() &lt; 21 {\n            println!(\"Do you want to hit or stand? (h/s)\");\n            let mut input = String::new();\n            std::io::stdin().read_line(&amp;mut input).unwrap();\n}\n</code></pre> <p>Com isso agora devemos caso o nosso jogador de um hit que uma carta seja retirada do baralho e colocada na m\u00e3o do nosso jogador.</p> <p>Caso o jogador pe\u00e7a stand nos apenas vamos parar o loop com um  break.</p> <pre><code>        while player_hand.value() &lt; 21 {\n            println!(\"Do you want to hit or stand? (h/s)\");\n            let mut input = String::new();\n            std::io::stdin().read_line(&amp;mut input).unwrap();\n            let input = input.trim();\n            if input == \"h\" {\n                player_hand.add_card(deck.pop().unwrap());\n                println!(\"Your hand:\");\n                for card in player_hand.cards.iter() {\n                    println!(\"{}\", card.to_ascii());\n                }\n                println!(\"Total value: {}\", player_hand.value());\n            } else if input == \"s\" {\n                break;\n            }\n        }\n</code></pre> <p>Agora o pr\u00f3ximo passo \u00e9 definir os turnos do dealer, nossa regra vai ser que se o dealer tiver menos de 17 pontos ele vai continuar pegando cartas.</p> <pre><code>        // Dealer's turn\n        while dealer_hand.value() &lt; 17 {\n            dealer_hand.add_card(deck.pop().unwrap());\n        }\n\n        println!(\"Dealer's hand:\");\n        for card in dealer_hand.cards.iter() {\n            println!(\"{}\", card.to_ascii());\n        }\n        println!(\"Total value: {}\", dealer_hand.value());\n</code></pre> <p>Agora se jogador nosso jogo vemos que somos derrotados sempre, por\u00e9m as vezes o dealer perdeu e mesmo assim perdemos, ent\u00e3o agora vamos criar nossa condi\u00e7\u00e3o de vit\u00f3ria.</p>"},{"location":"1_3_jogo_blackjack/#condicao-de-vitoria","title":"Condi\u00e7\u00e3o de vit\u00f3ria","text":"<p>Bom a condi\u00e7\u00e3o de vit\u00f3ria \u00e9 bem simples n\u00f3s vamos colocar uma condi\u00e7\u00e3o onde j\u00e1 foi verificado que temos um valor menor ou igual a 21 e nossa m\u00e3o \u00e9 maior que a do dealer ou que a m\u00e3o do dealer \u00e9 menor que a nossa.</p> <p>Outro ponto \u00e9 que no blackjack o empate ningu\u00e9m perde e nosso else vai servir pra esse prop\u00f3sito tamb\u00e9m.</p> <pre><code>        if player_score &gt; 21 {\n            println!(\"Bust! You lose.\");\n        } else if dealer_score &gt; 21 || player_score &gt; dealer_score {\n            println!(\"You win!\");\n        } else if player_score &lt; dealer_score {\n            println!(\"Dealer wins.\");\n        } else {\n            println!(\"It's a tie.\");\n        }\n\n</code></pre> <p>Agora quando o jogo terminar vamos verificar se o jogador quer jogar novamente. Pra isso vamos capturar um se o usu\u00e1rio quer ou n\u00e3o continuar se n\u00e3o continuar n\u00f3s damos o break e se quiser continuar s\u00f3 seguimos o jogo.</p> <p>Mais um refactor que vamos fazer agora \u00e9 tirar o loop do nosso game j\u00e1 que o loop est\u00e1 s\u00f3 quando estamos tirando cartas.</p> <pre><code>pub fn game_start() {\n    let mut deck = create_deck();\n\n    let mut rng = thread_rng();\n    deck.shuffle(&amp;mut rng);\n\n    let mut player_hand = Hand::new();\n    let mut dealer_hand = Hand::new();\n\n    // Initial deal\n    player_hand.add_card(deck.pop().unwrap());\n    dealer_hand.add_card(deck.pop().unwrap());\n    player_hand.add_card(deck.pop().unwrap());\n    dealer_hand.add_card(deck.pop().unwrap());\n\n    println!(\"Dealer's hand:\");\n    println!(\"{}\", dealer_hand.cards[1].to_ascii());\n    println!(\"Total value: {}\", dealer_hand.cards[1].value());\n\n    println!(\"Your hand:\");\n    for card in player_hand.cards.iter() {\n        println!(\"{}\", card.to_ascii());\n    }\n    println!(\"Total value: {}\", player_hand.value());\n\n    // Player Turn\n    while player_hand.value() &lt;= 21 {\n        println!(\"Do you want to hit or stand? (h/s)\");\n        let mut input = String::new();\n        std::io::stdin().read_line(&amp;mut input).unwrap();\n        let input = input.trim();\n        if input == \"h\" {\n            player_hand.add_card(deck.pop().unwrap());\n            println!(\"Your hand:\");\n            for card in player_hand.cards.iter() {\n                println!(\"{}\", card.to_ascii());\n            }\n            println!(\"Total value: {}\", player_hand.value());\n        } else if input == \"s\" {\n            break;\n        }\n    }\n\n    // Dealer's turn\n    while dealer_hand.value() &lt; 17 {\n        dealer_hand.add_card(deck.pop().unwrap());\n    }\n\n    println!(\"Dealer's hand:\");\n    for card in dealer_hand.cards.iter() {\n        println!(\"{}\", card.to_ascii());\n    }\n    println!(\"Total value: {}\", dealer_hand.value());\n\n    // Determine winner\n    let player_score = player_hand.value();\n    let dealer_score = dealer_hand.value();\n\n\n    // Determine winner\n    let player_score = player_hand.value();\n    let dealer_score = dealer_hand.value();\n    if player_score &gt; 21 {\n        println!(\"Bust! You lose.\");\n    } else if dealer_score &gt; 21 || player_score &gt; dealer_score {\n        println!(\"You win!\");\n    } else if player_score &lt; dealer_score {\n        println!(\"Dealer wins.\");\n    } else {\n        println!(\"It's a tie.\");\n    }\n\n}\n</code></pre> <p>Agora indo para o nosso <code>main.rs</code> vamos melhorar um pouco ele.</p> <p>O nosso jogo vai ficar embolado se n\u00e3o limparmos a tela ent\u00e3o agora vamos limpar a tela do  toda vez que iniciamos ele. Pra isso vamos instalar uma nova biblioteca no nosso jogo chamada <code>crossterm</code>.</p> <pre><code>cargo add crossterm\n</code></pre> <p>Ent\u00e3o vamos criar uma fun\u00e7\u00e3o chamada <code>clear_terminal</code>.  Chamando uma macro do <code>crossterm</code> chamada <code>execute!</code> que vai executar comandos no terminal. Essa recebe dois par\u00e2metros a primeira \u00e9 a sa\u00edda que no nosso caso \u00e9 a sa\u00edda padr\u00e3o e a segunda \u00e9 o comando que no caso do <code>crossterm</code> usamos o  comando  <code>Clear</code>.</p> <pre><code>//main.rs\nuse crossterm::execute;\nuse crossterm::terminal::{Clear, ClearType};\nuse std::io;\n...\n\nfn clear_terminal() -&gt; io::Result&lt;()&gt; {\n    execute!(io::stdout(), Clear(ClearType::All))?;\n    Ok(())\n}\n</code></pre> <p>Observamos que para apontar a sa\u00edda usamos <code>io::stdout()</code> que \u00e9 a sa\u00edda padr\u00e3o do nosso terminal e dentro do comando clear usamos o par\u00e2metro <code>ClearType::All)</code> para dizer que queremos limpar todo o terminal.</p> <p>No final colocamos um <code>?</code> \u00e9 uma forma de dizermos que se essa macro der um erro ele j\u00e1 vai lan\u00e7ar o erro imediatamente.</p> <p>Por conta disso agora quando formos colocar essa fun\u00e7\u00e3o na condi\u00e7\u00e3o de reinicio de jogo vamos colocar um <code>expected</code> com uma mensagem de erro em caso de falha.</p> <pre><code>fn main() {\n    loop {\n        println!(\"Start game? (y)es or (n)o\");\n        let mut option = String::new();\n        std::io::stdin().read_line(&amp;mut option).unwrap();\n        match option.trim().to_lowercase().as_str() {\n            \"y\" =&gt; {\n                clear_terminal().expect(\"Failed to clear terminal\");\n                game_start();\n            }\n            \"n\" =&gt; {\n                println!(\"Thank you playing.\");\n                break;\n            }\n            _ =&gt; {\n                continue;\n            }\n        }\n    }\n}\n\n</code></pre> <p>Agora se testarmos nosso jogo no terminal temos um jogo totalmente funcional.</p>"},{"location":"1_3_jogo_blackjack/#testes-do-gamers","title":"Testes do game.rs","text":"<p>Para come\u00e7ar queremos fazer um teste com todas as condi\u00e7\u00f5es de vit\u00f3ria e derrota do nosso jogo isso \u00e9 um cen\u00e1rio perfeito para criarmos fixtures com cada condi\u00e7\u00e3o e usar o <code>test-case</code> para testa-los. S\u00f3 que nossa fun\u00e7\u00e3o game_start tem muitas responsabilidades, ent\u00e3o quando estivemos criando os testes vamos pensar que esse teste vai verificar uma fun\u00e7\u00e3o e ela vai retornar a condi\u00e7\u00e3o de vit\u00f3ria ou derrota. Outro ponto tanto no nosso jogo quanto pro teste seria melhor termos um <code>enum</code> com todas as condi\u00e7\u00f5es poss\u00edveis sendo que agora podemos colocar nossa condi\u00e7\u00e3o <code>draw</code>.</p> <p>Vamos criar agora o nosso <code>enum</code> e a fun\u00e7\u00e3o vazia.</p> <pre><code>#[derive(Debug, PartialEq)]\npub enum GameResult {\n    PlayerWins,\n    DealerWins,\n    Draw,\n    Tie,\n    PlayerBust,\n}\n\npub fn determine_winner(player_score: u32, dealer_score: u32) -&gt; GameResult {\n}\n</code></pre> <p>Vamos manter o Tie por hora como uma condi\u00e7\u00e3o adversa do nosso jogo.  E criamos o teste com todas as condi\u00e7\u00f5es que esperamos no jogo.</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use test_case::test_case;\n\n    #[test_case(20, 19, GameResult::PlayerWins; \"player wins with higher score\")]\n    #[test_case(18, 20, GameResult::DealerWins; \"dealer wins with higher score\")]\n    #[test_case(19, 19, GameResult::Draw; \"tie with same score\")]\n    #[test_case(22, 20, GameResult::PlayerBust; \"player busts\")]\n    #[test_case(20, 22, GameResult::PlayerWins; \"dealer busts\")]\n    #[test_case(21, 21, GameResult::Draw; \"blackjack tie\")]\n    #[test_case(15, 25, GameResult::PlayerWins; \"dealer busts with high score\")]\n    fn test_determine_winner(player_score: u32, dealer_score: u32, exp\n    ected: GameResult) {\n        // Act\n        let result = determine_winner(player_score, dealer_score);\n\n        // Assert\n        assert_eq!(result, expected);\n    }\n}\n</code></pre> <p>Agora precisamos extrair a fun\u00e7\u00e3o que determina o vencedor pra fun\u00e7\u00e3o <code>determine_winner</code>. Al\u00e9m disso vamos retornar o <code>GameResult</code>.</p> <pre><code>\npub fn determine_winner(player_score: u32, dealer_score: u32) -&gt; GameResult {\n    if player_score &gt; 21 {\n        println!(\"Bust! You lose.\");\n        GameResult::PlayerBust\n    } else if dealer_score &gt; 21 || player_score &gt; dealer_score {\n        println!(\"You win!\");\n        GameResult::PlayerWins\n    } else if player_score &lt; dealer_score {\n        println!(\"Dealer wins.\");\n        GameResult::DealerWins\n    } else if player_score == dealer_score {\n        println!(\"This game draw!\");\n        GameResult::Draw\n    } else {\n        println!(\"It's a tie.\");\n        GameResult::Tie\n    }\n}\n\npub fn game_start() {\n...\n    // Determine winner\n    let player_score = player_hand.value();\n    let dealer_score = dealer_hand.value();\n    determine_winner(player_score, dealer_score);\n}\n</code></pre> <p>Vamos deixar o <code>Tie</code> ele vai ser nossa condi\u00e7\u00e3o n\u00e3o esperada pro jogo. Agora se rodarmos os testes tudo continuar funcionando.</p> <pre><code>test result: ok. 52 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre> <p>Outro trecho que \u00e9 facilmente test\u00e1vel \u00e9 a m\u00e3o inicial, vamos extrair ele pra uma fun\u00e7\u00e3o.</p> <pre><code>\npub fn initial_deal(deck: &amp;mut Vec&lt;Card&gt;) -&gt; (Hand, Hand) {\n    let mut player_hand = Hand::new();\n    let mut dealer_hand = Hand::new();\n\n    player_hand.add_card(deck.pop().unwrap());\n    dealer_hand.add_card(deck.pop().unwrap());\n    player_hand.add_card(deck.pop().unwrap());\n    dealer_hand.add_card(deck.pop().unwrap());\n\n    (player_hand, dealer_hand)\n}\n</code></pre> <p>Agora criamos o teste que verifique que o player e o dealer tem duas cartas e tamb\u00e9m que o nosso baralho agora tem 48 cartas, pra isso precisamos criar um fixture:</p> <pre><code>    #[fixture]\n    fn sample_deck() -&gt; Vec&lt;Card&gt; {\n        create_deck()\n    }\n\n</code></pre> <p>E agora criamos o teste: </p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use rstest::*;\n\n    #[rstest]\n    fn test_initial_deal_creates_hands_with_two_cards(mut sample_deck: Vec&lt;Card&gt;) {\n        // Act\n        let (player_hand, dealer_hand) = initial_deal(&amp;mut sample_deck);\n\n        // Assert\n        assert_eq!(player_hand.cards.len(), 2);\n        assert_eq!(dealer_hand.cards.len(), 2);\n        assert_eq!(sample_deck.len(), 48); // 52 - 4 cards dealt\n    }\n\n}\n</code></pre> <p>Aqui vamos fazer uma modifica\u00e7\u00e3o vamos iniciar a m\u00e3o na fun\u00e7\u00e3o e por conta disso na fun\u00e7\u00e3o principal vamos precisar criar duas vari\u00e1veis mut\u00e1veis.</p> <pre><code>pub fn game_start() {\n    let mut deck = create_deck();\n\n    let mut rng = thread_rng();\n    deck.shuffle(&amp;mut rng);\n\n    let (mut player_hand, mut dealer_hand) = initial_deal(&amp;mut deck);\n</code></pre> <p>N\u00e3o t\u00ednhamos ainda criado uma fun\u00e7\u00e3o assim, mas nela n\u00f3s retornamos na fun\u00e7\u00e3o (initial_deal) uma tupla com duas m\u00e3os, na nossa fun\u00e7\u00e3o game n\u00f3s recebemos a tupla no formato de desestrutura\u00e7\u00e3o onde cada elemento da tupla \u00e9 uma vari\u00e1vel mut\u00e1vel.</p> <p>O pr\u00f3ximo passo que podemos fazer \u00e9 testar  se  removidas do nosso baralho, pra isso vamos tamb\u00e9m extrair nossa m\u00e3o inicial.</p> <p>Agora rodando nossos testes est\u00e1 tudo perfeito.</p> <pre><code>test result: ok. 54 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n</code></pre>"},{"location":"1_3_jogo_blackjack/#conclusao","title":"Conclus\u00e3o","text":"<p>Com esse jogo vimos como criar uma m\u00f3dulos em rust, criar testes para essa fun\u00e7\u00e3o usando a suite nativa de testes do rust e tamb\u00e9m acrescentando novas bibliotecas de testes,  revemos os tipos b\u00e1sicos de rust e vimos alguns tipos mais complexos como o vetor.</p> <p>Poder\u00edamos agora melhorar ainda mais nossa cobertura de testes extraindo o sistema de retirar as cartas da m\u00e3o do dealer e do jogador e tamb\u00e9m  criar testes de integra\u00e7\u00e3o no<code>game_start</code> mas, deixaremos isso para os nossos pr\u00f3ximos jogos. Por\u00e9m nesse momento voc\u00ea pode criar esses testes de forma de desafio.</p> <p>Tamb\u00e9m nosso jogo n\u00e3o tem o sistema de apostas mas, isso vai ficar como exerc\u00edcio sugerido.</p>"},{"location":"1_3_jogo_blackjack/#exercicios-sugeridos","title":"Exercic\u00edos sugeridos","text":"<p>1 - Voc\u00ea est\u00e1 desenvolvendo um RPG de texto onde o jogador digita comandos como \"atacar goblin\", \"pegar espada\", \"ir norte\". Implemente um parser que processe esses comandos.</p> <pre><code>#[derive(Debug, PartialEq)]\npub enum GameCommand {\n    Attack(String),      // \"atacar goblin\"\n    Take(String),        // \"pegar espada\"\n    Go(Direction),       // \"ir norte\"\n    Look,               // \"olhar\"\n    Inventory,          // \"inventario\"\n    Invalid(String),    // comando inv\u00e1lido\n}\n\n#[derive(Debug, PartialEq)]\npub enum Direction {\n    North, South, East, West\n}\n\n\n// Converte input do usu\u00e1rio em comando\npub fn parse_command(input: &amp;str) -&gt; GameCommand {}\n\n// Limpa e normaliza string (remove acentos, espa\u00e7os extras, etc.)\npub fn normalize_input(input: &amp;str) -&gt; String {}\n\n// Valida se palavra \u00e9 uma dire\u00e7\u00e3o v\u00e1lida\npub fn parse_direction(word: &amp;str) -&gt; Option&lt;Direction&gt; {}\n\n// Gera mensagem de ajuda com comandos dispon\u00edveis\npub fn help_message() -&gt; String {}\n\n// Converte comando de volta para string amig\u00e1vel\npub fn command_to_string(cmd: &amp;GameCommand) -&gt; string {}\n\n//exemplos de testes\n\nassert_eq!(parse_command(\"atacar drag\u00e3o\"), GameCommand::Attack(\"drag\u00e3o\".to_string()));\nassert_eq!(parse_command(\"IR NORTE\"), GameCommand::Go(Direction::North));\nassert_eq!(parse_command(\"  olhar  \"), GameCommand::Look);\nassert_eq!(parse_command(\"xyz123\"), GameCommand::Invalid(\"xyz123\".to_string()));\n</code></pre> <p>2 - Criar um sistema de invent\u00e1rio para RPG usando m\u00f3dulos organizados. Aqui n\u00e3o precisa criar um jogo inteiro s\u00f3 chamar criar as estruturas e chamar na main.</p> <pre><code>src/\n\u251c\u2500\u2500 item.rs          // Defini\u00e7\u00f5es de itens\n\u251c\u2500\u2500 inventory.rs     // Sistema de invent\u00e1rio  \n\u251c\u2500\u2500 equipment.rs     // Sistema de equipamentos\n\u2514\u2500\u2500 main.rs\n</code></pre> <p>No main.rs chamar uma fun\u00e7\u00e3o <code>create_item</code>, <code>create_inventory</code>, <code>create_equipament</code>. Pode ser apenas um println! simples, o objetivo \u00e9 usar os m\u00f3dulos no nosso main.</p> <p>3 - Criar um jogo de puzzle onde o jogador decifra 4 segredos codificados em diferentes formatos (char, ASCII, bytes), usando dicas em Unicode e um sistema de pontua\u00e7\u00e3o. Voc\u00ea descobriu um manuscrito antigo com 4 segredos codificados. Cada segredo est\u00e1 representado de forma diferente e voc\u00ea pode pedir dicas, mas cada dica custa 100 pontos. Comece com 1000 pontos e tente descobrir todos os segredos!</p> <p>Estrutura base</p> <pre><code>\n#[derive(Debug, Clone)]\npub struct Secret {\n    pub id: u8,\n    pub encoded_data: EncodedData,\n    pub answer: String,\n    pub hints: Vec&lt;String&gt;,\n    pub description: String,\n}\n\n#[derive(Debug, Clone)]\npub enum EncodedData {\n    Chars(Vec&lt;char&gt;),           // ['H', 'e', 'l', 'l', 'o']\n    Ascii(Vec&lt;u8&gt;),             // [72, 101, 108, 108, 111]\n    Bytes(Vec&lt;u8&gt;),             // Dados em bytes brutos\n}\n\n#[derive(Debug)]\npub struct GameState {\n    pub secrets: Vec&lt;Secret&gt;,\n    pub current_secret: usize,\n    pub score: i32,\n    pub hints_used: u32,\n    pub attempts: u32,\n    pub solved_secrets: Vec&lt;bool&gt;,\n}\n\n</code></pre> <p>Fun\u00e7\u00f5es b\u00e1sicas de convers\u00e3o de formatos:</p> <p>```rust  /// Converte string para array de caracteres pub fn string_to_chars(text: &amp;str) -&gt; Vec {     // TODO: Converter string em Vec     // \"Hello\" -&gt; ['H', 'e', 'l', 'l', 'o'] } <p>/// Converte string para valores ASCII pub fn string_to_ascii(text: &amp;str) -&gt; Vec {     // TODO: Converter cada char para seu valor ASCII     // \"Hi\" -&gt; [72, 105] } <p>/// Converte string para bytes UTF-8 pub fn string_to_bytes(text: &amp;str) -&gt; Vec {     // TODO: Converter string para bytes     // Use .as_bytes() ou .bytes() } <p>/// Converte array de chars de volta para string pub fn chars_to_string(chars: &amp;[char]) -&gt; String {     // TODO: Reunir chars em string     // ['H', 'i'] -&gt; \"Hi\" }</p> <p>/// Converte valores ASCII de volta para string pub fn ascii_to_string(ascii_values: &amp;[u8]) -&gt; Result {     // TODO: Converter ASCII para string     // Verificar se todos os valores s\u00e3o ASCII v\u00e1lidos (0-127)     // [72, 105] -&gt; \"Hi\" } <p>/// Converte bytes de volta para string UTF-8 pub fn bytes_to_string(bytes: &amp;[u8]) -&gt; Result {     // TODO: Converter bytes para string UTF-8     // Usar String::from_utf8() e tratar erros } <p>// Testes: assert_eq!(string_to_chars(\"ABC\"), vec!['A', 'B', 'C']); assert_eq!(string_to_ascii(\"Hi\"), vec![72, 105]); assert_eq!(chars_to_string(&amp;['A', 'B']), \"AB\"); assert_eq!(ascii_to_string(&amp;[72, 105]).unwrap(), \"Hi\");</p> <pre><code>\nFun\u00e7\u00f5es b\u00e1sicas de condifica\u00e7\u00e3o:\n\n ```\n /// Gera dica formatada com caracteres Unicode especiais\npub fn format_hint(hint_text: &amp;str, hint_number: u32) -&gt; String {\n    // TODO: Formatar dica com emojis e Unicode\n    // \"\ud83d\udca1 Dica #1: [HINT_TEXT] \ud83d\udd0d\"\n    // Usar caracteres Unicode: \ud83d\udca1 \ud83d\udd0d \ud83c\udfaf \u2b50 \ud83c\udf1f \ud83d\udcdd \ud83d\udd2e\n}\n\n/// Insere s\u00edmbolos Unicode em string baseado na posi\u00e7\u00e3o\npub fn insert_unicode_clues(base_text: &amp;str, positions: &amp;[usize], symbols: &amp;[char]) -&gt; String {\n    // TODO: Inserir s\u00edmbolos Unicode em posi\u00e7\u00f5es espec\u00edficas\n    // \"hello\" + posi\u00e7\u00f5es [1,3] + s\u00edmbolos ['\u2605','\u2666'] -&gt; \"h\u2605el\u2666lo\"\n}\n\n/// Remove ou substitui caracteres n\u00e3o-ASCII para normaliza\u00e7\u00e3o\npub fn normalize_answer(answer: &amp;str) -&gt; String {\n    // TODO: \n    // 1. Converter para lowercase\n    // 2. Remover espa\u00e7os extras (trim + m\u00faltiplos espa\u00e7os)\n    // 3. Remover acentos: \u00e7-&gt;c, \u00e1-&gt;a, \u00ea-&gt;e, etc.\n    // 4. Manter apenas letras e espa\u00e7os \u00fanicos\n}\n\n/// Trunca dica se muito longa e adiciona \"...\"\npub fn truncate_hint(hint: &amp;mut String, max_length: usize) {\n    // TODO: \n    // 1. Se hint.len() &gt; max_length, truncar\n    // 2. Adicionar \"...\" no final se truncado\n    // 3. Usar String::truncate()\n}\n\n// Testes:\nassert_eq!(format_hint(\"Pense em animais\", 1), \"\ud83d\udca1 Dica #1: Pense em animais \ud83d\udd0d\");\nassert_eq!(normalize_answer(\"  Gato Preto  \"), \"gato preto\");\n</code></pre> <p>Loop principal</p> <pre><code>/// Fun\u00e7\u00e3o principal do jogo\npub fn play_puzzle_game() {\n    println!(\"\ud83d\udd0d BEM-VINDO AO JOGO DE DECIFRAGEM DE SEGREDOS! \ud83d\udd0d\");\n    println!(\"\ud83d\udcdc Voc\u00ea encontrou um manuscrito com 4 segredos antigos...\");\n    println!(\"\ud83d\udcb0 Voc\u00ea tem 1000 pontos. Cada dica custa 100 pontos!\");\n\n    let mut game = GameState::new();\n\n    // TODO: Implementar loop principal do jogo:\n    // 1. Exibir segredo atual\n    // 2. Mostrar menu de op\u00e7\u00f5es\n    // 3. Processar input do jogador\n    // 4. Executar a\u00e7\u00e3o (dica, tentativa, status)\n    // 5. Verificar se jogo terminou\n    // 6. Mostrar pontua\u00e7\u00e3o final\n}\n\n/// Exibe segredo atual formatado\npub fn display_current_secret(game: &amp;GameState) {\n    let secret = &amp;game.secrets[game.current_secret];\n\n    println!(\"\\n\ud83d\udddd\ufe0f SEGREDO #{}\", secret.id);\n    println!(\"\ud83d\udcdd {}\", secret.description);\n    println!(\"\ud83d\udd22 Dados codificados: {}\", format_encoded_display(&amp;secret.encoded_data));\n    println!(\"\ud83c\udfaf An\u00e1lise: {}\", analyze_encoded_data(&amp;secret.encoded_data));\n    println!(\"{}\", format_progress_report(game));\n}\n\n/// Exibe resultado final do jogo\npub fn display_final_results(final_score: &amp;FinalScore) {\n    // TODO: Criar tela final bonita com:\n    // - Pontua\u00e7\u00e3o total\n    // - Segredos resolvidos\n    // - Rating de efici\u00eancia\n    // - Mensagem de parab\u00e9ns/encorajamento\n}\n\n/// Demonstra todas as convers\u00f5es de formato\npub fn demo_format_conversions() {\n    let test_word = \"Hi! \ud83d\udc4b\";\n\n    println!(\"\ud83d\udd0d DEMONSTRA\u00c7\u00c3O DE CONVERS\u00d5ES:\");\n    println!(\"Texto original: '{}'\", test_word);\n\n    // TODO: Mostrar todas as convers\u00f5es:\n    // - Para chars\n    // - Para ASCII (se poss\u00edvel)\n    // - Para bytes\n    // - De volta para string\n    // - An\u00e1lise completa\n}\n</code></pre> <p>Dicas:</p> <p>SEGREDO #1  - Um animal dom\u00e9stico felino  -  Dados codificados: Chars: ['G', 'A', 'T', 'O']  -  An\u00e1lise: 4 caracteres ASCII que formam uma palavra</p> <p>SEGREDO #2  - A estrela do nosso sistema solar  - Dados codificados: ASCII: [83, 79, 76]  - An\u00e1lise: 3 valores ASCII (S=83, O=79, L=76)</p> <p>4 - Implementar um sistema de apostas completo no jogo de Blackjack existente, onde o jogador gerencia suas fichas e tenta duplicar seu dinheiro.</p>"},{"location":"1_3_jogo_blackjack/#regras-do-sistema","title":"* Regras do Sistema:**","text":"<ul> <li>Fichas iniciais: 1000 fichas</li> <li>Condi\u00e7\u00e3o de vit\u00f3ria: Atingir 2000 fichas</li> <li>Condi\u00e7\u00e3o de derrota: Ficar com 0 fichas</li> <li>Valores de aposta dispon\u00edveis: 5, 10, 15, 30, 50, 100, 250, 500 fichas</li> </ul>"},{"location":"1_3_jogo_blackjack/#regras-de-pagamento","title":"* Regras de Pagamento:**","text":"<ul> <li>Blackjack: Paga 3:1 (Ex: aposta 100 \u2192 ganha 300)</li> <li>Vit\u00f3ria normal: Paga 3:2 (Ex: aposta 100 \u2192 ganha 150)</li> <li>Empate: Devolve a aposta</li> <li>Derrota: Perde a aposta</li> </ul>"},{"location":"1_4_caca_palavras/","title":"Ca\u00e7a palavras - WIP","text":""},{"location":"1_4_caca_palavras/#raio-x","title":"Raio X","text":""},{"location":"1_4_caca_palavras/#mecanicas-do-jogo","title":"Mec\u00e2nicas do Jogo:","text":"<p>A tela apresentar\u00e1 uma lista de palavras pra serem buscadas. O jogo ter\u00e1 20 palavras para serem buscadas. Palavras podem estar na horizontal, vertical ou diagonal. Uma palavra encontrada deve aparecer riscada para indicar que j\u00e1 foi achada. Precisa ter um timer para indicar o tempo at\u00e9 encontrar todas as palavras. Precisa ter um marcador quando tenta encontrar uma palavra. Palavras encontradas devem aparecer destacadas.O jogo termina quando forem encontradas as 20 palavras.</p>"},{"location":"1_4_caca_palavras/#tui","title":"TUI","text":"<p>Tui \u00e9 Terminal User Interface e \u00e9 usado amplamente na computa\u00e7\u00e3o tanto corporativa quanto pessoal, \u00e9 basicamente uma forma de termos um programa com uma interface com bot\u00f5es, menus e etc s\u00f3 que rodando no terminal \u00e9 bem \u00fatil em v\u00e1rias situa\u00e7\u00f5es e podemos fazer v\u00e1rias coisas com esse tipo de interface.</p>"},{"location":"1_4_caca_palavras/#ratatui","title":"Ratatui","text":"<p>Ratatui \u00e9 uma biblioteca para cria\u00e7\u00e3o de interfaces de usu\u00e1rio baseadas em texto (TUI) na linguagem de programa\u00e7\u00e3o Rust. Ela \u00e9 uma vers\u00e3o aprimorada e mantida da biblioteca TUI-rs, com o objetivo de fornecer uma maneira eficiente e f\u00e1cil de construir TUIs no terminal. Principais Recursos:     Flexibilidade e Composi\u00e7\u00e3o:         O Ratatui oferece layout flex\u00edvel e ferramentas para organizar componentes como pain\u00e9is, caixas de texto, tabelas, gr\u00e1ficos, e barras de progresso, com base nas suas necessidades.         Ele usa um sistema de layouts declarativos, permitindo que voc\u00ea divida sua interface em blocos reutiliz\u00e1veis e bem organizados.     Estiliza\u00e7\u00e3o e Temas:         A biblioteca suporta estilos customiz\u00e1veis para textos e widgets, permitindo a aplica\u00e7\u00e3o de cores, modificadores como negrito, sublinhado e it\u00e1lico, al\u00e9m de temas personalizados.         Com isso, voc\u00ea pode criar interfaces que se adaptam \u00e0 est\u00e9tica desejada para a aplica\u00e7\u00e3o no terminal.     Performance:         Escrito em Rust, o Ratatui \u00e9 muito eficiente em termos de uso de mem\u00f3ria e processamento, o que o torna adequado para aplica\u00e7\u00f5es de linha de comando r\u00e1pidas e reativas.     Integra\u00e7\u00e3o com Crossterm:         O Ratatui funciona em conjunto com o Crossterm, uma biblioteca que oferece controle sobre o terminal (como captura de eventos de teclado e controle de entrada/sa\u00edda de terminal) de maneira cross-platform (suporta Windows, Linux e macOS).     Suporte a Eventos:         Al\u00e9m do controle de layout e estilo, o Ratatui permite a captura de eventos de teclado e mouse, tornando poss\u00edvel a cria\u00e7\u00e3o de interfaces interativas, como editores de texto, navegadores de arquivos, e clientes de chat.</p> <pre><code>graph TB\n    subgraph \"Aplica\u00e7\u00e3o do Usu\u00e1rio\"\n        App[Estado da Aplica\u00e7\u00e3o]\n        EventLoop[Loop de Eventos]\n        DrawFn[Fun\u00e7\u00e3o de Desenho]\n    end\n\n    subgraph \"Ratatui Core\"\n        Terminal[Terminal]\n        Frame[Frame]\n        Buffer1[Buffer Atual]\n        Buffer2[Buffer Anterior]\n        Layout[Sistema de Layout]\n    end\n\n    subgraph \"Widgets\"\n        Block[Block]\n        Paragraph[Paragraph]\n        List[List]\n        Table[Table]\n        Chart[Chart]\n        Custom[Widgets Customizados]\n    end\n\n    subgraph \"Backend Layer\"\n        Backend[Backend&lt;br/&gt;Crossterm/Termion/Termwiz]\n        TerminalIO[I/O do Terminal]\n    end\n\n    EventLoop --&gt;|1. Captura eventos| Backend\n    Backend --&gt;|2. Retorna eventos| EventLoop\n    EventLoop --&gt;|3. Atualiza| App\n    EventLoop --&gt;|4. Chama draw| Terminal\n    Terminal --&gt;|5. Fornece Frame| DrawFn\n    DrawFn --&gt;|6. Calcula espa\u00e7o| Layout\n    Layout --&gt;|7. Retorna Rect| DrawFn\n    DrawFn --&gt;|8. Renderiza widgets| Frame\n    Frame --&gt;|9. Desenha em| Buffer1\n\n    Block -.-&gt;|implementa Widget| Frame\n    Paragraph -.-&gt;|implementa Widget| Frame\n    List -.-&gt;|implementa StatefulWidget| Frame\n    Table -.-&gt;|implementa StatefulWidget| Frame\n    Chart -.-&gt;|implementa Widget| Frame\n    Custom -.-&gt;|implementa Widget/StatefulWidget| Frame\n\n    Terminal --&gt;|10. Compara| Buffer2\n    Terminal --&gt;|11. Calcula diff| Buffer1\n    Terminal --&gt;|12. Envia mudan\u00e7as| Backend\n    Backend --&gt;|13. Escreve na tela| TerminalIO\n\n    Buffer1 -.-&gt;|Se torna pr\u00f3ximo| Buffer2\n\n    style App fill:#e1f5ff\n    style Terminal fill:#ffe1e1\n    style Backend fill:#e1ffe1\n    style Frame fill:#fff4e1\n    style Layout fill:#f0e1ff\n</code></pre> <p>O diagrama acima ilustra como os componentes do Ratatui se conectam e como a informa\u00e7\u00e3o flui pelo sistema. Vou destacar alguns pontos importantes que voc\u00ea v\u00ea no diagrama:</p> <p>O ciclo numerado (1-13) mostra o fluxo completo de uma itera\u00e7\u00e3o do loop de renderiza\u00e7\u00e3o. Voc\u00ea pode ver como come\u00e7a com a captura de eventos do teclado, passa pela atualiza\u00e7\u00e3o do estado, depois pela renderiza\u00e7\u00e3o dos widgets, e finalmente termina com a escrita eficiente no terminal usando o sistema de diff.</p> <p>As linhas s\u00f3lidas representam o fluxo principal de dados e controle, enquanto as linhas pontilhadas mostram as rela\u00e7\u00f5es de implementa\u00e7\u00e3o entre os widgets e o sistema de renderiza\u00e7\u00e3o.</p> <p>O sistema de buffer duplo \u00e9 especialmente importante para performance: ao manter dois buffers e comparar apenas as diferen\u00e7as, o Ratatui evita redesenhar toda a tela a cada frame, resultando em interfaces muito mais fluidas e responsivas.</p>"},{"location":"1_4_caca_palavras/#atualizando-o-rust","title":"Atualizando o rust","text":"<p>Bom antes de come\u00e7armos nosso jogo vamos fazer novamente a atualiza\u00e7\u00e3o do rust:</p> <pre><code>rustup update stable\n</code></pre> <p>Criando projeto</p> <p>Bom vamos criar nosso novo projeto em projects:</p> <pre><code>cargo new wordsearch\ncd wordsearch\n</code></pre> <p>Para criar esse projeto vamos entender melhor como vamos estruturar nosso jogo.</p>"},{"location":"1_4_caca_palavras/#iniciando-o-nosso-projeto","title":"Iniciando o nosso projeto","text":"<p>Vamos agora adicionar algumas bibliotecas no nosso projeto.</p> <pre><code>cargo add ratatui crossterm color-eyre\n</code></pre> <p>Explicando as libs com o <code>ratatui</code> que \u00e9 nossa lib base e o <code>crossterm</code> que como usamos no jogo anterior ele vai executar comandos no nosso terminal e finalmente o <code>color-eyre</code> que \u00e9 apenas para colorir nossa sa\u00edda do terminal quando houver erro no nosso programa.</p> <p>Agora vamos colar o exemplo do site do ratatui</p> <pre><code>use color_eyre::Result;\nuse crossterm::event::{self, Event};\nuse ratatui::{DefaultTerminal, Frame};\n\nfn main() -&gt; Result&lt;()&gt; {\n    color_eyre::install()?;\n    let terminal = ratatui::init();\n    let result = run(terminal);\n    ratatui::restore();\n    result\n}\n\nfn run(mut terminal: DefaultTerminal) -&gt; Result&lt;()&gt; {\n    loop {\n        terminal.draw(render)?;\n        if matches!(event::read()?, Event::Key(_)) {\n            break Ok(());\n        }\n    }\n}\n\nfn render(frame: &amp;mut Frame) {\n    frame.render_widget(\"hello world\", frame.area());\n}\n</code></pre> <p>Explicando pontualmente para usar o ratatui na nossa main atrav\u00e9s do <code>ratatui::init();</code>que basicamente inicializa um terminal, isso quer dizer que esse objeto \u00e9 respons\u00e1vel para desenhar dentro do terminal.</p> <p>Agora temos duas fun\u00e7\u00f5es que ser\u00e3o muito importantes:</p> <pre><code>fn run(mut terminal: DefaultTerminal) -&gt; Result&lt;()&gt; {\n</code></pre> <p>Essa fun\u00e7\u00e3o vai ser respons\u00e1vel para chamar nossa fun\u00e7\u00e3o de desenho que chamamos  aqui de render e tamb\u00e9m ali vamos fazer as itera\u00e7\u00f5es com teclado ou mouse pro nosso jogo. Deixamos um loop infinito ali onde nesse caso clicando qualquer tecla damos um <code>break</code> e sa\u00edmos do programa.</p> <p>E na fun\u00e7\u00e3o:</p> <pre><code>fn render(frame: &amp;mut Frame) {\n</code></pre> <p>\u00e9 nossa fun\u00e7\u00e3o pra desenhar nossa tela, podemos ter mais fun\u00e7\u00f5es de render se tivermos muitas telas pra desenhar, mas basicamente aqui nos vamos clicar nossos widgets.</p> <p>Um ponto importante aqui conhe\u00e7o j\u00e1 o nosso m\u00e9todo <code>frame.area())</code> onde ele marca o tamanho do terminal como um todo.</p>"},{"location":"1_4_caca_palavras/#conceito-do-grid","title":"Conceito do grid","text":"<p>Agora quero falar um pouco de como podemos desenhar as telas da nossa TUI, no caso do <code>ratatui</code> temos um conceito de chunks ou seja, s\u00e3o peda\u00e7os do nosso layout com eles podemos definir sess\u00f5es pro nosso jogo. </p> <p>Veja na imagem abaixo vamos separar nosso layout do jogo em 3 partes ou 3 chunks uma pro header, outra pro footer e finalmente o meio pro Grid.</p> <p></p> <p>Com isso podemos criar na nossa fun\u00e7\u00e3o render nosso layout padr\u00e3o.</p> <pre><code>    let size = frame.area();\n\n    // Layout principal\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(3), // Header\n            Constraint::Min(0),    // Game area\n            Constraint::Length(3), // Footer\n        ])\n        .split(size);\n</code></pre> <p>Aqui vamos definir que o size do nosso projeto vai ser toda a \u00e1rea do frame, com isso podemos definir nossos chunks. Pra iniciar nosso layout n\u00f3s passamos o <code>Layout::default()</code> que fica respons\u00e1vel por iniciar nosso layout.</p> <p>Em <code>direction(Direction::Vertical)</code> n\u00f3s passamos como vamos dividir os chunks que nesse caso ser\u00e1 vertical. Em <code>constraints</code> n\u00f3s definimos os peda\u00e7os e pro nosso footer e header vamos passar o valor 3 que nesse caso vai ser interpretado como linhas e a \u00e1rea do jogo colocamos como <code>Min(0)</code> que dentro da biblioteca vai ocupar todo o espa\u00e7o dispon\u00edvel no layout.</p> <p>Finalmente usamos o <code>.split(size)</code> que aqui tem como objetivo pegar a area da nossa tela e fazer o split conforme capturamos.</p> <p>Com isso ainda n\u00e3o vamos ter nada por que n\u00e3o renderizamos a tela mas, podemos come\u00e7ar a desenha nossa tela.</p> <p>Pra saber mais dessa parte pode ver aqui.</p> <p>Layout do ratatui Propor\u00e7\u00f5es</p>"},{"location":"1_4_caca_palavras/#arquitetando-nosso-jogo","title":"Arquitetando nosso jogo","text":"<p>Vamos agora criar dois arquivos pro nosso jogo, o primeiro vai ser o m\u00f3dulo pro nosso jogo vamos chamar de <code>ui.rs</code>.</p> <pre><code>touch src/ui.rs\n</code></pre> <p>Esse m\u00f3dulo vamos concentrar tudo relacionado ao desenho da tela do nosso jogo, agora vamos mudar a forma que trabalhamos com nossos testes, vamos criar um diret\u00f3rio dedicado pros testes e tamb\u00e9m um arquivo chamado <code>test_ui.rs</code>.</p> <pre><code>mkdir -p tests\ntouch tests/tests_ui.rs\n</code></pre> <p>Agora vamos criar no nosso <code>src</code> um arquivo chamado <code>lib.rs</code> e agora ao inv\u00e9s de exportar nossos m\u00f3dulos no nosso <code>main.rs</code> vamos exportar diretamente no nosso <code>lib.rs</code>.</p>"},{"location":"1_4_caca_palavras/#por-que-no-lib-e-nao-direto-no-main","title":"Por que no lib e n\u00e3o direto no main?","text":"<p>Primeiro quando exportamos para <code>lib.rs</code> estamos deixando nossos m\u00f3dulos como APIs p\u00fablicas e eles podem ser reutilizados por outros bin\u00e1rios se houvesse no nosso c\u00f3digo, mas tamb\u00e9m pro nosso caso vai facilitar pra testarmos nosso c\u00f3digo atrav\u00e9s de um diret\u00f3rio externo que \u00e9 o caso do nosso diret\u00f3rio <code>tests</code>.</p> <p>Com isso agora vamos fazer uma pequena revis\u00e3o sobre <code>clousures</code>.</p>"},{"location":"1_4_caca_palavras/#closures","title":"Closures","text":"<p>Closures (ou fun\u00e7\u00f5es an\u00f4nimas) s\u00e3o fun\u00e7\u00f5es que podem processar elementos do ambiente onde foram definidas. Diferente de fun\u00e7\u00f5es regulares criadas com <code>fn</code>, closures s\u00e3o an\u00f4nimas (n\u00e3o precisam de nome) e t\u00eam a capacidade especial de \"lembrar\" e usar vari\u00e1veis do escopo onde foram criadas. Em Rust, o compilador analisa como cada vari\u00e1vel \u00e9 capturada e escolhe automaticamente a melhor estrat\u00e9gia de implementa\u00e7\u00e3o.</p> <p>A sintaxe b\u00e1sica de uma closure \u00e9 simples: <code>|par\u00e2metros| express\u00e3o</code>. Por exemplo, <code>|x| x + 1</code> \u00e9 uma closure que recebe um valor e retorna esse valor incrementado. Closures podem ser armazenadas em vari\u00e1veis e passadas como argumentos para outras fun\u00e7\u00f5es, tornando-as perfeitas para callbacks, iteradores e programa\u00e7\u00e3o funcional.</p> <pre><code>// Closure simples que captura uma vari\u00e1vel do ambiente\nlet multiplicador = 5;\nlet multiplicar = |x| x * multiplicador; // Captura 'multiplicador'\n\nprintln!(\"10 * {} = {}\", multiplicador, multiplicar(10)); // 50\n</code></pre> <p>Rust possui tr\u00eas traits principais para closures, que determinam como elas capturam e usam vari\u00e1veis: - <code>Fn</code>: captura por refer\u00eancia imut\u00e1vel (<code>&amp;T</code>) - pode ser chamada m\u00faltiplas vezes sem modificar o ambiente - <code>FnMut</code>: captura por refer\u00eancia mut\u00e1vel (<code>&amp;mut T</code>) - pode modificar o ambiente, mas pode ser chamada m\u00faltiplas vezes - <code>FnOnce</code>: captura por valor (toma posse, move) - consome o ambiente, s\u00f3 pode ser chamada uma vez</p> <pre><code>// Exemplo dos tr\u00eas tipos de closures\nlet mut contador = 0;\n\n// Fn - apenas l\u00ea, n\u00e3o modifica\nlet ler = || println!(\"Contador: {}\", contador);\nler();\nler(); // Pode chamar m\u00faltiplas vezes\n\n// FnMut - modifica o ambiente\nlet mut incrementar = || {\n    contador += 1;\n    contador\n};\nprintln!(\"Novo valor: {}\", incrementar()); // 1\nprintln!(\"Novo valor: {}\", incrementar()); // 2\n\n// FnOnce - consome o valor (move)\nlet mensagem = String::from(\"Sistema ativado!\");\nlet consumir = || {\n    println!(\"{}\", mensagem);\n    mensagem // move mensagem pra fora\n};\nconsumir(); // OK\n// consumir(); // ERRO! N\u00e3o pode chamar de novo\n</code></pre>"},{"location":"1_4_caca_palavras/#por-que-closures-sao-importantes","title":"Por que Closures s\u00e3o Importantes?","text":"<p>Closures s\u00e3o fundamentais em Rust porque permitem: 1. Callbacks e Event Handlers: responder a eventos com l\u00f3gica customizada 2. Iteradores: transformar e filtrar cole\u00e7\u00f5es de forma elegante com <code>map</code>, <code>filter</code>, <code>for_each</code> 3. Programa\u00e7\u00e3o Funcional: compor opera\u00e7\u00f5es complexas de forma declarativa 4. Lazy Evaluation: adiar computa\u00e7\u00f5es at\u00e9 que sejam realmente necess\u00e1rias 5. Threads: passar c\u00f3digo com contexto para execu\u00e7\u00e3o paralela</p> <p>Com isso podemos come\u00e7ar a desenhar nosso header.</p>"},{"location":"1_4_caca_palavras/#criando-um-render-pro-nosso-header","title":"Criando um render pro nosso header","text":"<p>Primeiro vamos criar um teste para verificar se nossa fun\u00e7\u00e3o <code>draw_header</code> existe. Nesse momento n\u00e3o vamos usar o <code>rstest</code> pra criar uma <code>fixture</code> mas, vamos criar uma fun\u00e7\u00e3o auxiliar.</p> <p>Pra isso vamos importar a <code>struct</code> <code>TestBackend</code> que j\u00e1 vem com o <code>ratatui</code>,  com ele podemos criar uma terminal de teste e usar no nosso c\u00f3digo.</p> <pre><code>use ratatui::backend::{backend::TestBackend, Terminal};\n\nfn setup_terminal() -&gt; Terminal&lt;TestBackend&gt; {\n    let backend = TestBackend::new(80, 24);\n    Terminal::new(backend).unwrap()\n}\n</code></pre> <p>Ent\u00e3o a fun\u00e7\u00e3o <code>setup_terminal</code> vai retornar um terminal pra n\u00f3s e assim podemos usar o m\u00e9todo <code>new</code> pra gerar nosso backend, depois usando a <code>struct</code> <code>Terminal</code> criamos o terminal em si.</p> <p>Com isso podemos criar um teste pra apenas verificar se vai ser chamada a nossa fun\u00e7\u00e3o <code>draw_header</code> que vamos implementar.</p> <p>Nossa fun\u00e7\u00e3o <code>draw_header</code> vamos criar um terminal e chamar seu m\u00e9todo <code>draw</code> e no m\u00e9todo vamos passar o retorno da nossa fun\u00e7\u00e3o <code>draw_header</code> e assim podemos passar o retorno da nossa fun\u00e7\u00e3o <code>draw_header</code> como uma <code>clousure</code>. Finalmente podemos encadear um <code>expect</code> depois do <code>draw</code> para lan\u00e7ar um erro caso aconte\u00e7a algum problema.</p> <pre><code>use ratatui::{backend::TestBackend, layout::Rect, Terminal};\n\n#[test]\nfn test_draw_header_renders_successfully() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 3);\n\n    // Act - Assert\n    terminal\n        .draw(|f| draw_header(f, area))\n        .expect(\"draw_header should render\");\n}\n</code></pre> <p>Aqui nosso teste n\u00e3o tem um assert por que s\u00f3 o fato de renderizar j\u00e1 \u00e9 considerado um sucesso, ent\u00e3o vamos rodar assim o nosso c\u00f3digo e vamos ter o erro abaixo:</p> <pre><code>error[E0425]: cannot find function `draw_header` in this scope\n  --&gt; tests/tests_ui.rs:34:19\n   |\n34 |         .draw(|f| draw_header(f, area))\n   |                   ^^^^^^^^^^^ not found in this scope\n</code></pre> <p>Bom como sabemos esse erro \u00e9 por que n\u00e3o temos o draw_header criado, vamos cria-lo na nosso m\u00f3dulo ui.</p> <pre><code>pub fn draw_header(f: &amp;mut Frame, area: Rect) {\n\n}\n</code></pre> <p>Agora \u00e9 importante ressaltar que todas as fun\u00e7\u00f5es que vamos testar ser\u00e3o publicas nesse projeto, no futuro nos pr\u00f3ximos projetos vamos delimitar aspectos que precisam ser p\u00fablicos e os aspectos privados, manejando os testes corretamente. Mas, nesse projeto eu quero que voc\u00ea se acostume a criar os testes de forma p\u00fablica j\u00e1 que anteriormente s\u00f3 criamos testes no pr\u00f3prio m\u00f3dulo.</p> <p>Agora precisamos importar o <code>draw_header</code> no <code>tests_ui.rs</code> e depois rodar os testes:</p> <pre><code>// tests_ui.rs\nuse wordsearch::ui::draw_header;\n\n</code></pre> <pre><code>    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s\n     Running unittests src/lib.rs (target/debug/deps/wordsearch-b906015e74c9ad81)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/wordsearch-ca09197567fe797a)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/tests_ui.rs (target/debug/deps/tests_ui-547972e55c75e006)\n\nrunning 1 test\ntest test_draw_header_renders_successfully ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests wordsearch\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Sucesso! Agora come\u00e7amos a construir o primeiro elemento da nossa ui.</p>"},{"location":"1_4_caca_palavras/#entendo-como-capturar-os-elementos-do-nosso-render","title":"Entendo como capturar os elementos do nosso render","text":"<p>Agora nosso teste j\u00e1 passou, queremos que nosso header tenha um label com o tempo que decorrido durante o jogo e o t\u00edtulo do jogo que vai ser <code>_Wordsearch_</code>.</p> <p>Pra isso vamos ter que criar no nosso teste uma nova fun\u00e7\u00e3o auxiliar, nela vamos acessar nosso terminal de teste, ai vamos precisar navegar por alguns m\u00e9todos, vamos acessar o m\u00e9todo <code>backend</code> nele vamos acessar o m\u00e9todo <code>buffer</code> que representa os elementos que foram renderizados. </p> <p>Ent\u00e3o vamos criar uma fun\u00e7\u00e3o chamada <code>get_buffer_content</code>.</p> <pre><code>fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;) {\n    terminal\n        .backend()\n        .buffer()\n}\n\n</code></pre> <p>Uma vez com isso ainda precisamos acessar o m\u00e9todo <code>content</code> pra pegar o conte\u00fado gerado para o buffer. O <code>content</code> vai retornar um tipo especial o <code>&amp;[Cell]</code> que \u00e9 uma cole\u00e7\u00e3o e por usa vez tem implementado <code>iterator</code> pois ele \u00e9 uma sequ\u00eancia de elementos.</p> <pre><code>fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;){\n    terminal\n        .backend()\n        .buffer()\n        .content()\n        .iter()\n}\n</code></pre> <p>Como n\u00f3s queremos um conte\u00fado especifico do <code>&amp;Cell</code> que foi gerado pelo nosso <code>iterator</code> vamos selecionado. No caso precisamo do campo <code>symbols</code> ent\u00e3o vamos mapear todos os <code>symbols</code> dos elementos dentro do content e pra isso vamos criar uma <code>clousure</code> dedicada a capturar esse campo dos elementos de <code>content</code> e finalmente damos um <code>collect</code> no final.</p> <p>O <code>collect</code> \u00e9 um m\u00e9todo especial que ainda n\u00e3o vimos mas, seu objetivo \u00e9 transformar um <code>iterator</code> em uma cole\u00e7\u00e3o, no nosso caso <code>symbols</code> \u00e9 um item do tipo <code>&amp;str</code> ent\u00e3o o collect vai transformar o retorno numa cole\u00e7\u00e3o de <code>String</code> ent\u00e3o vamos indicar que o retorno dessa fun\u00e7\u00e3o \u00e9 uma <code>String</code>.</p> <pre><code>fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;) -&gt; String {\n    terminal\n        .backend()\n        .buffer()\n        .content()\n        .iter()\n        .map(|c| c.symbol())\n        .collect()\n}\n</code></pre> <p>Pra saber mais sobre os detalhes de cada m\u00e9todo e seu retorno voc\u00ea pode consultar a documenta\u00e7\u00e3o do <code>ratatui</code>.</p>"},{"location":"1_4_caca_palavras/#preenchendo-o-header","title":"Preenchendo o header","text":"<p>Ainda n\u00e3o vamos desenhar a tela mas, vamos primeiro criar um teste nele vamos checar se dentro do conte\u00fado do nosso header h\u00e1 uma string chamada tempo, uma string chamada Found que representa as palavras encontradas e outra chamada <code>_Wordsearch_</code>.</p> <p>Com isso em mente vamos criar um teste chamado <code>test_draw_header_contains_required_elements</code> vamos passar como setup um terminal e uma area aqui vamos criar um ret\u00e2ngulo simples.</p> <pre><code>#[test]\nfn test_draw_header_contains_required_elements() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 3);\n\n}\n\n</code></pre> <p>Agora vamos simplesmente chamar a fun\u00e7\u00e3o <code>terminal.draw</code> precisamos fazer um desempacotamento do m\u00e9todo pois ele retorna um result.</p> <pre><code>#[test]\nfn test_draw_header_contains_required_elements() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 3);\n    terminal.draw(|f| draw_header(f, area)).unwrap();\n\n}\n\n</code></pre> <p>Agora vamos criar nosso Act recebendo o conte\u00fado do nosso terminal gerado, pra isso vamos usar a fun\u00e7\u00e3o auxiliar <code>get_buffer_content</code> que criamos</p> <pre><code>#[test]\nfn test_draw_header_contains_required_elements() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 3);\n    terminal.draw(|f| draw_header(f, area)).unwrap();\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n\n}\n</code></pre> <p>Finalmente vamos agora verificar se contem nele existem as strings que precisamos, pra isso vamos usar a macro <code>assert!</code> e pra verificar vamos usar o pr\u00f3prio m\u00e9todo contains que existe dentro da <code>struct String</code>.</p> <pre><code>#[test]\nfn test_draw_header_contains_required_elements() {\n    //Assert\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 3);\n    terminal.draw(|f| draw_header(f, area)).unwrap();\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n\n    // Assert\n    assert!(\n        content.contains(\"Wordsearch\"), \"Should have a title\"\n    );\n    assert!(content.contains(\"Time:\"), \"Should have a label Time\");\n    assert!(\n        content.contains(\"Found:\"),\n        \"Should have a label Found\"\n    );\n}\n</code></pre> <p>Agora vamos rodar nosso teste e devemos receber a falha abaixo:</p> <pre><code>failures:\n\n---- test_draw_header_contains_required_elements stdout ----\n\nthread 'test_draw_header_contains_required_elements' panicked at tests/tests_ui.rs:49:5:\nShould have a title\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n</code></pre> <p>Agora precisamos desenhar em si nosso header. Vamos criar uma <code>String</code> para exibir o tempo.</p> <pre><code>pub fn draw_header(f: &amp;mut Frame, area: Rect) {\n    let time_str = String::from(\"Time: \");\n\n</code></pre> <p>Agora vamos pra um t\u00f3pico novo dentro do <code>ratatui</code>, vamos trabalhar com a <code>struct Span</code>  para criar nossos textos e para formata-los vamos chamar o m\u00e9todo <code>styled</code>. Dentro de <code>styled</code> vamos usar a <code>struct Style</code> para aplicar as formata\u00e7\u00f5es, e sempre vamos chamar seu construtor <code>default</code> para j\u00e1 nos entregar os atributos m\u00ednimos preenchidos para facilitar nossa vida.</p> <p>Essa \u00e9 uma forma parecida com uma formata\u00e7\u00e3o <code>html</code>, assim podemos aplicar formata\u00e7\u00e3o de texto de forma mais conhecida para saber mais sobre as nossas op\u00e7\u00f5es de estilos voc\u00ea pode ver na documenta\u00e7\u00e3o.</p> <p>Para criar nosso t\u00edtulo vamos criar um vetor chamado <code>header_text</code> e ele vai receber um vetor de Line que basicamente consiste em um ou mais spans. Ent\u00e3o vamos adicionar um span para a palavra <code>Wordsearch</code> um para <code>Found</code> e vamos criar um espa\u00e7amento entre essas palavras usando <code>Span::raw</code> j\u00e1 que vai ser um texto vazio apenas.</p> <p>Vamos tamb\u00e9m por um \u00edcone de lupa no nosso <code>header</code> pra isso vamos copiar o emoji atrav\u00e9s do site do <code>emojipedia</code>.</p> <pre><code>pub fn draw_header(f: &amp;mut Frame, area: Rect) {\n    let time_str = String::new(\"Time: \");\n\n    let header_text = vec![Line::from(vec![\n        Span::styled(\n            \"\ud83d\udd0d Wordsearch\",\n            Style::default()\n                .fg(Color::Yellow.into())\n                .add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(\"  \"),\n        Span::styled(time_str, Style::default().fg(Color::Cyan.into())),\n        Span::raw(\"  \"),\n        Span::styled(format!(\"Found: \",), Style::default().fg(Color::Green.into())),\n    ])];\n</code></pre> <p>Finalmente podemos fazer o render em si, agora precisamos para isso criar uma vari\u00e1vel <code>header</code> com ela vamos construir um <code>Paragraph</code> que \u00e9 um widget que mostra um texto.</p> <p>Ainda n\u00e3o falei dos widgets mas, basicamente um widget \u00e9 um trecho de c\u00f3digo reutiliz\u00e1vel para renderizar algum elemento da tela, pense como um peda\u00e7o do layout da sua tela, eles s\u00e3o uteis pois s\u00e3o elementos que podemos reutilizar e representam algum aspecto da nossa tela, seja um texto, um bot\u00e3o ou qualquer outro elemento visual que precisamos.</p> <p>Al\u00e9m do <code>Paragraph</code> n\u00f3s queremos que nosso header tenha uma borda, no <code>ratatui</code> precisamos nesse caso criar uma <code>Block</code> e tamb\u00e9m vamos chamar o m\u00e9todo <code>default()</code> para preencher com os valores m\u00ednimos.</p> <p>E pra finalizar nossa formata\u00e7\u00e3o vamos usar uma <code>struct Wrap</code> para configurar a quebra de linha e a op\u00e7\u00e3o <code>trim</code> que \u00e9 para ajustar os espa\u00e7os, assim nossos textos n\u00e3o v\u00e3o ficar cortados e v\u00e3o se ajustar ao tamanho da tela de exibi\u00e7\u00e3o, ent\u00e3o se voc\u00ea n\u00e3o estiver usando o terminal como eu em tela cheia vai perceber que ele vai ajustar o texto com o tamanho da sua tela de terminal e n\u00e3o vai cortar o texto.</p> <pre><code>pub fn draw_header(f: &amp;mut Frame, area: Rect) {\n    let time_str = String::new(\"Time: \");\n\n    let header_text = vec![Line::from(vec![\n        Span::styled(\n            \"\ud83d\udd0d Wordsearch\",\n            Style::default()\n                .fg(Color::Yellow.into())\n                .add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(\"  \"),\n        Span::styled(time_str, Style::default().fg(Color::Cyan.into())),\n        Span::raw(\"  \"),\n        Span::styled(format!(\"Found: \",), Style::default().fg(Color::Green.into())),\n    ])];\n\n    let header = Paragraph::new(header_text)\n        .block(Block::default().borders(Borders::ALL))\n        .wrap(Wrap { trim: true });\n\n    f.render_widget(header, area);\n}\n\n</code></pre> <p>Agora podemos rodar os testes novamente:</p> <pre><code>cargo test\nrunning 2 tests\ntest test_draw_header_contains_required_elements ... ok\ntest test_draw_header_renders_successfully ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests wordsearch\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Com o nosso teste funcionando vamos adicionar agora no nosso main dentro do nosso render. Vamos passar a posi\u00e7\u00e3o 0 do nosso chunks que \u00e9 a parte do layout do <code>header</code>.</p> <pre><code>fn render(frame: &amp;mut Frame) {\n    let size = frame.area();\n\n    // Layout principal\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(3), // Header\n            Constraint::Min(0),    // Game area\n            Constraint::Length(3), // Footer\n        ])\n        .split(size);\n\n    // Header com informa\u00e7\u00f5es do jogo\n    draw_header(frame, chunks[0]);\n\n</code></pre>"},{"location":"1_4_caca_palavras/#option-result-wrap-unwrap-e-expect","title":"Option, Result, Wrap, Unwrap e Expect","text":"<p>Bom agora chegou a hora de falarmos de algumas coisas que estamos usando a algum tempo e at\u00e9 agora voc\u00ea sabia que existia e n\u00e3o entramos muito a fundo e agora chegou a hora.</p>"},{"location":"1_4_caca_palavras/#wrap","title":"Wrap","text":"<p>Antes de falar sobre desembrulhar (unwrap), precisamos entender como embrulhar valores em Rust. Pense nisso como colocar um presente em uma caixa: Nesse presente temos o conte\u00fado que queremos dar e ele pode vir com um valor que queremos, ou vazio ou ainda com uma mensagem do por que n\u00e3o pode entregar o conte\u00fado. Em rust por default vai querer embrulhar sua resposta no m\u00e9todo <code>main</code> que \u00e9 o nosso <code>Result</code> mas, tamb\u00e9m durante esse curso algumas vezes embrulhamos nossos valores usando um <code>Option</code>.</p>"},{"location":"1_4_caca_palavras/#option","title":"Option <p>Option \u00e9 um <code>enum</code> (tipo enumerado) que representa a possibilidade de ter um valor ou n\u00e3o ter nada. Ele tem dois poss\u00edveis estados: <p>Some(valor): O valor existe e pode ser acessado None: N\u00e3o h\u00e1 valor \u2014 represente o \"vazio\" com seguran\u00e7a</p> <pre><code>fn recuperar_muni\u00e7\u00e3o_do_arsenal(tipo: &amp;str) -&gt; Option&lt;i32&gt; {\n    match tipo {\n        \"m\u00edssil\" =&gt; Some(5),        // Temos 5 m\u00edsseis\n        \"laser\" =&gt; Some(999),       // Energia infinita de laser\n        \"plasma\" =&gt; None,           // N\u00e3o temos plasma, estamos sem ele\n        _ =&gt; None,                  // Tipo desconhecido = nada\n    }\n}\n\nfn equipar_arma() {\n    let muni\u00e7\u00e3o = recuperar_muni\u00e7\u00e3o_do_arsenal(\"m\u00edssil\");\n\n    match muni\u00e7\u00e3o {\n        Some(qtd) =&gt; println!(\"Equipado! Temos {} m\u00edsseis!\", qtd),\n        None =&gt; println!(\"Arsenal vazio! Sem muni\u00e7\u00e3o desse tipo.\"),\n    }\n}\n</code></pre> <p>Voc\u00ea usa Option quando uma opera\u00e7\u00e3o pode n\u00e3o retornar nada, mas n\u00e3o h\u00e1 um \"erro\" em sentido t\u00e9cnico. Por exemplo: buscar o primeiro soldado em uma lista (pode n\u00e3o haver nenhum), procurar um item em um mapa (pode n\u00e3o ter sido guardado l\u00e1), ou verificar se um inimigo foi detectado pelo radar (o sensor pode estar desligado ou n\u00e3o ter alvos). O Rust for\u00e7a voc\u00ea a lidar com ambos os casos, eliminando bugs silenciosos onde voc\u00ea acessa null por acidente.</p> <p>Essa \u00e9 a forma dele tratar o famoso null pointer assim ao inv\u00e9s de checar se o valor \u00e9 nulo n\u00f3s verificamos se h\u00e1 algo ali.</p>","text":""},{"location":"1_4_caca_palavras/#metodos-uteis","title":"M\u00e9todos \u00fateis","text":"<pre><code>let valor = Some(42);\n\n// unwrap_or: se Some, retorna; se None, retorna padr\u00e3o\nlet resultado = valor.unwrap_or(0);  // 42\n\n// map: transforma o valor se existir\nlet dobrado = valor.map(|x| x * 2);  // Some(84)\n\n// is_some / is_none: verifica\u00e7\u00f5es simples\nif valor.is_some() {\n    println!(\"Tem valor!\");\n}\n</code></pre>"},{"location":"1_4_caca_palavras/#result","title":"Result <p>Agora vamos para algo que usamos muito no nosso dia-a-dia com rust, o Result \u00e9 um <code>enum</code> com dois poss\u00edveis estados que representa o resultado de uma opera\u00e7\u00e3o que pode falhar: <p>Ok(valor): A opera\u00e7\u00e3o funcionou e retorna um valor do tipo T Err(erro): A opera\u00e7\u00e3o falhou e retorna informa\u00e7\u00f5es sobre o erro do tipo E</p> <pre><code>fn conectar_ao_servidor_central(endere\u00e7o: &amp;str) -&gt; Result&lt;String, String&gt; {\n    // Simulando tentativa de conex\u00e3o\n    if endere\u00e7o.contains(\"v\u00e1lido\") {\n        Ok(\"Conex\u00e3o estabelecida com sucesso!\".to_string())\n    } else {\n        Err(\"Erro: Endere\u00e7o do servidor inv\u00e1lido\".to_string())\n    }\n}\n\n// Usando o resultado\nfn sincronizar_dados() {\n    let resultado = conectar_ao_servidor_central(\"servidor-v\u00e1lido.com\");\n\n    match resultado {\n        Ok(mensagem) =&gt; println!(\"\u2713 {}\", mensagem),\n        Err(erro) =&gt; println!(\"\u2717 Falha: {}\", erro),\n    }\n}\n</code></pre> <p>Voc\u00ea usa Result quando uma opera\u00e7\u00e3o pode ter sucesso ou falha com uma raz\u00e3o espec\u00edfica. Por exemplo: conectar ao servidor central (pode falhar por rede), ler dados do sensores (pode haver interfer\u00eancia), ou disparar a arma principal (pode travar). A diferen\u00e7a crucial: com Result, voc\u00ea sabe por que algo falhou, n\u00e3o s\u00f3 que falhou.</p>","text":""},{"location":"1_4_caca_palavras/#metodos-uteis_1","title":"M\u00e9todos \u00fateis <pre><code>let resultado = Ok::&lt;i32, String&gt;(50);\n\n// unwrap_or: se Ok, retorna; se Err, retorna padr\u00e3o\nlet valor = resultado.unwrap_or(0);  // 50\n\n// map: transforma o Ok se existir\nlet dobrado = resultado.map(|x| x * 2);  // Ok(100)\n\n// ? (operador try): retorna Err imediatamente (aprenderemos depois!)\nfn operacao() -&gt; Result&lt;i32, String&gt; {\n    let x = disparar_arma_principal(100)?;  // Se falhar, retorna o erro\n    Ok(42)\n}\n</code></pre>","text":""},{"location":"1_4_caca_palavras/#unwrap-expect","title":"unwrap - expect <p>Em Rust, tanto Option quanto Result encapsulam valores que podem ou n\u00e3o estar presentes. \u00c0s vezes, por\u00e9m, voc\u00ea est\u00e1 absolutamente certo de que o valor existe (ou aceita que o programa falhe se n\u00e3o existir). \u00c9 a\u00ed que unwrap() e expect() entram em cena. O que fazem esses m\u00e9todos? unwrap() extrai o valor interno de um Option ou Result. Se for Some(valor) ou Ok(valor), voc\u00ea recebe valor. Se for None ou Err(e), o programa entra em p\u00e2nico (panic) e termina com uma mensagem gen\u00e9rica: <pre><code>fn main() {\n    let combustivel: Option&lt;u32&gt; = Some(100);\n    let quantidade = combustivel.unwrap(); // 100 \u2014 tudo certo!\n\n    let vazio: Option&lt;u32&gt; = None;\n    // let falha = vazio.unwrap(); // \u26a0\ufe0f PANIC: \"called `Option::unwrap()` on a `None` value\"\n\n}\n</code></pre>","text":""},{"location":"1_4_caca_palavras/#expect","title":"Expect <p>expect(mensagem) faz o mesmo que unwrap(), mas permite que voc\u00ea forne\u00e7a uma mensagem personalizada de erro. Isso torna o p\u00e2nico mais informativo durante a depura\u00e7\u00e3o:</p> <pre><code>let resultado: Result&lt;String, &amp;str&gt; = Err(\"falha no reator\");\n// let comando = resultado.expect(\"Sistema de propuls\u00e3o falhou!\"); \n// \u26a0\ufe0f PANIC: \"Sistema de propuls\u00e3o falhou!: falha no reator\"\n</code></pre> <p>Quando usar unwrap/expect?</p> <ul> <li>Em testes unit\u00e1rios: onde voc\u00ea quer que o teste falhe imediatamente se algo inesperado acontecer.</li> <li>Em prot\u00f3tipos: para desenvolvimento r\u00e1pido antes de adicionar tratamento de erros robusto.</li> <li>Quando h\u00e1 garantia l\u00f3gica: por exemplo, depois de verificar explicitamente com is_some() ou is_ok()</li> <li>Em c\u00f3digo de exemplo: para manter a clareza sem distrair com tratamento de erros</li> </ul>","text":""},{"location":"1_4_caca_palavras/#boas-praticas","title":"Boas pr\u00e1ticas <p>Em c\u00f3digo de produ\u00e7\u00e3o, prefira m\u00e9todos que n\u00e3o causam p\u00e2nico:</p> <pre><code>// \u274c Perigoso em produ\u00e7\u00e3o\nlet valor = opcao.unwrap();\n\n// \u2705 Tratamento seguro com match\nlet valor = match opcao {\n    Some(v) =&gt; v,\n    None =&gt; return Err(\"Valor ausente\"),\n};\n\n// \u2705 Valor padr\u00e3o com unwrap_or\nlet valor = opcao.unwrap_or(0);\n\n// \u2705 Computa\u00e7\u00e3o lazy com unwrap_or_else  \nlet valor = opcao.unwrap_or_else(|| calcular_padrao());\n\n// \u2705 Propaga\u00e7\u00e3o de erros com ?\nlet valor = resultado?;\n</code></pre>","text":""},{"location":"1_4_caca_palavras/#operador","title":"Operador ? <p>O operador ? \u00e9 uma forma elegante e segura de desembrulhar valores, mas ao inv\u00e9s de causar p\u00e2nico, ele propaga o erro para quem chamou a fun\u00e7\u00e3o. \u00c9 como dizer: \"Se der erro aqui, eu n\u00e3o posso resolver, ent\u00e3o passo o problema para cima\".</p> <pre><code>// \u274c Sem o operador ? (verbose)\nfn processar_dados() -&gt; Result&lt;String, String&gt; {\n    let dado1 = match obter_dado1() {\n        Ok(d) =&gt; d,\n        Err(e) =&gt; return Err(e),  // Propagar erro manualmente\n    };\n\n    let dado2 = match obter_dado2() {\n        Ok(d) =&gt; d,\n        Err(e) =&gt; return Err(e),  // Propagar erro manualmente\n    };\n\n    Ok(format!(\"{} {}\", dado1, dado2))\n}\n\n// \u2705 Com o operador ? (limpo e conciso)\nfn processar_dados() -&gt; Result&lt;String, String&gt; {\n    let dado1 = obter_dado1()?;  // Se Err, retorna automaticamente\n    let dado2 = obter_dado2()?;  // Se Err, retorna automaticamente\n\n    Ok(format!(\"{} {}\", dado1, dado2))\n}\n</code></pre> <p>O operador ? faz tr\u00eas coisas:</p> <p>Se Ok/Some: Desembrulha o valor e continua Se Err/None: Converte e retorna o erro imediatamente Convers\u00e3o autom\u00e1tica: Converte tipos de erro compat\u00edveis</p> <p>\u2705 USE quando:</p> <p>A fun\u00e7\u00e3o j\u00e1 retorna Result ou Option Voc\u00ea quer propagar erros para o chamador N\u00e3o precisa fazer tratamento local do erro Quer c\u00f3digo limpo e conciso</p> <p>\u274c N\u00c3O use quando:</p> <p>Precisa tratar o erro localmente Quer fornecer valor padr\u00e3o (use unwrap_or etc.) Os tipos de erro n\u00e3o s\u00e3o compat\u00edveis</p> <p>Diferen\u00e7a entre ?, unwrap e match:</p> <pre><code>// Operador ? - Propaga erro (seguro, requer Result/Option)\nlet valor = funcao_que_pode_falhar()?;\n\n// unwrap - Causa p\u00e2nico (perigoso)\nlet valor = funcao_que_pode_falhar().unwrap();\n\n// match - Tratamento expl\u00edcito (verboso mas claro)\nlet valor = match funcao_que_pode_falhar() {\n    Ok(v) =&gt; v,\n    Err(e) =&gt; return Err(e),\n};\n</code></pre> <p>Exemplo pr\u00e1tico em um sistema de mecha:</p> <pre><code>use std::collections::HashMap;\n\nstruct SistemaMecha {\n    energia: HashMap&lt;String, u32&gt;,\n}\n\nimpl SistemaMecha {\n    fn obter_energia(&amp;self, sistema: &amp;str) -&gt; Option&lt;u32&gt; {\n        self.energia.get(sistema).copied()\n    }\n\n    // \u274c Vers\u00e3o perigosa - pode causar panic\n    fn ativar_arma_inseguro(&amp;self) {\n        let energia = self.obter_energia(\"arma\").unwrap();\n        println!(\"Arma ativada com {} unidades\", energia);\n    }\n\n    // \u2705 Vers\u00e3o segura - retorna Result\n    fn ativar_arma_seguro(&amp;self) -&gt; Result&lt;(), String&gt; {\n        let energia = self.obter_energia(\"arma\")\n            .ok_or_else(|| \"Sistema de arma sem energia!\".to_string())?;\n\n        if energia &lt; 10 {\n            return Err(\"Energia insuficiente para disparo!\".to_string());\n        }\n\n        println!(\"Arma ativada com {} unidades\", energia);\n        Ok(())\n    }\n}\n</code></pre> <p>Lembre-se quando usamos unwrap() \u00e9 como um bot\u00e3o de eje\u00e7\u00e3o, use apenas quando estiver preparado para as consequ\u00eancias ou quando tiver certeza absoluta de que \u00e9 seguro.</p>","text":""},{"location":"1_4_caca_palavras/#macros","title":"Macros","text":"<p>Existem dois tipos principais de macros em Rust: macros declarativas (definidas com [macro_rules!]https://doc.rust-lang.org/rust-by-example/macros.html) e macros procedurais (que s\u00e3o fun\u00e7\u00f5es especiais anotadas com atributos). As macros declarativas funcionam atrav\u00e9s de pattern matching, voc\u00ea define padr\u00f5es de sintaxe que a macro deve reconhecer e especifica o c\u00f3digo que deve ser gerado quando esse padr\u00e3o \u00e9 encontrado. Elas s\u00e3o como um match expression super-poderoso que trabalha com tokens de c\u00f3digo ao inv\u00e9s de valores. As macros procedurais, por outro lado, s\u00e3o mais flex\u00edveis e podem manipular o AST (Abstract Syntax Tree) diretamente, mas tamb\u00e9m s\u00e3o mais complexas e requerem uma crate separada.</p> <p>Exemplo B\u00e1sico: Macro declarativa</p> <pre><code>macro_rules! log_status {\n    ($msg:expr) =&gt; {\n        println!(\"[STATUS] {}\", $msg);\n    };\n\n    ($level:expr, $msg:expr) =&gt; {\n        println!(\"[{}] {}\", $level, $msg);\n    };\n}\n\nfn main() {\n    log_status!(\"Sistema inicializado\");\n    log_status!(\"INFO\", \"Todos os sistemas operacionais\");\n\n    // println!(\"[STATUS] {}\", \"Sistema inicializado\");\n    // println!(\"[{}] {}\", \"INFO\", \"Todos os sistemas operacionais\");\n}\n</code></pre> <p>Fragmentos de Sintaxe (Fragment Specifiers) Macros podem capturar diferentes tipos de elementos sint\u00e1ticos:</p> <p>expr - express\u00f5es (como 2 + 2, minha_funcao()) ident - identificadores (nomes de vari\u00e1veis, fun\u00e7\u00f5es) ty - tipos (i32, Vec) stmt - statements (declara\u00e7\u00f5es) block - blocos de c\u00f3digo ({ ... }) tt - token tree (qualquer token) literal - literais (42, \"texto\") <pre><code>macro_rules! comando_mecha {\n    // Captura um identificador (nome da a\u00e7\u00e3o)\n    ($acao:ident) =&gt; {\n        println!(\"Executando comando: {}\", stringify!($acao));\n    };\n\n    // Captura um identificador e uma express\u00e3o (com par\u00e2metro)\n    ($acao:ident, $param:expr) =&gt; {\n        println!(\"Executando {}: com par\u00e2metro {}\", \n                 stringify!($acao), $param);\n    };\n}\n\nfn main() {\n    comando_mecha!(avan\u00e7ar);           // Identifica a a\u00e7\u00e3o\n    comando_mecha!(girar, 90);         // A\u00e7\u00e3o com par\u00e2metro\n}\n</code></pre> <p>Por que usar Macros?</p> <p>Evitar repeti\u00e7\u00e3o de c\u00f3digo (DRY - Don't Repeat Yourself): quando voc\u00ea tem um padr\u00e3o que se repete mas n\u00e3o pode ser abstra\u00eddo com fun\u00e7\u00f5es Criar DSLs (Domain-Specific Languages): criar sintaxe customizada para seu dom\u00ednio Interfaces vari\u00e1veis: aceitar n\u00famero vari\u00e1vel de argumentos (como println!, vec!) Gera\u00e7\u00e3o de c\u00f3digo em tempo de compila\u00e7\u00e3o: zero overhead em runtime Capturar informa\u00e7\u00f5es do contexto: como file!(), line!(), column!() que fun\u00e7\u00f5es n\u00e3o conseguem</p>"},{"location":"1_4_caca_palavras/#trabalhando-com-o-footer","title":"Trabalhando com o footer","text":"<p>Agora vamos come\u00e7ar a desenhar nosso footer, primeiro vamos criar um teste parecido com o header pra ver se ele consegue chamar a fun\u00e7\u00e3o <code>draw_footer</code>.</p> <pre><code>#[test]\nfn test_draw_footer_renders_successfully() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 4);\n\n    // Act - Assert\n    terminal\n        .draw(|f| draw_footer(f, area))\n        .expect(\"draw_footer should render\");\n}\n</code></pre> <p>Agora vamos rodar o nosso teste:</p> <pre><code>\u276f cargo test\n   Compiling wordsearch v0.1.0 (/home/feanor/projects/wordsearch)\nerror[E0425]: cannot find function `draw_footer` in this scope\n   --&gt; tests/tests_ui.rs:108:19\n    |\n108 |         .draw(|f| draw_footer(f, area))\n    |                   ^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `wordsearch` (test \"tests_ui\") due to 1 previous error\n</code></pre> <p>Certo isso acontece por que n\u00e3o temos uma fun\u00e7\u00e3o <code>draw_footer</code> ainda. Ent\u00e3o vamos cria-la e ele vai seguir a mesma assinatura do nosso <code>draw_header</code> pois eles possuem a mesma fun\u00e7\u00e3o.</p> <pre><code>//ui.rs\npub fn draw_footer(f: &amp;mut Frame, area: Rect) {\n}\n</code></pre> <p>Agora importamos ele no teste e vamos executar novamente.</p> <pre><code>running 3 tests\ntest test_draw_header_renders_successfully ... ok\ntest test_draw_footer_renders_successfully ... ok\ntest test_draw_header_contains_required_elements ... ok\n\n</code></pre> <p>Para o footer vamos precisar colocar os comandos do jogo pra auxiliar nosso jogador e pra isso vamos criar um teste que verifique se o footer tem os comandos. Pra isso vamos criar um vetor que vai armazenar uma tupla com duas <code>&amp;str</code>.</p> <pre><code>#[test]\nfn test_draw_footer_contains_all_controls() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 4);\n    terminal.draw(|f| draw_footer(f, area)).unwrap();\n    let controls = vec![\n        (\"Move\", \"movement in grid\"),\n        (\"Select\", \"selection letter\"),\n        (\"Confirm\", \"confirmation\"),\n        (\"Clean\", \"clean selection\"),\n        (\"Close\", \"close game\"),\n    ];\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n}\n</code></pre> <p>Agora pra testarmos a fun\u00e7\u00e3o vamos criar um loop onde vamos comparar se na nossa vari\u00e1vel content h\u00e1 as strings que est\u00e3o em controls e pra isso vamos criar um  for que vai percorrer o vetor de controls e desestruturar a tupla em duas vari\u00e1veis pra percorrermos durante o nosso loop e comparar com o conte\u00fado de content.</p> <pre><code>#[test]\nfn test_draw_footer_contains_all_controls() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 4);\n    terminal.draw(|f| draw_footer(f, area)).unwrap();\n    let controls = vec![\n        (\"Move\", \"movement in grid\"),\n        (\"Select\", \"selection letter\"),\n        (\"Confirm\", \"confirmation\"),\n        (\"Clean\", \"clean selection\"),\n        (\"Close\", \"close game\"),\n    ];\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n\n    // Assert\n    for (action, description) in controls {\n        assert!(\n            content.contains(action),\n            \"Should control for {}: '{}'\",\n            description,\n            action\n        );\n    }\n}\n</code></pre> <p>Agora rodando vamos ter a falha que vai ser o texto dentro do nosso assert.</p> <pre><code>\nfailures:\n\n---- test_draw_footer_contains_all_controls stdout ----\n\nthread 'test_draw_footer_contains_all_controls' panicked at tests/tests_ui.rs:95:9:\nShould control for movement in grid: 'move'\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Certo agora vamos implementar nossa fun\u00e7\u00e3o passando todos os controles que queremos.</p> <pre><code>fn draw_footer(f: &amp;mut Frame, area: Rect) {\n    let footer_text = vec![\n        Line::from(vec![\n            Span::raw(\"Controls: \"),\n            Span::styled(\"\u2191\u2193\u2190\u2192\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" Move | \"),\n            Span::styled(\"SPACE\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" Select | \"),\n            Span::styled(\"ENTER\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" Confirm | \"),\n            Span::styled(\"c\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" Clean | \"),\n            Span::styled(\"q/ESC\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" Close\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"Status: \", Style::default().fg(Color::Cyan)),\n            Span::raw(\" \"),\n        ]),\n    ];\n\n    let footer = Paragraph::new(footer_text)\n        .block(Block::default().borders(Borders::ALL))\n        .wrap(Wrap { trim: true });\n\n    f.render_widget(footer, area);\n}\n\n</code></pre> <p>Agora rodamos os testes e vemos que tudo est\u00e1 funcionando:</p> <pre><code>running 4 tests\ntest test_draw_header_renders_successfully ... ok\ntest test_draw_header_contains_required_elements ... ok\ntest test_draw_footer_renders_successfully ... ok\ntest test_draw_footer_contains_all_controls ... ok\n</code></pre> <p>Agora precisamos colocar nossa fun\u00e7\u00e3o footer no <code>main.rs</code></p> <pre><code>fn main() {\n    //c\u00f3digo\n\n    // Header\n    draw_header(frame, chunks[0]);\n    // Footer\n    draw_footer(frame, chunks[2]);\n\n}\n</code></pre> <p>Importante refor\u00e7ar que o footer como \u00e9 a ultima parte do nosso layout ele vai pro <code>chunks[2]</code> e podemos ver ele funcionando.</p> <p>Vamos criar agora mais um teste para complementar o anterior e verificar se todos os comandos foram inseridos. Isso \u00e9 importante pra termos certeza que todas as op\u00e7\u00f5es est\u00e3o a vista do jogador.</p> <pre><code>#[test]\nfn test_draw_footer_shows_control_keys() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 4);\n    terminal.draw(|f| draw_footer(f, area)).unwrap();\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n    let has_arrow_keys = content.contains(\"\u2191\") || content.contains(\"\u2193\");\n    let has_space = content.contains(\"SPACE\");\n    let has_enter = content.contains(\"ENTER\");\n    let has_clear = content.contains(\"c\");\n    let has_quit = content.contains(\"q\") || content.contains(\"ESC\");\n\n    // Assert\n    assert!(has_arrow_keys, \"Should have the movement keys\");\n    assert!(has_space, \"Should show key space\");\n    assert!(has_enter, \"Should show key enter\");\n    assert!(has_clear, \"Should show key c\");\n    assert!(has_quit, \"Should show quit keys\");\n}\n</code></pre> <p>Agora verificando os testes:</p> <pre><code>test test_draw_header_renders_successfully ... ok\ntest test_draw_header_contains_required_elements ... ok\ntest test_draw_footer_shows_control_keys ... ok\ntest test_draw_footer_renders_successfully ... ok\ntest test_draw_footer_contains_all_controls ... ok\n</code></pre> <p>Perfeito tudo funcionando! Agora podemos ir desenhar nosso grid.</p>"},{"location":"1_4_caca_palavras/#desenhando-o-grid","title":"Desenhando o grid","text":"<p>O grid ser\u00e1 necess\u00e1rio dividir em partes, nesse primeiro momento s\u00f3 vamos desenha-lo. Mas, ainda n\u00e3o vamos por as palavras.</p> <p>Para iniciar vamos fazer aquele teste b\u00e1sico de ver se nosso layout de grid vai renderizar corretamente.</p> <pre><code>#[test]\nfn test_draw_grid_renders_successfully() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 20);\n\n    // Act - Assert\n    terminal\n        .draw(|f| draw_grid(f, area))\n        .expect(\"draw_grid deve renderizar sem erros\");\n}\n</code></pre> <p>Agora temos o erro que ele n\u00e3o est\u00e1 no escopo:</p> <pre><code>error[E0425]: cannot find function `draw_grid` in this scope\n   --&gt; tests/tests_ui.rs:136:19\n    |\n136 |         .draw(|f| draw_grid(f, area))\n    |                   ^^^^^^^^^ not found in this scope\n</code></pre> <p>Como as fun\u00e7\u00f5es anteriores, vamos criar nossa fun\u00e7\u00e3o <code>draw_grid</code> e tamb\u00e9m vamos importar no nosso teste.</p> <pre><code>pub fn draw_grid(f: &amp;mut Frame, area: Rect) {\n}\n</code></pre> <p>Agora se rodarmos os testes vamos ver que est\u00e1 tudo funcionando:</p> <pre><code>running 6 tests\ntest test_draw_footer_shows_control_keys ... ok\ntest test_draw_grid_renders_successfully ... ok\ntest test_draw_footer_contains_all_controls ... ok\ntest test_draw_header_renders_successfully ... ok\ntest test_draw_footer_renders_successfully ... ok\ntest test_draw_header_contains_required_elements ... ok\n</code></pre> <p>Vamos criar um t\u00edtulo na parte do grid mas, antes vamos criar um teste para verificar se nosso grid tem o t\u00edtulo Grade.</p> <pre><code>#[test]\nfn test_draw_grid_has_title() {\n    // Setup\n    let mut terminal = setup_terminal();\n    let area = Rect::new(0, 0, 80, 20);\n    terminal.draw(|f| draw_grid(f, area)).unwrap();\n\n    // Act\n    let content = get_buffer_content(&amp;terminal);\n\n    // Assert\n    assert!(\n        content.contains(\"Grade\"),\n        \"Should a title 'Grade'\"\n    );\n}\n</code></pre> <p>Certo o teste agora falhou:</p> <pre><code>failures:\n\n---- test_draw_grid_has_title stdout ----\n\nthread 'test_draw_grid_has_title' panicked at tests/tests_ui.rs:151:5:\nShould a title 'Grade'\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Vamos criar um t\u00edtulo no nosso grid layout. Nesse caso vamos criar um bloco e al\u00e9m de criar as bordas vamos dar a esse bloco o t\u00edtulo Grade que queremos.</p> <pre><code>pub fn draw_grid(f: &amp;mut Frame, area: Rect) {\n    let block = Block::default().title(\"Grade\").borders(Borders::ALL);\n\n    f.render_widget(block, area);\n}\n</code></pre> <p>Rodamos os testes:</p> <pre><code>running 7 tests\ntest test_draw_grid_has_title ... ok\ntest test_draw_footer_renders_successfully ... ok\ntest test_draw_header_renders_successfully ... ok\ntest test_draw_grid_renders_successfully ... ok\ntest test_draw_header_contains_required_elements ... ok\ntest test_draw_footer_shows_control_keys ... ok\ntest test_draw_footer_contains_all_controls ... ok\n</code></pre> <p>Agora vamos adicionar ao nosso grid a nosso render.</p> <pre><code>fn render(frame: &amp;mut Frame) {\n    // Header\n    draw_header(frame, chunks[0]);\n    // Grid\n    draw_grid(frame, chunks[1]);\n    // Footer\n    draw_footer(frame, chunks[2]);\n}\n\n</code></pre> <p>Rodamos o nosso projeto e vemos que agora temos todos os elementos da nossa tela desenhados.</p>"},{"location":"1_4_caca_palavras/#arquitetando-nosso-grid-system","title":"Arquitetando nosso grid system","text":"<p>Vamos come\u00e7ar a trabalhar no nosso sistema que vai carregar as palavras e exibir na tela. Pra isso vamos come\u00e7ar vamos criar um novo m\u00f3dulo para ser respons\u00e1vel por todas as regras que s\u00e3o relativas ao jogo em si, vamos chama-la de <code>game</code>, tamb\u00e9m vamos criar um m\u00f3dulo que representa o nosso grid e chama-lo de <code>grid.rs</code>.</p> <pre><code>touch src/game.rs\ntouch src/grid.rs\n</code></pre> <p>Vamos deixar esse m\u00f3dulo publico dentro do nosso <code>lib.rs</code></p> <pre><code>pub mod ui;\npub mod game;\npub mod grid;\n\n</code></pre> <p>Para come\u00e7ar nosso desenvolvimento vamos ter que criar uma representa\u00e7\u00e3o do nosso grid.</p>"},{"location":"1_4_caca_palavras/#fundamentos-do-nosso-grid","title":"Fundamentos do nosso grid.","text":"<p>Agora preciso lhe explicar como vai funcionar nosso sistema de grid, primeiro teremos 4 estruturas distintas.</p>"},{"location":"1_4_caca_palavras/#grid","title":"Grid <p>Ele ser\u00e1 uma matriz de c\u00e9lulas onde cada c\u00e9lula vai ter uma letra.</p> <p>Grid (10x10) \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  P  A  L  A  V  R  A  S  X  Z       \u2502  \u2190 Linha 0 \u2502  R  U  S  T  O  M  N  Q  W  Y       \u2502  \u2190 Linha 1 \u2502  O  K  L  E  T  R  A  S  D  F       \u2502  \u2190 Linha 2 \u2502  G  H  J  K  L  M  N  O  P  Q       \u2502 \u2502  R  S  T  U  V  W  X  Y  Z  A       \u2502 \u2502  A  B  C  D  E  F  G  H  I  J       \u2502 \u2502  M  N  O  P  Q  R  S  T  U  V       \u2502 \u2502  A  W  X  Y  Z  A  B  C  D  E       \u2502 \u2502  R  F  G  H  I  J  K  L  M  N       \u2502 \u2502  Z  O  P  Q  R  S  T  U  V  W       \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</p> <p>Ai como vamos distribuir nossas palavras dentro dessa matriz?</p>","text":""},{"location":"1_4_caca_palavras/#position","title":"Position <p>Vamos precisar de uma <code>struct Position</code> nela vamos conseguir definir a posi\u00e7\u00e3o que vai ficar a primeira letra da nossa palavra.</p> <p></p>","text":""},{"location":"1_4_caca_palavras/#direction","title":"Direction <p>Vamos precisar tamb\u00e9m de uma <code>struct Direction</code> nela vamos definir se a palavra vai seguir na horizontal, vertical ou diagonal.</p> <p></p>","text":""},{"location":"1_4_caca_palavras/#wordplacement","title":"<code>Wordplacement</code> <p>Tamb\u00e9m precisamos de uma <code>struct Wordplacement</code> sua fun\u00e7\u00e3o vai ser a representa\u00e7\u00e3o da nossa palavra, com ele vamos ter a palavra em si, sua posi\u00e7\u00e3o, sua dire\u00e7\u00e3o e tamb\u00e9m um marcador pra indicar se ela foi encontrada ou n\u00e3o.</p> <p></p> <p>Agora vamos construir cada estrutura. Primeiro vamos criar nossa Position e ela vai ter um n\u00famero de coluna e linha, vamos cria-lo como um <code>usize</code>. Vamos adicionar as <code>traits</code> <code>Debug</code> e <code>Clone</code>.</p> <pre><code>//grid.rs\n#[derive(Debug, Clone)]\npub struct Position {\n    pub row: usize,\n    pub col: usize,\n}\n</code></pre> <p>A nossa Direction vai ser um <code>enum</code> com o nome das posi\u00e7\u00f5es. Vamos adicionar nele as <code>traits</code> <code>Debug</code>, <code>Clone</code> e <code>PartialEq</code></p> <pre><code>//grid.rs\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Direction {\n    Horizontal,\n    Vertical,\n    DiagonalDown,\n    DiagonalUp,\n}\n</code></pre> <p>O <code>Wordplacement</code> vai agregar como falamos anteriormente a palavra, posi\u00e7\u00e3o, dire\u00e7\u00e3o e se ela foi encontrada ou n\u00e3o.</p> <pre><code>//grid.rs\npub struct WordPlacement {\n    pub word: String,\n    pub start: Position,\n    pub direction: Direction,\n    pub found: bool,\n}\n</code></pre> <p>Finalmente vamos criar nosso <code>Grid</code> onde ele vai ser uma <code>struct</code> com suas c\u00e9lulas que ser\u00e1 um vetor de caracteres, as palavras a serem encontradas que ser\u00e3o um vetor de <code>WordPlacement</code> e seu tamanho que ser\u00e1 do tipo <code>usize</code>.</p> <pre><code>pub struct Grid {\n    cells: Vec&lt;Vec&lt;char&gt;&gt;,\n    pub size: usize,\n    pub words: Vec&lt;WordPlacement&gt;,\n}\n</code></pre> <p>Com isso j\u00e1 podemos come\u00e7ar a trabalhar com a l\u00f3gica do nosso jogo.</p>","text":""},{"location":"1_4_caca_palavras/#manipulando-arquivos-em-rust","title":"Manipulando arquivos em Rust","text":"<p>Para o nosso jogo vamos criar um arquivo de texto simples para armazenar as palavras que queremos que nosso jogador procure ent\u00e3o agora vamos precisar trabalhar com leitura e escrita de arquivos em rust pra isso vamos trabalhar com a biblioteca <code>fs</code> que j\u00e1 vem por padr\u00e3o.</p> <p>A biblioteca padr\u00e3o <code>std::fs</code> fornece pra n\u00f3s as funcionalidades para manipula\u00e7\u00e3o de arquivos e diret\u00f3rios do sistema de arquivos.</p> <p>Para come\u00e7armos a trabalhar com a leitura de arquivos vamos no nosso m\u00f3dulo <code>game</code> e criar uma nova <code>struct</code> que ser\u00e1 chamada de <code>GameState</code> onde ela vai controlar os estados do nosso jogo.</p> <pre><code>//game.rs\nuse crate::grid::Grid;\n\npub struct GameState {\n    pub grid: Grid,\n}\n</code></pre> <p>Agora queremos que nosso <code>GameState</code> com a responsabilidade de ler o arquivo pra isso queremos criar uma fun\u00e7\u00e3o <code>load_words_from_file</code> nele para que ele leia o conte\u00fado do arquivo e transforme pra n\u00f3s como um vetor de <code>String</code>. Mas, primeiro vamos criar um teste que j\u00e1 verifique isso ent\u00e3o vamos criar um novo arquivo de teste e criar duas fun\u00e7\u00f5es auxiliares uma pra criar um arquivo e outra pra deletar um arquivo.</p> <pre><code>touch /tests/tests_game.rs\n</code></pre> <pre><code>use std::fs;\nuse std::io;\n\n// Helper: cria arquivo tempor\u00e1rio para testes\nfn create_test_file(filename: &amp;str, content: &amp;str) {\n    fs::write(filename, content).expect(\"Error to create test file\");\n}\n\n// Helper: limpa arquivo de teste\nfn cleanup_test_file(filename: &amp;str) {\n    fs::remove_file(filename).ok();\n}\n</code></pre> <p>Com a fun\u00e7\u00e3o <code>fs::write</code> podemos passar o nome do arquivo e um conte\u00fado que se o arquivo n\u00e3o existir ele vai cria-lo.</p> <p>J\u00e1 a fun\u00e7\u00e3o <code>fs::remove_file</code> podemos passar um nome de arquivo e remove-lo.</p> <p>Com isso j\u00e1 podemos criar nosso primeiro teste para validar um arquivo.</p>"},{"location":"1_4_caca_palavras/#lendo-nosso-arquivo-de-palavras","title":"Lendo nosso arquivo de palavras","text":"<p>A primeira coisa que vamos fazer \u00e9 criar um teste pra verificar pra isso vamos criar um arquivo com as palavras \"rust\", \"python\" e \"java\". E vamos chamar nosso m\u00e9todo <code>load_words_from_file</code> e verificar se o tamanho e as palavras batem.</p> <p>No final do teste vamos chamar a fun\u00e7\u00e3o <code>cleanup_test_file</code> e ele vai ser nosso <code>Tear Down</code> que \u00e9 basicamente uma fun\u00e7\u00e3o que limpa nosso teste para que ele n\u00e3o afete os pr\u00f3ximos testes.</p> <pre><code>//tests_game.rs\n#[test]\nfn test_load_words_from_valid_file() {\n    // Setup\n    let filename = \"test_words_valid.txt\";\n    create_test_file(filename, \"rust\\npython\\njava\\n\");\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert_eq!(words.len(), 3, \"Expected 3 words\");\n    assert_eq!(words, vec![\"rust\", \"python\", \"java\"]);\n\n    // Tear down\n    cleanup_test_file(filename);\n}\n</code></pre> <p>Vamos adiantar e j\u00e1 criar o m\u00e9todo antes de rodar o teste. Vamos fazer ele receber um <code>&amp;str</code> chamado filename e vamos retornar um <code>Result</code> que vai ser um vetor de <code>String</code> e por ser um result vamos por que o retorno com erro vai ser um <code>io::Error</code>.</p> <pre><code>impl GameState {\n\n    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n    }\n}\n</code></pre> <pre><code>error[E0308]: mismatched types\n  --&gt; src/game.rs:12:52\n   |\n12 |     pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n   |            --------------------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;Vec&lt;String&gt;, Error&gt;`, found `()`\n   |            |\n   |            implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note:   expected enum `Result&lt;Vec&lt;String&gt;, std::io::Error&gt;`\n           found unit type `()`\n</code></pre> <p>A falha que deu agora, acontece por que definimos que ele vai retornar um result ent\u00e3o precisamos pelo menos empacotar um vetor de <code>String</code>, pra isso vamos usar a fun\u00e7\u00e3o <code>read_to_string</code> para ler nosso arquivo e salva-lo como um vetor.</p> <pre><code>\nimpl GameState {\n\n    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n        let content = fs::read_to_string(filename)?;\n        let words: Vec&lt;String&gt; = content\n            .lines()\n            .map(|line| line.to_string())\n            .collect();\n        Ok(words)\n    }\n}\n</code></pre> <p>Agora rodando os testes v\u00e3o passar. E agora estamos lendo com sucesso nosso arquivo gerado.</p> <pre><code>running 1 test\ntest test_load_words_from_valid_file ... ok\n</code></pre> <p>Vamos fazer algumas modifica\u00e7\u00f5es eu quero primeiro que nossas palavras sejam todas em caixa alta para isso vamos criar um teste que valide que as palavras s\u00e3o todas em caixa alta.</p> <pre><code>#[test]\nfn test_convert_all_words_to_uppercase() {\n    // Setup\n    let filename = \"test_mixed_case.txt\";\n    create_test_file(filename, \"rust\\nPython\\nJaVa\\nGO\");\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert!(words.iter().all(|w| w.chars().all(|c| c.is_uppercase())),\n        \"Should all words is uppercase, found: {:?}\", words);\n\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>running 2 tests\ntest should_convert_all_words_to_uppercase ... FAILED\ntest test_load_words_from_valid_file ... ok\n\nfailures:\n\n---- should_convert_all_words_to_uppercase stdout ----\n\nthread 'should_convert_all_words_to_uppercase' panicked at tests/tests_game.rs:40:5:\nShould all words is uppercase, found: [\"rust\", \"Python\", \"JaVa\", \"GO\"]\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Vamos refatorar nossa fun\u00e7\u00e3o e ao inv\u00e9s de usar o <code>to_string</code> vamos usar direto o m\u00e9todo <code>to_uppercase</code> para deixar todos os caracteres em caixa alta.</p> <pre><code>    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n        let content = fs::read_to_string(filename)?;\n        let words: Vec&lt;String&gt; = content\n            .lines()\n            .map(|line| line.to_uppercase())\n            .collect();\n\n        Ok(words)\n    }\n</code></pre> <pre><code>running 2 tests\ntest test_convert_all_words_to_uppercase ... ok\ntest test_load_words_from_valid_file ... FAILED\n\nfailures:\n\n---- test_load_words_from_valid_file stdout ----\n\nthread 'test_load_words_from_valid_file' panicked at tests/tests_game.rs:24:5:\nassertion `left == right` failed\n  left: [\"RUST\", \"PYTHON\", \"JAVA\"]\n right: [\"rust\", \"python\", \"java\"]\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Agora nosso teste anterior come\u00e7ou a falhar, isso por que o teste era em caixa baixa, ent\u00e3o vamos mudar o teste para tanto o setup quando o assert sejam em caixa alta.</p> <pre><code>#[test]\nfn test_load_words_from_valid_file() {\n    // Setup\n    let filename = \"test_words_valid.txt\";\n    create_test_file(filename, \"RUST\\nPYTHON\\nJAVA\\n\");\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert_eq!(words.len(), 3, \"Expected 3 words\");\n    assert_eq!(words, vec![\"RUST\", \"PYTHON\", \"JAVA\"]);\n\n    // Tear down\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>running 2 tests\ntest test_load_words_from_valid_file ... ok\ntest test_convert_all_words_to_uppercase ... ok\n</code></pre> <p>Temos que verificar agora se nosso texto quando tiver algumas sujeiras nas palavras como espa\u00e7o ou tabs eles precisam ser removidos.</p> <pre><code>#[test]\nfn test_trim_whitespace_from_words() {\n    // Setup\n    let filename = \"test_trim.txt\";\n    create_test_file(\n        filename,\n        \"  rust  \\n\\tpython\\t\\n   java  \"\n    );\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert_eq!(words, vec![\"RUST\", \"PYTHON\", \"JAVA\"]);\n    assert!(words.iter().all(|w| !w.starts_with(' ') &amp;&amp; !w.ends_with(' ')),\n        \"Words should'nt space or tabs\");\n\n    // Tear Down\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>---- test_trim_whitespace_from_words stdout ----\n\nthread 'test_trim_whitespace_from_words' panicked at tests/tests_game.rs:59:5:\nassertion `left == right` failed\n  left: [\"  RUST  \", \"\\tPYTHON\\t\", \"   JAVA  \"]\n right: [\"RUST\", \"PYTHON\", \"JAVA\"]\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    test_trim_whitespace_from_words\n</code></pre> <p>Agora vamos precisar adicionar o m\u00e9todo <code>trim</code> antes do <code>to_uppercase</code>.</p> <pre><code>    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n        let content = fs::read_to_string(filename)?;\n        let words: Vec&lt;String&gt; = content\n            .lines()\n            .map(|line| line.trim().to_uppercase())\n            .collect();\n\n        Ok(words)\n    }\n}\n</code></pre> <pre><code>running 3 tests\ntest test_convert_all_words_to_uppercase ... ok\ntest test_load_words_from_valid_file ... ok\ntest test_trim_whitespace_from_words ... ok\n</code></pre> <p>Agora j\u00e1 conseguimos garantir que nosso arquivo do jogo vai gerar as palavras da forma que queremos.</p>"},{"location":"1_4_caca_palavras/#analisando-os-casos-excepcionais","title":"Analisando os casos excepcionais","text":"<p>O que vai acontecer se nosso arquivo com as palavras tiver vazio ou ainda ele n\u00e3o existir? Normalmente vamos ter um arquivo l\u00e1, mas caso n\u00e3o tenha sabemos como nosso sistema vai se comportar? Chamamos isso de casos excepcionais ou casos de borda ou ainda edge cases que s\u00e3o comportamentos que s\u00f3 v\u00e3o acontecer em casos muito particulares. Vamos tentar fazer um teste para verificar.</p> <pre><code>#[test]\nfn test_return_error_when_file_does_not_exist() {\n    // Setup\n    let filename = \"file_not_found.txt\";\n\n    // Act\n    let result = GameState::load_words_from_file(filename);\n\n    // Assert\n    assert!(result.is_err(), \n        \"Should raise a error if file not exist\");\n}\n</code></pre> <pre><code>running 4 tests\ntest test_return_error_when_file_does_not_exist ... ok\ntest test_convert_all_words_to_uppercase ... ok\ntest test_load_words_from_valid_file ... ok\ntest test_trim_whitespace_from_words ... ok\n</code></pre> <p>Muito bom o teste passou e agora se o arquivo for vazio, ele vai lan\u00e7ar um erro? Vamos verificar se ele n\u00e3o vai retornar o m\u00e9todo <code>is_empty</code> como verdadeiro.</p> <pre><code>#[test]\nfn test_empty_file_should_raise_error() {\n    // Setup\n    let filename = \"test_empty.txt\";\n    create_test_file(\n        filename,\n        \"\"\n    );\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert!(!words.is_empty(), \n        \"Should raise a error if file is empty\");\n\n    // Tear Down\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>running 5 tests\ntest test_return_error_when_file_does_not_exist ... ok\ntest test_empty_file_should_raise_error ... FAILED\ntest test_convert_all_words_to_uppercase ... ok\ntest test_load_words_from_valid_file ... ok\ntest test_trim_whitespace_from_words ... ok\n\nfailures:\n\n---- test_empty_file_should_raise_error stdout ----\n\nthread 'test_empty_file_should_raise_error' panicked at tests/tests_game.rs:93:5:\nShould raise a error if file is empty\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Aqui o teste trouxe um erro pois n\u00e3o tratamos esse caso ainda de n\u00e3o ter nenhuma palavra, ent\u00e3o agora precisamos trabalhar para gerar um m\u00f3dulo de erros pro nosso jogo.</p>"},{"location":"1_4_caca_palavras/#iniciando-nosso-modulo-de-erros","title":"Iniciando nosso m\u00f3dulo de erros","text":"<p>Pra iniciar vamos criar um novo m\u00f3dulo <code>error</code> e colocado no nosso <code>lib.rs</code>.</p> <pre><code>touch src/error.rs\n</code></pre> <pre><code>//lib.rs\npub mod ui;\npub mod game;\npub mod grid;\npub mod error;\n</code></pre> <p>Agora queremos criar um <code>enum</code> com nossos erros, vamos criar um <code>IoError</code> pra usar no nosso result e outro <code>NoWordsProvided</code> para lan\u00e7ar quando o arquivo estiver vazio. Tamb\u00e9m vamos criar um coment\u00e1rio com 3 barras \"///\" para servir como documenta\u00e7\u00e3o.</p> <pre><code>#[derive(Debug)]\npub enum WordSearchError {\n    /// Error by I/O (file not found, permissions, etc.)\n    IoError(std::io::Error),\n    /// Any word found\n    NoWordsProvided,\n}\n\n</code></pre> <p>Agora precisamo adicionar um novo <code>impl</code> para indicar para o nosso compilador que nosso <code>WordSearchError</code> faz parte de <code>Error</code>.  ``` impl std::error::Error for WordSearchError {}</p> <pre><code>Aqui basicamente dizemos que o tipo `WordSearchError` implementa o `trait std::error::Error`.\nSe voc\u00ea j\u00e1 tem um conhecimento de _estrutura de dados_ aqui n\u00e3o \u00e9 uma heran\u00e7a mas sim uma\ncomposi\u00e7\u00e3o.\n\nAqui no caso o `for` n\u00e3o \u00e9 um `loop` nesse contexto ele quer falar que \"Eu sei transformar `std::error::Error` em `WordsearchError`\"\n\nPor que o bloco est\u00e1 vazio {}?\nO trait `std::error::Error` j\u00e1 vem com implementa\u00e7\u00f5es padr\u00e3o (`default impls`) para a maioria dos seus m\u00e9todos. Ent\u00e3o aqui s\u00f3 precisamos realmente criar a implementa\u00e7\u00e3o vazia.\n\nOutro ponto importante \u00e9 que para cada `struct` ou `enum` que criamos podemos ter quantos `impl` quisermos.\n\nAgora precisamos colocar mais um `impl` para que nosso `WordsearchError` fa\u00e7a o tratamento do `ioError` internamente. Toda vez que ele receber o `ioError` ele vai trata-lo e devolver um erro customizado do tipo `WordsearchError` para isso precisamos implementar a [`trait From`](https://doc.rust-lang.org/std/convert/trait.From.html).\n\nAo implementar a trait `From`, definimos o m\u00e9todo `from`, que recebe como par\u00e2metro o tipo de origem (no caso, `std::io::Error`) e ele retorna `Self`, ou seja, o tipo que est\u00e1 recebendo a implementa\u00e7\u00e3o o `WordSearchError`.\nDentro do m\u00e9todo, criamos e retornamos a variante correspondente do nosso tipo de erro `WordSearchError::IoError(error)`.\n\n```rust\n//error.rs\n\nimpl From&lt;std::io::Error&gt; for WordSearchError {\n    fn from(error: std::io::Error) -&gt; Self {\n        WordSearchError::IoError(error)\n    }\n}\n</code></pre> <p>Com isso podemos apenas trabalhar como nosso erro customizado no nosso c\u00f3digo. </p>"},{"location":"1_4_caca_palavras/#customizando-nossas-mensagens-de-erro","title":"Customizando nossas mensagens de erro","text":"<p>Agora vamos implementar a trait Display para trazer uma melhor visualiza\u00e7\u00e3o pro nosso erro. Nela precisamos criar uma fun\u00e7\u00e3o <code>fmt</code> para que possamos criar uma mensagem customizada da forma que queremos. Nesse caso tamb\u00e9m vamos usar um <code>impl</code> s\u00f3 que para <code>fmt::Display</code> que \u00e9 a nossa trait e vamos fazer um match para verificar qual variante do nosso <code>enum</code> est\u00e1 sendo usada e formatar a mensagem de erro apropriada. Tamb\u00e9m nesse caso vamos usar a macro <code>write!</code> ao inv\u00e9s do <code>println!</code> pois o <code>println!</code> sempre imprime diretamente no console (<code>stdout</code>), mas no nosso caso a <code>trait Display</code> est\u00e1 preparando a representa\u00e7\u00e3o textual do erro para ser usada em diferentes contextos. O <code>write!</code> \u00e9 mais flex\u00edvel porque ele escreve no <code>formatter</code> (<code>buffer</code>) que foi passado como par\u00e2metro, permitindo que essa representa\u00e7\u00e3o seja usada com outras macros como <code>format!</code>, <code>println!</code>, salvamento em arquivos, etc. N\u00f3s teremos ent\u00e3o na fun\u00e7\u00e3o <code>fmt</code> os par\u00e2metros <code>&amp;self</code> pois vamos usar o pr\u00f3prio contexto do <code>enum</code> e tamb\u00e9m como disse anteriormente o <code>formatter</code> que vai ser do tipo <code>fmt::Formatter&lt;'_&gt;</code> e vamos retornar um <code>fmt::Result</code>.</p> <pre><code>impl fmt::Display for WordSearchError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            WordSearchError::IoError(e) =&gt; write!(f, \"IO Error: {}\", e),\n            WordSearchError::NoWordsProvided =&gt; write!(f, \"No words provided\"),\n        }\n    }\n}\n</code></pre> <p>Novamente tivemos que recorrer a um <code>lifetime</code> no caso em <code>fmt::Formatter&lt;'_&gt;</code> porque o <code>Formatter</code> mant\u00e9m uma refer\u00eancia ao buffer onde o texto ser\u00e1 escrito, e essa refer\u00eancia precisa ter um tempo de vida v\u00e1lido. O <code>'_</code> indica que estamos deixando o Rust inferir automaticamente qual \u00e9 o lifetime correto.</p> <p>Pense assim: quando voc\u00ea formata o erro de um jogo, \u00e9 como preparar uma mensagem em um quadro-negro antes de mostr\u00e1-la ao jogador. O <code>Formatter</code> \u00e9 como uma seta apontando para esse quadro-negro, e o lifetime garante que o quadro n\u00e3o seja apagado enquanto voc\u00ea ainda est\u00e1 escrevendo nele. O <code>'_</code> diz ao Rust: \"voc\u00ea sabe quanto tempo isso precisa durar, n\u00e3o preciso especificar\".</p> <p>Voltando ao <code>game.rs</code> vamos implementar uma condi\u00e7\u00e3o parecida com o nosso assert  vamos verificar se words \u00e9 vazio e se sim vamos lan\u00e7ar o erro do tipo <code>NoWordsProvided</code> nele.</p> <pre><code>    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {\n        let content = fs::read_to_string(filename)?;\n        let words: Vec&lt;String&gt; = content\n            .lines()\n            .map(|line| line.trim().to_uppercase())\n            .collect();\n\n        if words.is_empty() {\n            return Err(WordSearchError::NoWordsProvided);\n        }\n\n        Ok(words)\n    }\n</code></pre> <p>Vamos mudar o tipo de erro da sa\u00edda do nosso <code>Result</code> da fun\u00e7\u00e3o pra <code>WordSearchError</code> tamb\u00e9m.</p> <pre><code>    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, WordSearchError&gt; {\n</code></pre> <p>Nos testes precisamos agora parar de desempacotar nossa string e ver se h\u00e1 um erro usando o m\u00e9todo <code>is_err</code>.</p> <pre><code>#[test]\nfn test_empty_file_should_raise_error() {\n    // Setup\n    let filename = \"test_empty.txt\";\n    create_test_file(\n        filename,\n        \"\"\n    );\n\n    // Act\n    let words = GameState::load_words_from_file(filename);\n\n    // Assert\n    assert!(words.is_err(), \"Should raise an error if file is empty\");\n\n    // Tear Down\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/tests_game.rs (target/debug/deps/tests_game-48a4cab4eebeef08)\n\nrunning 5 tests\ntest test_return_error_when_file_does_not_exist ... ok\ntest test_empty_file_should_raise_error ... ok\ntest test_trim_whitespace_from_words ... ok\ntest test_convert_all_words_to_uppercase ... ok\ntest test_load_words_from_valid_file ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/tests_ui.rs (target/debug/deps/tests_ui-16d9dc32c61ca57b)\n</code></pre> <p>Agora j\u00e1 temos um m\u00f3dulo de erros funcional vamos fazer um \u00faltimo teste pra verificar se estamos lidando bem com apenas uma palavra.</p> <pre><code>#[test]\nfn should_work_with_single_word() {\n    // Setup\n    let filename = \"test_single.txt\";\n    create_test_file(filename, \"rust\");\n\n    // Act\n    let words = GameState::load_words_from_file(filename).unwrap();\n\n    // Assert\n    assert_eq!(words.len(), 1);\n    assert_eq!(words[0], \"RUST\");\n\n    // Tear Down\n    cleanup_test_file(filename);\n}\n</code></pre> <pre><code>running 6 tests\ntest test_return_error_when_file_does_not_exist ... ok\ntest test_empty_file_should_raise_error ... ok\ntest test_load_words_from_valid_file ... ok\ntest test_convert_all_words_to_uppercase ... ok\ntest should_work_with_single_word ... ok\ntest test_trim_whitespace_from_words ... ok\n\ntest result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Agora temos algumas boas garantias que nosso sistema de arquivos vai funcionar.</p>"},{"location":"1_4_caca_palavras/#criando-um-alias-pra-um-tipo","title":"Criando um alias pra um tipo","text":"<p>Agora eu quero fazer uma mudan\u00e7a ao inv\u00e9s de deixar o retorno do nosso m\u00e9todo <code>load_words_from_file</code> como <code>Result&lt;Vec&lt;String&gt;, WordSearchError&gt;</code> quero deixa-lo apenas como <code>Result&lt;(T)&gt;</code> pra isso podemos criar um <code>type</code> que \u00e9 um alias ou um atalho ou ainda representar algo extenso com algo menor.</p> <p>Ent\u00e3o vamos criar esse <code>type</code> no final do nosso m\u00f3dulo.</p> <pre><code>// error.rs\npub type Result&lt;T&gt; = std::result::Result&lt;T, WordSearchError&gt;;\n</code></pre> <p>Com isso a agora podemos alterar o retorno da nossa fun\u00e7\u00e3o, e aqui estamos criando um alias pro Result da biblioteca  <code>std</code> com o nosso tipo de erro j\u00e1 declarado e chamando de result, por conta disso no nosso game vamos precisar importar explicitamente o result sendo ele o que est\u00e1 na nossa biblioteca error.</p> <p>Al\u00e9m disso como retornamos uma <code>Vec&lt;String&gt;</code> nosso alias precisa ainda receber o tipo <code>T</code> do retorno.</p> <pre><code>use std::fs;\n\nuse crate::{error::{Result, WordSearchError}, grid::Grid};\n\n\npub struct GameState {\n    pub grid: Grid,\n\n}\nimpl GameState {\n\n    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {\n        let content = fs::read_to_string(filename)?;\n        let words: Vec&lt;String&gt; = content\n            .lines()\n            .map(|line| line.trim().to_uppercase())\n            .collect();\n\n        if words.is_empty() {\n            return Err(WordSearchError::NoWordsProvided);\n        }\n\n        Ok(words)\n    }\n}\n</code></pre> <pre><code>-&gt; cargo test\nrunning 6 tests\ntest test_return_error_when_file_does_not_exist ... ok\ntest test_convert_all_words_to_uppercase ... ok\ntest test_empty_file_should_raise_error ... ok\ntest should_work_with_single_word ... ok\ntest test_load_words_from_valid_file ... ok\ntest test_trim_whitespace_from_words ... ok\n\ntest result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre> <p>Com isso podemos centralizar todos os erros em <code>WordSearchError</code> e s\u00f3 passar o tipo do nosso retorno, isso que chamamos de \"a\u00e7ucar sint\u00e1tico\".</p>"},{"location":"1_4_caca_palavras/#lifetimes","title":"Lifetimes","text":"<p>Lifetimes s\u00e3o anota\u00e7\u00f5es que dizem ao compilador por quanto tempo uma refer\u00eancia \u00e9 v\u00e1lida. Em C/C++, usar refer\u00eancias para dados j\u00e1 desalocados causa bugs terr\u00edveis. Em Rust, o compilador simplesmente n\u00e3o permite.</p> <p>Pense assim: Lifetimes s\u00e3o como etiquetas de validade em alimentos. O compilador verifica se voc\u00ea n\u00e3o est\u00e1 usando algo \"vencido\". A maioria das vezes o compilador infere automaticamente, mas \u00e0s vezes precisamos ajud\u00e1-lo com anota\u00e7\u00f5es expl\u00edcitas.</p> <p>Normalmente precisamos anotar o lifetime quando em casos espec\u00edficos e sempre anotar os par\u00e2metros que recebemos emprestados <code>&amp;</code> pois ele mantem-se marcando o tempo de vida dos par\u00e2metros.</p> <p>O c\u00f3digo abaixo vai dar erro porque o compilador n\u00e3o sabe qual lifetime o retorno deve ter quando a fun\u00e7\u00e3o recebe m\u00faltiplas refer\u00eancias.</p> <pre><code>fn escolher_arma(arma1: &amp;str, arma2: &amp;str, usar_primeira: bool) -&gt; &amp;str {\n    if usar_primeira { arma1 } else { arma2 }\n}\nlet rifle = String::from(\"Rifle de Plasma\");\nlet espada = String::from(\"Espada Laser\");\nlet arma = escolher_arma(&amp;rifle, &amp;espada, true); // Erro\nprintln!(\"Arma: {}\", arma);\n</code></pre> <p>O erro ocorre por que arma depende da vari\u00e1vel rifle ou espada, mas o compilador n\u00e3o sabe como retornar. - Posso retornar arma1... mas qual \u00e9 o lifetime dela? - Posso retornar arma2... mas qual \u00e9 o lifetime dela? - S\u00e3o diferentes? S\u00e3o iguais? - N\u00c3O SEI! ERRO!</p> <p>Isso acontece porque <code>arma1</code> e <code>arma2</code> podem ter lifetimes diferentes. O compilador n\u00e3o consegue garantir qual ser\u00e1 retornado (arma1 ou arma2?) sem que voc\u00ea especifique explicitamente que ambos devem ter o mesmo lifetime.</p> <p>Podemos resolver usando uma anota\u00e7\u00e3o <code>&lt;'a&gt;</code>, assim dizemos que eles duram o tempo <code>a</code>.</p> <pre><code>fn escolher_arma&lt;'a&gt;(arma1: &amp;'a str, arma2: &amp;'a str, usar_primeira: bool) -&gt; &amp;'a str {\n    if usar_primeira { arma1 } else { arma2 }\n}\n\nlet rifle = String::from(\"Rifle de Plasma\");\nlet espada = String::from(\"Espada Laser\");\nlet arma = escolher_arma(&amp;rifle, &amp;espada, true);\nprintln!(\"Arma: {}\", arma); // \"Rifle de Plasma\"\n</code></pre> <p>O que <code>&lt;'a&gt;</code> significa? - <code>'a</code> \u00e9 um nome de lifetime (pode ser <code>'b</code>, <code>'vida</code>, qualquer nome), todas essas refer\u00eancias vivem pelo menos durante o tempo <code>'a</code> e tamb\u00e9m vive durante <code>'a</code></p> <p>Podemos tamb\u00e9m usar dois lifetimes independentes e combinar esses dados.</p> <pre><code>fn combinar_dados&lt;'a, 'b&gt;(\n    piloto: &amp;'a str,\n    missao: &amp;'b str,\n) -&gt; (&amp;'a str, &amp;'b str) {\n    (piloto, missao)\n}\n\nlet piloto = String::from(\"Elena\");\nlet resultado = {\n    let missao = String::from(\"Reconhecimento\");\n    combinar_dados(&amp;piloto, &amp;missao)\n}; // \u274c ERRO\n</code></pre> <p>Por qu\u00ea? <code>'a</code> e <code>'b</code> s\u00e3o independentes. Se <code>missao</code> vive menos, n\u00e3o podemos usar <code>resultado.1</code> depois. Ent\u00e3o se mantermos as vari\u00e1veis no mesmo contexto ele \u00e9 funcional.</p> <pre><code>fn combinar_dados&lt;'a, 'b&gt;(\n    piloto: &amp;'a str,\n    missao: &amp;'b str,\n) -&gt; (&amp;'a str, &amp;'b str) {\n    (piloto, missao)\n}\n\nlet piloto = String::from(\"Elena\");\nlet missao = String::from(\"Reconhecimento\");\nlet resultado = combinar_dados(&amp;piloto, &amp;missao);\n</code></pre> <p>Se sua fun\u00e7\u00e3o pode retornar o valor de um par\u00e2metro ou outro podemos anotar o mesmo lifetime pra v\u00e1rios par\u00e2metros.</p> <pre><code>fn maior_nome&lt;'a&gt;(nome1: &amp;'a str, nome2: &amp;'a str) -&gt; &amp;'a str {\n    if nome1.len() &gt; nome2.len() { nome1 } else { nome2 }\n}\n\nlet n1 = String::from(\"Gundam\");\nlet n2 = String::from(\"Valkyrie\");\nprintln!(\"Maior: {}\", maior_nome(&amp;n1, &amp;n2)); // \"Valkyrie\"\n</code></pre> <p>Agora tivemos casos que recebemos algum par\u00e2metro mas, vamos devolver um <code>static</code>, pra isso podemos usar o lifetime <code>static</code>.</p> <pre><code>fn obter_status(codigo: u32) -&gt; &amp;'static str {\n    match codigo {\n        200 =&gt; \"Sistema Operacional\",\n        404 =&gt; \"Sensor N\u00e3o Encontrado\",\n        500 =&gt; \"Erro Cr\u00edtico\",\n        _ =&gt; \"Status Desconhecido\",\n    }\n}\n\nlet status = obter_status(404);\nprintln!(\"{}\", status); // \"Sensor N\u00e3o Encontrado\"\n</code></pre> <p>String literals s\u00e3o <code>'static</code>, n\u00e3o dependem do par\u00e2metro <code>codigo</code>. Ou seja esse lifetime est\u00e1 indicando que vamos retornar um <code>static</code> e n\u00e3o alguma transforma\u00e7\u00e3o do par\u00e2metro.</p> <p>Podemos tamb\u00e9m usar lifetimes para <code>Struct</code> e m\u00e9todos, no caso de m\u00e9todos o retorno vive enquanto <code>self</code> for v\u00e1lido.</p> <pre><code>struct Mecha&lt;'a&gt; {\n    nome: &amp;'a str,\n    energia: u32,\n}\n\nimpl&lt;'a&gt; Mecha&lt;'a&gt; {\n    fn nome(&amp;self) -&gt; &amp;str {\n        self.nome\n    }\n\n    fn energia(&amp;self) -&gt; u32 {\n        self.energia\n    }\n}\nlet nome = String::from(\"Valkyrie\");\nlet mecha = Mecha { nome: &amp;nome, energia: 100 };\nprintln!(\"{} - {}%\", mecha.nome(), mecha.energia());\n</code></pre>"},{"location":"1_4_caca_palavras/#construindo-o-grid","title":"Construindo o grid","text":"<p>Precisamos criar um m\u00e9todo tamb\u00e9m que vai gerar nosso grid recebendo um tamanho e a mesma string de palavras.</p> <pre><code>impl Grid {\n    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n    }\n}\n</code></pre> <p>Vamos criar agora uma inicializa\u00e7\u00e3o onde vamos preencher nossa <code>struct Grid</code> e retorna-la.</p> <pre><code>    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        let mut grid = Grid {\n            cells: vec![vec![' '; size]; size],\n            size,\n            words: Vec::new(),\n        };\n        Ok(grid)\n    }\n\n</code></pre> <p>Vamos preencher inicialmente o grid com as palavras do nosso arquivo, para isso precisamos de uma fun\u00e7\u00e3o que coloque as palavras que v\u00e3o vir do nosso arquivo no grid ent\u00e3o, na nossa <code>struct Grid</code> vamos criar um m\u00e9todo chamado <code>place_words</code> que vai receber a pr\u00f3pria <code>struct</code> e um vetor de <code>String</code> e como retorno vamos retornar apenas um Result ent\u00e3o no final da nossa fun\u00e7\u00e3o vamos retornar um <code>Ok(())</code>.</p> <pre><code>    fn place_words(&amp;mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;()&gt; {\n        Ok(())\n    }\n\n</code></pre> <p>Precisamos inicialmente agora criar um novo arquivo de teste para testar nosso grid e depois criar um teste para validar que <code>Grid</code> retorna OK se for adicionado par\u00e2metros v\u00e1lidos.</p> <pre><code>touch tests/tests_grid.rs\n</code></pre> <pre><code>#[test]\nfn test_grid_new_with_valid_parameters() {\n    // Setup\n    let words = vec![\n        \"RUST\".to_string(),\n        \"CODE\".to_string(),\n        \"TEST\".to_string(),\n    ];\n    let size = 10;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_ok(), \"Grid creation should succeed with valid parameters\");\n}\n</code></pre> <pre><code>running 1 test\ntest test_grid_new_with_valid_parameters ... ok\n</code></pre> <p>Agora vamos criar um teste para validar se adicionarmos um size de valor 0 lan\u00e7ar\u00e1 um erro. Para isso vamos criar um erro do tipo <code>InvalidGridSize</code> ele vai ser respons\u00e1vel por tratar o erro quando nosso <code>grid</code> for menor que 0, vamos fazer que ele receba um par\u00e2metro.</p> <pre><code>//error.rs\nuse std::fmt;\n\n#[derive(Debug)]\npub enum WordSearchError {\n    /// Error by I/O (file not found, permissions, etc.)\n    IoError(std::io::Error),\n    /// Any word found\n    NoWordsProvided,\n    /// Grid size not valid\n    InvalidGridSize(usize),\n}\n\nimpl fmt::Display for WordSearchError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            WordSearchError::IoError(e) =&gt; write!(f, \"IO Error: {}\", e),\n            WordSearchError::NoWordsProvided =&gt; write!(f, \"No words provided\"),\n            WordSearchError::InvalidGridSize(size) =&gt; {\n                write!(f, \"Invalid grid size: {}. Size must be greater than 2\", size)\n        }\n    }\n}\n</code></pre> <pre><code>#[test]\nfn test_grid_new_with_zero_size() {\n    // Setup\n    let words = vec![\"RUST\".to_string()];\n    let size = 0;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_err(), \"Grid creation should fail with size 0\");\n    if let Err(e) = result {\n        match e {\n            Error::InvalidGridSize(s) =&gt; assert_eq!(s, 0),\n            _ =&gt; panic!(\"Expected InvalidGridSize error\"),\n        }\n    }\n}\n</code></pre> <p>Agora como vamos validar o nosso construtor? Poder\u00edamos colocar apenas uma verifica\u00e7\u00e3o do nosso <code>new</code> mas, poder\u00edamos usar um <code>design partner</code> nesse caso que \u00e9 o padr\u00e3o <code>build</code>.</p> <p>O que \u00e9 o Builder Pattern? O Builder Pattern \u00e9 um padr\u00e3o de projeto criacional que permite construir objetos complexos passo a passo. Ele \u00e9 especialmente \u00fatil quando:</p> <ul> <li>Um objeto tem muitos par\u00e2metros opcionais</li> <li>A valida\u00e7\u00e3o precisa ser feita durante a constru\u00e7\u00e3o</li> <li>Voc\u00ea quer tornar a cria\u00e7\u00e3o de objetos mais leg\u00edvel</li> </ul> <p>Assim como quando estamos trabalhando com o arquivo que damos um <code>lines()</code>, <code>map()</code> e <code>collect()</code>, vamos criar nossos m\u00e9todos para encadear durante a constru\u00e7\u00e3o do nosso grid. Mas, pra isso vamos precisar criar um <code>GridBuilder</code> e a fun\u00e7\u00e3o dele vai ser especificamente trabalhar com a valida\u00e7\u00e3o de <code>size</code> e <code>words</code> e a parte das c\u00e9lulas vai ficar respons\u00e1vel no nosso grid j\u00e1 criado.</p> <p>Se fosse um projeto real eu acredito que a melhor abordagem seria criar um m\u00e9todo que valide o size \u00e9 mais simples, por\u00e9m aqui vamos complicar um pouquinho apenas pra voc\u00ea ter uma vis\u00e3o das possibilidades na hora de construir um objeto.</p> <p>Nessa constru\u00e7\u00e3o vamos criar uma <code>struct GridBuilder</code> nela vamos ter <code>size</code> e <code>words</code> seu principal objetivo vai ser validar esses dois atributos e construir o <code>grid</code>. Ent\u00e3o primeiros vamos criar a  <code>struct</code> e validar se size for menor ou igual a 0 vamos lan\u00e7ar um erro <code>InvalidGridSize</code>.</p> <pre><code>pub struct GridBuilder {\n    size: Option&lt;usize&gt;,\n    words: Option&lt;Vec&lt;String&gt;&gt;,\n}\n\nimpl GridBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            size: None,\n            words: None,\n        }\n    }\n\n    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {\n        if size == 0 {\n            return Err(WordSearchError::InvalidGridSize(size));\n        }\n        self.size = Some(size);\n        Ok(self)\n    }\n</code></pre> <p>Como estamos criando um builder vamos criar um m\u00e9todo chamado <code>build</code> ele vai criar o grid.</p> <pre><code>pub struct GridBuilder {\n    size: Option&lt;usize&gt;,\n    words: Option&lt;Vec&lt;String&gt;&gt;,\n}\n\nimpl GridBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            size: None,\n            words: None,\n        }\n    }\n\n    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {\n        if size == 0 {\n            return Err(WordSearchError::InvalidGridSize(size));\n        }\n        self.size = Some(size);\n        Ok(self)\n    }\n\n    pub fn build(self) -&gt; Grid {\n        let size = self.size.expect(\"Size must be set\");\n\n        Grid {\n            size,\n            cells: vec![vec![' '; size]; size],\n            words: vec![],\n        }\n    }\n}\n</code></pre> <p>Agora podemos construir ele no nosso <code>struct Grid</code> e podemos encadear nosso m\u00e9todo <code>new</code> com a valida\u00e7\u00e3o de <code>with_size</code> e usar o operador \"?\" para propagar o erro depois s\u00f3 devolvemos o <code>grid</code> do nosso construtor.</p> <pre><code>impl Grid {\n    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        let grid = GridBuilder::new()\n            .with_size(size)?\n            .build();\n        Ok(grid)\n    }\n\n}\n</code></pre> <pre><code>running\n2 tests\ntest test_grid_new_with_zero_size ... ok\ntest test_grid_new_with_valid_parameters ... ok\n</code></pre>"},{"location":"1_4_caca_palavras/#validando-nosso-vetor-de-palavras","title":"Validando nosso vetor de palavras","text":"<p>Primeiro vamos ajustar nosso m\u00e9todo new em <code>grid.rs</code> para receber <code>WordPlacement</code> ao inv\u00e9s de uma string. E vamos aplicar a <code>trait Debug</code> tanto em <code>Grid</code> quanto em <code>WordPlacement</code></p> <pre><code>#[derive(Debug)]\npub struct WordPlacement {\n    pub word: String,\n    pub start: Position,\n    pub direction: Direction,\n    pub found: bool,\n}\n\n#[derive(Debug)]\npub struct Grid {\n    cells: Vec&lt;Vec&lt;char&gt;&gt;,\n    pub size: usize,\n    pub words: Vec&lt;WordPlacement&gt;,\n}\n\nimpl Grid {\n    pub fn new(size: usize, words: Vec&lt;WordPlacement&gt;) -&gt; Result&lt;Self&gt; {\n        let grid = GridBuilder::new()\n            .with_size(size)?\n            .build();\n        Ok(grid)\n    }\n\n}\n\n</code></pre> <p>Agora precisamos validar as palavras do nosso jogo, pra isso vamos criar um teste que quando for tentado construir o grid sem palavras ele de um erro do tipo <code>NoWordsProvided</code> e no nosso grid vamos receber o par\u00e2metro de palavras.</p> <pre><code>// tests_grid.rs\n#[test]\nfn test_grid_new_with_empty_words() {\n    let words = Vec::new();\n    let size = 10;\n\n    let result = Grid::new(size, words);\n\n    assert!(result.is_err(), \"Grid creation should fail with empty word list\");\n    if let Err(e) = result {\n        match e {\n            Error::EmptyWordList =&gt; {},\n            _ =&gt; panic!(\"Expected EmptyWordList error\"),\n        }\n    }\n}\n</code></pre> <pre><code>//grid.rs\npub struct Grid {\n    cells: Vec&lt;Vec&lt;char&gt;&gt;,\n    pub size: usize,\n    pub words: Vec&lt;WordPlacement&gt;,\n}\n\nimpl Grid {\n    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        let grid = GridBuilder::new()\n            .with_size(size)?\n            .with_words(words)?\n            .build();\n        Ok(grid)\n    }\n\n}\n\npub struct GridBuilder {\n    size: Option&lt;usize&gt;,\n    words: Option&lt;Vec&lt;String&gt;&gt;,\n}\n\nimpl GridBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            size: None,\n            words: None,\n        }\n    }\n\n    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {\n        if size == 0 {\n            return Err(WordSearchError::InvalidGridSize(size));\n        }\n        self.size = Some(size);\n        Ok(self)\n    }\n\n    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        self.words = Some(words);\n        Ok(self)\n    }\n\n    pub fn build(self) -&gt; Grid {\n        let size = self.size.expect(\"Size must be set\");\n\n        Grid {\n            size,\n            cells: vec![vec![' '; size]; size],\n            words: vec![],\n        }\n    }\n}\n</code></pre> <pre><code>running 3 tests\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_zero_size ... ok\ntest test_grid_new_with_empty_words ... FAILED\n\nfailures:\n\n---- test_grid_new_with_empty_words stdout ----\n\nthread 'test_grid_new_with_empty_words' panicked at tests/test_grid.rs:44:5:\nGrid creation should fail with empty word list\n</code></pre> <p>O que precisamos fazer agora \u00e9 criar uma valida\u00e7\u00e3o se o <code>words</code> for um vetor vazio ele deve lan\u00e7ar um erro. Por isso vamos modificar nosso <code>with_words</code> para fazer essa valida\u00e7\u00e3o.</p> <pre><code>    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        if words.is_empty() {\n            return Err(WordSearchError::NoWordsProvided);\n        }\n        self.words = Some(words);\n        Ok(self)\n    }\n</code></pre> <pre><code>running 3 tests\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_zero_size ... ok\ntest test_grid_new_with_valid_parameters ... ok\n\n</code></pre> <p>Agora o que acontece se criarmos um grid 5x5 e temos uma palavra como \"Pneumoultramicroscopicossilicovulcanoconiose\" acredito que temos um problema n\u00e3o? Ent\u00e3o vamos criar um teste para verificar se a palavra \u00e9 maior que o tamanho do nosso grid. Se a palavra for maior precisamos lan\u00e7ar um erro do tipo <code>WordTooLong</code> ent\u00e3o vamos cria-lo.</p> <pre><code> use std::fmt;\n\n#[derive(Debug)]\npub enum WordSearchError {\n    /// Error by I/O (file not found, permissions, etc.)\n    IoError(std::io::Error),\n    /// Any word found\n    NoWordsProvided,\n    /// Grid size not valid\n    InvalidGridSize(usize),\n    /// Word is too long for the grid\n    WordTooLong { word: String, size: usize },\n}\n\nimpl fmt::Display for WordSearchError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            WordSearchError::IoError(e) =&gt; write!(f, \"IO Error: {}\", e),\n            WordSearchError::NoWordsProvided =&gt; write!(f, \"No words provided\"),\n            WordSearchError::InvalidGridSize(size) =&gt; {\n                write!(f, \"Invalid grid size: {}. Size must be greater than 0\", size)\n            }\n            WordSearchError::WordTooLong { word, size } =&gt; {\n                write!(f, \"Word '{}' with length {} is too long for grid size {}\", \n                    word, word.len(), size)\n            }\n        }\n    }\n}\n</code></pre> <p>Com isso podemos criar um teste:</p> <pre><code>#[test]\nfn test_grid_new_with_word_too_large() {\n    // Setup\n    let words = vec![\"VERYLONGWORDTHATDOESNOTFIT\".to_string()];\n    let size = 5;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_err(), \"Grid creation should fail when word is larger than grid\");\n\n    match result {\n        Err(WordSearchError::WordTooLarge { word, size: grid_size }) =&gt; {\n            assert_eq!(word, \"VERYLONGWORDTHATDOESNOTFIT\");\n            assert_eq!(grid_size, 5);\n        }\n        _ =&gt; panic!(\"Expected WordTooLong error\"),\n    }\n}\n</code></pre> <pre><code>running 4 tests\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_word_too_large ... FAILED\ntest test_grid_new_with_zero_size ... ok\n\nfailures:\n\n---- test_grid_new_with_word_too_large stdout ----\n\nthread 'test_grid_new_with_word_too_large' panicked at tests/test_grid.rs:64:5:\nGrid creation should fail when word is larger than grid\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Precisamos agora criar um validador para nosso teste ent\u00e3o aqui vamos precisar verificar o size e pra isso vamos criar uma vari\u00e1vel condicional chamada let Some(current_size) e receber self.size o valor interno de self.size SE ele for Some. Quando fazemos isso abrimos um bloco de c\u00f3digo {}  l\u00e1 podemos criar nosso c\u00f3digo condicional no caso ele vai percorrer words e verificar se alguma \u00e9 maior que current_size se isso for verdadeiro ele lan\u00e7a um erro, se n\u00e3o <code>current_size</code> vai receber <code>self.size</code>. Poderiamos aqui tanto fazer um <code>match</code> com <code>self.size</code> e verificar se a <code>option</code> tem algum Some ou vazia ou mesmo desempacotar com um <code>unwrap</code> mas, a vantagem do if let \u00e9 ser seguro (n\u00e3o causa panic), conciso (uma linha), e idiom\u00e1tico. Al\u00e9m disso, ele extrai o valor automaticamente, sem precisar desempacotar manualmente.</p> <p>Por\u00e9m tudo vai depender do que voc\u00ea acha melhor em cada situa\u00e7\u00e3o, mas hoje vamos fazer assim.</p> <pre><code>        if let Some(size) = self.size {\n            for word in &amp;words {\n                if word.len() &gt; size {\n                    return Err(WordSearchError::WordTooLong {\n                        word: word.clone(),\n                        size,\n                    });\n                }\n            }\n        }\n</code></pre> <pre><code>running 4 tests\ntest test_grid_new_with_word_too_large ... ok\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_zero_size ... ok\ntest test_grid_new_with_valid_parameters ... ok\n</code></pre> <p>Vamos fazer um teste agora apenas pra validar se a palavra tem o mesmo tamanho do grid ela tem que aceitar.</p> <pre><code>#[test]\nfn test_grid_new_with_exact_word_size() {\n    // Setup\n    let words = vec![\"EXACT\".to_string()];\n    let size = 5;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_ok(), \"Grid creation should succeed when word length equals grid size\");\n}\n</code></pre> <pre><code>running 5 tests\ntest test_grid_new_with_exact_word_size ... ok\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_word_too_large ... ok\ntest test_grid_new_with_zero_size ... ok\n\n</code></pre> <p>Agora uma ultima valida\u00e7\u00e3o precisamos ver que uma palavra tenha pelo menos dois caracteres, sen\u00e3o n\u00e3o \u00e9 uma palavra n\u00e3o? Ent\u00e3o vamos criar um error <code>WordInvalid</code> para lan\u00e7ar quando o tamanho for menor que 2.</p> <pre><code>use std::fmt;\n\n#[derive(Debug)]\npub enum WordSearchError {\n    /// Error by I/O (file not found, permissions, etc.)\n    IoError(std::io::Error),\n    /// Any word found\n    NoWordsProvided,\n    /// Grid size not valid\n    InvalidGridSize(usize),\n    /// Word is too long for the grid\n    WordTooLong { word: String, size: usize },\n    /// Word should the minimal 2 characters\n    WordInvalid { word: String },\n}\n\nimpl fmt::Display for WordSearchError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            WordSearchError::IoError(e) =&gt; write!(f, \"IO Error: {}\", e),\n            WordSearchError::NoWordsProvided =&gt; write!(f, \"No words provided\"),\n            WordSearchError::InvalidGridSize(size) =&gt; {\n                write!(f, \"Invalid grid size: {}. Size must be greater than 0\", size)\n            }\n            WordSearchError::WordTooLong { word, size } =&gt; {\n                write!(f, \"Word '{}' with length {} is too long for grid size {}\", \n                    word, word.len(), size)\n            }\n            WordSearchError::WordInvalid { word } =&gt; {\n                write!(f, \"Word '{}' with length {} is too short you need the minimum 2 characters\", \n                    word, word.len())\n            }\n        }\n    }\n}\n</code></pre> <p>Agora criamos o teste:</p> <pre><code>#[test]\nfn test_grid_new_with_word_only_caracter_should_a_error() {\n    // Setup\n    let words = vec![\"A\".to_string()];\n    let size = 2;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_err(), \"Grid creation should fail when word is only one character\");\n\n    match result {\n        Err(WordSearchError::WordInvalid { word }) =&gt; {\n            assert_eq!(word, \"A\");\n        }\n        _ =&gt; panic!(\"Expected WordInvalid error\"),\n    }\n}\n</code></pre> <pre><code>running 6 tests\ntest test_grid_new_with_word_too_large ... ok\ntest test_grid_new_with_word_only_caracter ... FAILED\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_exact_word_size ... ok\ntest test_grid_new_with_zero_size ... ok\n\nfailures:\n\n---- test_grid_new_with_word_only_caracter stdout ----\n\nthread 'test_grid_new_with_word_only_caracter' panicked at tests/test_grid.rs:99:5:\nGrid creation should fail when word is only one character\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> <p>Vamos colocar por seguran\u00e7a tamb\u00e9m um validador no build se words existe.</p> <pre><code>    pub fn build(self) -&gt; Grid {\n        let size = self.size.expect(\"Size must be set\");\n        let words = self.words.expect(\"Words must be set\");\n\n        Grid {\n            size,\n            cells: vec![vec![' '; size]; size],\n            words: vec![],\n        }\n\n</code></pre> <p>Ajustando agora vamos fazer simplesmente outro <code>if</code> pra validar isso.</p> <pre><code>    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {\n        if words.is_empty() {\n            return Err(WordSearchError::NoWordsProvided);\n        }\n        if let Some(size) = self.size {\n            for word in &amp;words {\n                if word.len() &gt; size {\n                    return Err(WordSearchError::WordTooLong {\n                        word: word.clone(),\n                        size,\n                    });\n                }\n                if word.len() &lt; 2 {\n                    return Err(WordSearchError::WordInvalid { word: word.clone() })\n                }\n            }\n        }\n        self.words = Some(words);\n        Ok(self)\n    }\n\n</code></pre> <pre><code>running 6 tests\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_exact_word_size ... ok\ntest test_grid_new_with_word_only_caracter_shoudl_a_error ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_zero_size ... ok\ntest test_grid_new_with_word_too_large ... ok\n</code></pre> <p>Certo tudo funcionando.</p>"},{"location":"1_4_caca_palavras/#validando-o-tamanho-do-jogo","title":"Validando o tamanho do jogo","text":"<p>Bom agora precisamos validar se o size do nosso jogo \u00e9 maior ou igual a 2, menos que 2 c\u00e9lulas o jogo n\u00e3o existe praticamente. Ent\u00e3o vamos refatorar nosso teste pra validar um grid de tamanho 1 ainda vai dar erro. Vamos renomear o teste <code>test_grid_new_with_zero_size</code> para  <code>test_grid_new_with_one_size</code> e mudar o tamanho de 0 para 1.</p> <pre><code>#[test]\nfn test_grid_new_with_one_size() {\n    // Setup\n    let words = vec![\"HI\".to_string()];\n    let size = 1;\n\n    // Act\n    let result = Grid::new(size, words);\n\n    // Assert\n    assert!(result.is_err(), \"Grid creation should fail with size 1\");\n\n    match result {\n        Err(WordSearchError::InvalidGridSize(s)) =&gt; {\n            assert_eq!(s, 1, \"Error should contain the invalid size value\");\n        }\n        _ =&gt; panic!(\"Expected InvalidGridSize error with value 1\"),\n    }\n}\n</code></pre> <pre><code>running 6 tests\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_word_too_large ... ok\ntest test_grid_new_with_word_only_caracter_shoudl_a_error ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_exact_word_size ... ok\ntest test_grid_new_with_one_size ... FAILED\n\nfailures:\n\n---- test_grid_new_with_one_size stdout ----\n\nthread 'test_grid_new_with_one_size' panicked at tests/test_grid.rs:33:14:\nExpected InvalidGridSize error with value 1\n</code></pre> <p>Agora alterando nosso grid ele precisa ter valor maior que 1.</p> <pre><code>    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {\n        if size &lt;= 1 {\n            return Err(WordSearchError::InvalidGridSize(size));\n        }\n        self.size = Some(size);\n        Ok(self)\n    }\n</code></pre> <pre><code>running 6 tests\ntest test_grid_new_with_empty_words ... ok\ntest test_grid_new_with_one_size ... ok\ntest test_grid_new_with_exact_word_size ... ok\ntest test_grid_new_with_valid_parameters ... ok\ntest test_grid_new_with_word_only_caracter_shoudl_a_error ... ok\ntest test_grid_new_with_word_too_large ... ok\n</code></pre> <p>WIP - Conte\u00fado em constru\u00e7\u00e3o</p>"},{"location":"1_5_pong/","title":"Pong","text":""},{"location":"1_5_pong/#wip","title":"WIP","text":""},{"location":"1_6_labirinto/","title":"Labirinto","text":""},{"location":"1_6_labirinto/#wip","title":"WIP","text":""},{"location":"1_7_rpg_tatico_text/","title":"Rpg T\u00e1tico","text":""},{"location":"1_7_rpg_tatico_text/#wip","title":"WIP","text":""},{"location":"1_8_batalha_naval/","title":"Batalha naval","text":""},{"location":"1_8_batalha_naval/#wip","title":"WIP","text":""},{"location":"1_9_aprimorando_rpg_tatico/","title":"Aprimorando o RPG t\u00e1tico","text":""},{"location":"1_9_aprimorando_rpg_tatico/#wip","title":"WIP","text":""},{"location":"2_0_rogue/","title":"Rogue","text":""},{"location":"2_0_rogue/#wip","title":"WIP","text":""},{"location":"INDICE/","title":"Summary","text":""},{"location":"INDICE/#ementa-desenvolvimento-de-jogos-em-ascii-com-rust","title":"Ementa: Desenvolvimento de Jogos em ASCII com Rust","text":""},{"location":"INDICE/#topico-1-conceitos-basicos-de-rust","title":"T\u00f3pico 1: Conceitos B\u00e1sicos de Rust","text":"<ul> <li>Introdu\u00e7\u00e3o</li> <li>Jogo a Floresta Misteriosa</li> <li>Tipos de Dados e Fun\u00e7\u00f5es</li> <li>Controle de Fluxo e Propriedade (Ownership)</li> </ul>"},{"location":"INDICE/#topico-2-introducao-a-arte-ascii","title":"T\u00f3pico 2: Introdu\u00e7\u00e3o \u00e0 Arte ASCII","text":"<ul> <li>[Manipula\u00e7\u00e3o de Strings e Caracteres ASCII]</li> <li>[Sa\u00edda para o Terminal e Interface do Usu\u00e1rio]</li> </ul>"},{"location":"INDICE/#topico-3-implementando-a-logica-de-jogos","title":"T\u00f3pico 3: Implementando a L\u00f3gica de Jogos","text":"<ul> <li>[Vetores e Matrizes]</li> <li>[Algoritmos de Busca e Ordena\u00e7\u00e3o]</li> </ul>"},{"location":"INDICE/#topico-4-gerenciamento-de-tela-e-interface-do-usuario","title":"T\u00f3pico 4: Gerenciamento de Tela e Interface do Usu\u00e1rio","text":"<ul> <li>[Manipula\u00e7\u00e3o de Tela e Terminal (ANSI escape codes)]</li> <li>[Entrada do Usu\u00e1rio (stdin) e Gerenciamento de Eventos]</li> </ul>"},{"location":"INDICE/#topico-5-mecanica-de-jogo","title":"T\u00f3pico 5: Mec\u00e2nica de Jogo","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto State]</li> </ul>"},{"location":"INDICE/#topico-6-tratamento-de-eventos","title":"T\u00f3pico 6: Tratamento de Eventos","text":"<ul> <li>[Enumera\u00e7\u00f5es e Padr\u00e3o de Projeto Observer]</li> </ul>"},{"location":"INDICE/#topico-7-controle-de-estado-e-salvamento-do-jogo","title":"T\u00f3pico 7: Controle de Estado e Salvamento do Jogo","text":"<ul> <li>[Serializa\u00e7\u00e3o e Desserializa\u00e7\u00e3o de Dados]</li> </ul>"},{"location":"INDICE/#topico-8-desafios-e-recursos-avancados","title":"T\u00f3pico 8: Desafios e Recursos Avan\u00e7ados","text":"<ul> <li>[Threads e Concorr\u00eancia]</li> <li>[Gerenciamento de Mem\u00f3ria Avan\u00e7ado (Rc, Arc, Mutex)]</li> </ul>"},{"location":"INDICE/#topico-9-desenvolvimento-de-jogos-completos-em-ascii","title":"T\u00f3pico 9: Desenvolvimento de Jogos Completos em ASCII","text":"<ul> <li>[Estrutura de Projeto e Organiza\u00e7\u00e3o de Arquivos]</li> <li>[Tratamento de Erros (Result, Option)]</li> <li>[Documenta\u00e7\u00e3o do C\u00f3digo]</li> </ul>"},{"location":"INDICE/#topico-10-projeto-final-jogo-completo-em-ascii","title":"T\u00f3pico 10: Projeto Final: Jogo Completo em ASCII","text":"<ul> <li>[Aplica\u00e7\u00e3o de todos os conceitos aprendidos para criar um jogo completo e original em ASCII.]</li> </ul>"},{"location":"Jogos/","title":"Jogos","text":"<p>Ementa</p> <p>1 - Introdu\u00e7\u00e3o ao Rust 2 - Jogo 'A floresta misteriosa' 3 - Jogo da adivinha\u00e7\u00e3o 4 - Blackjack WIP 5 - Jogo de palavras cruzadas 6 - Jogo do Pong 7 - Jodo do Labirinto 5 - RPG de texto 7 - Jogo top down com eventos aleat\u00f3rios 8 - Criando sistema de salvamento pro nosso RPG 9 - Batalha naval Multiplayer 9 - Jogo de Xadrez multiplayer 10 - Criando nosso jogo Adventure 11 - Fazendo nosso RPG ser jogado Online 12 - Projeto Final: Jogo Rogue</p>"},{"location":"topicos-explicacao/","title":"Topicos explicacao","text":"<p>Coment\u00e1rios Tipos simples Tipos compostos Infer\u00eancia Display e Debug Mutabilidade Stack, heap e pointers Strings Constantes e est\u00e1ticos Referencias Fun\u00e7\u00f5es e m\u00e9todos Trait copy e clone Collections Vetores Tuplas Controle de fluxo Structs Enuns Loops Desestrutura\u00e7\u00e3o dot operator Generics Option e Result Operador de interroga\u00e7\u00e3o \"?\" traits Chaining Methods Iterators Closures macros inspects Tipos do &amp;str Lifetimes Cow Tipos de alias Macro Todo RC Threads Arc Channels Atributos Box Box envolta de traits Deref e DerefMut Crates and modules Testing External crates standard library Escrevendo macros Escrevendo Traits Turbo fish</p>"}]}