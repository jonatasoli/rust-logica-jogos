
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://rustlogicajogos.jonatasoliveira.dev/1_4_caca_palavras/">
      
      
        <link rel="prev" href="../1_3_jogo_blackjack/">
      
      
        <link rel="next" href="../1_5_pong/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.1.21">
    
    
      
        <title>Ca√ßa palavras - WIP - Rust da L√≥gica aos Jogos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#caca-palavras-wip" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Rust da L√≥gica aos Jogos" class="md-header__button md-logo" aria-label="Rust da L√≥gica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Rust da L√≥gica aos Jogos
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Ca√ßa palavras - WIP
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema claro"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Mudar para o tema claro" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Mudar para o tema escuro"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Mudar para o tema escuro" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Rust da L√≥gica aos Jogos" class="md-nav__button md-logo" aria-label="Rust da L√≥gica aos Jogos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Rust da L√≥gica aos Jogos
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jonatasoli/rust-logica-jogos" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    jonatasolivera/rust-logica-jogos
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Bem vindo ao curso Rust l√≥gica com jogos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_0_introducao/" class="md-nav__link">
        Introdu√ß√£o
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_1_jogo_floresta_misteriosa/" class="md-nav__link">
        Floresta Misteriosa
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_2_jogo_da_adivinhacao/" class="md-nav__link">
        Jogo da adivinha√ß√£o
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_3_jogo_blackjack/" class="md-nav__link">
        Blackjack
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Ca√ßa palavras - WIP
      </a>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_5_pong/" class="md-nav__link">
        Pong
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_6_labirinto/" class="md-nav__link">
        Labirinto
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_7_rpg_tatico_text/" class="md-nav__link">
        Rpg T√°tico
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_8_batalha_naval/" class="md-nav__link">
        Batalha naval
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../1_9_aprimorando_rpg_tatico/" class="md-nav__link">
        Aprimorando o RPG t√°tico
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../2_0_rogue/" class="md-nav__link">
        Rogue
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../INDICE/" class="md-nav__link">
        Summary
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Jogos/" class="md-nav__link">
        Jogos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../topicos-explicacao/" class="md-nav__link">
        Topicos explicacao
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="caca-palavras-wip">Ca√ßa palavras - WIP</h1>
<h1 id="caca-palavras">Ca√ßa Palavras</h1>
<h2 id="raio-x">Raio X</h2>
<p><a class="glightbox" href="../images/M4/raiox-caca-palavras.jpg" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="" src="../images/M4/raiox-caca-palavras.jpg" /></a></p>
<h3 id="mecanicas-do-jogo">Mec√¢nicas do Jogo:</h3>
<p>A tela apresentar√° uma lista de palavras pra serem buscadas.
O jogo ter√° 20 palavras para serem buscadas.
Palavras podem estar na horizontal, vertical ou diagonal.
Uma palavra encontrada deve aparecer riscada para indicar que j√° foi achada.
Precisa ter um timer para indicar o tempo at√© encontrar todas as palavras.
Precisa ter um marcador quando tenta encontrar uma palavra.
Palavras encontradas devem aparecer destacadas.O jogo termina quando forem encontradas as 20 palavras.</p>
<h2 id="tui">TUI</h2>
<p>Tui √© <em>Terminal User Interface</em> e √© usado amplamente na computa√ß√£o tanto corporativa quanto pessoal, √© basicamente uma forma de termos um programa com uma interface com bot√µes, menus e etc s√≥ que rodando no terminal √© bem √∫til em v√°rias situa√ß√µes e podemos fazer v√°rias coisas com esse tipo de interface.</p>
<h2 id="ratatui">Ratatui</h2>
<p>Ratatui √© uma biblioteca para cria√ß√£o de interfaces de usu√°rio baseadas em texto (TUI) na linguagem de programa√ß√£o Rust. Ela √© uma vers√£o aprimorada e mantida da biblioteca TUI-rs, com o objetivo de fornecer uma maneira eficiente e f√°cil de construir TUIs no terminal.
Principais Recursos:
    Flexibilidade e Composi√ß√£o:
        O Ratatui oferece layout flex√≠vel e ferramentas para organizar componentes como pain√©is, caixas de texto, tabelas, gr√°ficos, e barras de progresso, com base nas suas necessidades.
        Ele usa um sistema de layouts declarativos, permitindo que voc√™ divida sua interface em blocos reutiliz√°veis e bem organizados.
    Estiliza√ß√£o e Temas:
        A biblioteca suporta estilos customiz√°veis para textos e widgets, permitindo a aplica√ß√£o de cores, modificadores como negrito, sublinhado e it√°lico, al√©m de temas personalizados.
        Com isso, voc√™ pode criar interfaces que se adaptam √† est√©tica desejada para a aplica√ß√£o no terminal.
    Performance:
        Escrito em Rust, o Ratatui √© muito eficiente em termos de uso de mem√≥ria e processamento, o que o torna adequado para aplica√ß√µes de linha de comando r√°pidas e reativas.
    Integra√ß√£o com Crossterm:
        O Ratatui funciona em conjunto com o Crossterm, uma biblioteca que oferece controle sobre o terminal (como captura de eventos de teclado e controle de entrada/sa√≠da de terminal) de maneira cross-platform (suporta Windows, Linux e macOS).
    Suporte a Eventos:
        Al√©m do controle de layout e estilo, o Ratatui permite a captura de eventos de teclado e mouse, tornando poss√≠vel a cria√ß√£o de interfaces interativas, como editores de texto, navegadores de arquivos, e clientes de chat.</p>
<pre><code class="language-mermaid">graph TB
    subgraph &quot;Aplica√ß√£o do Usu√°rio&quot;
        App[Estado da Aplica√ß√£o]
        EventLoop[Loop de Eventos]
        DrawFn[Fun√ß√£o de Desenho]
    end

    subgraph &quot;Ratatui Core&quot;
        Terminal[Terminal]
        Frame[Frame]
        Buffer1[Buffer Atual]
        Buffer2[Buffer Anterior]
        Layout[Sistema de Layout]
    end

    subgraph &quot;Widgets&quot;
        Block[Block]
        Paragraph[Paragraph]
        List[List]
        Table[Table]
        Chart[Chart]
        Custom[Widgets Customizados]
    end

    subgraph &quot;Backend Layer&quot;
        Backend[Backend&lt;br/&gt;Crossterm/Termion/Termwiz]
        TerminalIO[I/O do Terminal]
    end

    EventLoop --&gt;|1. Captura eventos| Backend
    Backend --&gt;|2. Retorna eventos| EventLoop
    EventLoop --&gt;|3. Atualiza| App
    EventLoop --&gt;|4. Chama draw| Terminal
    Terminal --&gt;|5. Fornece Frame| DrawFn
    DrawFn --&gt;|6. Calcula espa√ßo| Layout
    Layout --&gt;|7. Retorna Rect| DrawFn
    DrawFn --&gt;|8. Renderiza widgets| Frame
    Frame --&gt;|9. Desenha em| Buffer1

    Block -.-&gt;|implementa Widget| Frame
    Paragraph -.-&gt;|implementa Widget| Frame
    List -.-&gt;|implementa StatefulWidget| Frame
    Table -.-&gt;|implementa StatefulWidget| Frame
    Chart -.-&gt;|implementa Widget| Frame
    Custom -.-&gt;|implementa Widget/StatefulWidget| Frame

    Terminal --&gt;|10. Compara| Buffer2
    Terminal --&gt;|11. Calcula diff| Buffer1
    Terminal --&gt;|12. Envia mudan√ßas| Backend
    Backend --&gt;|13. Escreve na tela| TerminalIO

    Buffer1 -.-&gt;|Se torna pr√≥ximo| Buffer2

    style App fill:#e1f5ff
    style Terminal fill:#ffe1e1
    style Backend fill:#e1ffe1
    style Frame fill:#fff4e1
    style Layout fill:#f0e1ff
</code></pre>
<p>O diagrama acima ilustra como os componentes do Ratatui se conectam e como a informa√ß√£o flui pelo sistema. Vou destacar alguns pontos importantes que voc√™ v√™ no diagrama:</p>
<p>O <strong>ciclo numerado</strong> (1-13) mostra o fluxo completo de uma itera√ß√£o do loop de renderiza√ß√£o. Voc√™ pode ver como come√ßa com a captura de eventos do teclado, passa pela atualiza√ß√£o do estado, depois pela renderiza√ß√£o dos widgets, e finalmente termina com a escrita eficiente no terminal usando o sistema de diff.</p>
<p>As <strong>linhas s√≥lidas</strong> representam o fluxo principal de dados e controle, enquanto as <strong>linhas pontilhadas</strong> mostram as rela√ß√µes de implementa√ß√£o entre os widgets e o sistema de renderiza√ß√£o.</p>
<p>O <strong>sistema de buffer duplo</strong> √© especialmente importante para performance: ao manter dois buffers e comparar apenas as diferen√ßas, o Ratatui evita redesenhar toda a tela a cada frame, resultando em interfaces muito mais fluidas e responsivas.</p>
<h2 id="atualizando-o-rust">Atualizando o rust</h2>
<p>Bom antes de come√ßarmos nosso jogo vamos fazer novamente a atualiza√ß√£o do rust:</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<p>Criando projeto</p>
<p>Bom vamos criar nosso novo projeto em projects:</p>
<pre><code class="language-bash">cargo new wordsearch
cd wordsearch
</code></pre>
<p>Para criar esse projeto vamos entender melhor como vamos estruturar nosso jogo.</p>
<h2 id="iniciando-o-nosso-projeto">Iniciando o nosso projeto</h2>
<p>Vamos agora adicionar algumas bibliotecas no nosso projeto.</p>
<pre><code class="language-bash">cargo add ratatui crossterm color-eyre
</code></pre>
<p>Explicando as libs com o <code>ratatui</code> que √© nossa lib base e o <code>crossterm</code> que como usamos no jogo anterior ele vai executar comandos no nosso terminal e finalmente o <code>color-eyre</code> que √© apenas para colorir nossa sa√≠da do terminal quando houver erro no nosso programa.</p>
<p>Agora vamos colar o exemplo do site do <a href="https://ratatui.rs/tutorials/hello-ratatui/">ratatui</a></p>
<pre><code class="language-rust">use color_eyre::Result;
use crossterm::event::{self, Event};
use ratatui::{DefaultTerminal, Frame};

fn main() -&gt; Result&lt;()&gt; {
    color_eyre::install()?;
    let terminal = ratatui::init();
    let result = run(terminal);
    ratatui::restore();
    result
}

fn run(mut terminal: DefaultTerminal) -&gt; Result&lt;()&gt; {
    loop {
        terminal.draw(render)?;
        if matches!(event::read()?, Event::Key(_)) {
            break Ok(());
        }
    }
}

fn render(frame: &amp;mut Frame) {
    frame.render_widget(&quot;hello world&quot;, frame.area());
}
</code></pre>
<p>Explicando pontualmente para usar o <em>ratatui</em> na nossa main atrav√©s do <code>ratatui::init();</code>que basicamente inicializa um terminal, isso quer dizer que esse objeto √© respons√°vel para desenhar dentro do terminal.</p>
<p>Agora temos duas fun√ß√µes que ser√£o muito importantes:</p>
<pre><code class="language-rust">fn run(mut terminal: DefaultTerminal) -&gt; Result&lt;()&gt; {
</code></pre>
<p>Essa fun√ß√£o vai ser respons√°vel para chamar nossa fun√ß√£o de desenho que chamamos  aqui de render e tamb√©m ali vamos fazer as itera√ß√µes com teclado ou mouse pro nosso jogo.
Deixamos um loop infinito ali onde nesse caso clicando qualquer tecla damos um <code>break</code> e sa√≠mos do programa.</p>
<p>E na fun√ß√£o:</p>
<pre><code class="language-rust">fn render(frame: &amp;mut Frame) {
</code></pre>
<p>√© nossa fun√ß√£o pra desenhar nossa tela, podemos ter mais fun√ß√µes de render se tivermos muitas telas pra desenhar, mas basicamente aqui nos vamos clicar nossos widgets.</p>
<p>Um ponto importante aqui conhe√ßo j√° o nosso m√©todo <code>frame.area())</code> onde ele marca o tamanho do terminal como um todo.</p>
<h2 id="conceito-do-grid">Conceito do grid</h2>
<p>Agora quero falar um pouco de como podemos desenhar as telas da nossa TUI, no caso do <code>ratatui</code> temos um conceito de <em>chunks</em> ou seja, s√£o peda√ßos do nosso <em>layout</em> com eles podemos definir sess√µes pro nosso jogo. </p>
<p>Veja na imagem abaixo vamos separar nosso layout do jogo em 3 partes ou 3 <em>chunks</em> uma pro header, outra pro footer e finalmente o meio pro Grid.</p>
<p><a class="glightbox" href="../images/M4/curso-rust-m4-3-layers.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="" src="../images/M4/curso-rust-m4-3-layers.png" /></a></p>
<p>Com isso podemos criar na nossa fun√ß√£o render nosso layout padr√£o.</p>
<pre><code class="language-rust">    let size = frame.area();

    // Layout principal
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3), // Header
            Constraint::Min(0),    // Game area
            Constraint::Length(3), // Footer
        ])
        .split(size);
</code></pre>
<p>Aqui vamos definir que o <em>size</em> do nosso projeto vai ser toda a √°rea do frame, com isso podemos definir nossos <em>chunks</em>. Pra iniciar nosso layout n√≥s passamos o <code>Layout::default()</code> que fica respons√°vel por iniciar nosso layout.</p>
<p>Em <code>direction(Direction::Vertical)</code> n√≥s passamos como vamos dividir os <em>chunks</em> que nesse caso ser√° vertical. Em <code>constraints</code> n√≥s definimos os peda√ßos e pro nosso footer e header vamos passar o valor <em>3</em> que nesse caso vai ser interpretado como linhas e a √°rea do jogo colocamos como <code>Min(0)</code> que dentro da biblioteca vai ocupar todo o espa√ßo dispon√≠vel no layout.</p>
<p>Finalmente usamos o <code>.split(size)</code> que aqui tem como objetivo pegar a area da nossa tela e fazer o split conforme capturamos.</p>
<p>Com isso ainda n√£o vamos ter nada por que n√£o renderizamos a tela mas, podemos come√ßar a desenha nossa tela.</p>
<p>Pra saber mais dessa parte pode ver aqui.</p>
<p><a href="https://ratatui.rs/tutorials/json-editor/ui/">Layout do ratatui</a>
<a href="https://ratatui.rs/examples/layout/layout/#_top">Propor√ß√µes</a></p>
<h2 id="arquitetando-nosso-jogo">Arquitetando nosso jogo</h2>
<p>Vamos agora criar dois arquivos pro nosso jogo, o primeiro vai ser o m√≥dulo pro
nosso jogo vamos chamar de <code>ui.rs</code>.</p>
<pre><code class="language-bash">touch src/ui.rs
</code></pre>
<p>Esse m√≥dulo vamos concentrar tudo relacionado ao desenho da tela do nosso jogo, agora vamos
mudar a forma que trabalhamos com nossos testes, vamos criar um diret√≥rio dedicado pros testes e tamb√©m um arquivo chamado <code>test_ui.rs</code>.</p>
<pre><code class="language-bash">mkdir -p tests
touch tests/tests_ui.rs
</code></pre>
<p>Agora vamos criar no nosso <code>src</code> um arquivo chamado <code>lib.rs</code> e agora ao inv√©s de exportar nossos m√≥dulos no nosso <code>main.rs</code> vamos exportar diretamente no nosso <code>lib.rs</code>.</p>
<h3 id="por-que-no-lib-e-nao-direto-no-main">Por que no lib e n√£o direto no main?</h3>
<p>Primeiro quando exportamos para <code>lib.rs</code> estamos deixando nossos m√≥dulos como APIs p√∫blicas e eles podem ser reutilizados por outros bin√°rios se houvesse no nosso c√≥digo, mas tamb√©m pro nosso caso vai facilitar pra testarmos nosso c√≥digo atrav√©s de um diret√≥rio externo que √© o caso do nosso diret√≥rio <code>tests</code>.</p>
<p>Com isso agora vamos fazer uma pequena revis√£o sobre <code>clousures</code>.</p>
<h2 id="closures">Closures</h2>
<p><strong>Closures</strong> (ou fun√ß√µes an√¥nimas) s√£o fun√ß√µes que podem processar elementos do ambiente onde foram definidas. Diferente de fun√ß√µes regulares criadas com <code>fn</code>, closures s√£o an√¥nimas (n√£o precisam de nome) e t√™m a capacidade especial de "lembrar" e usar vari√°veis do escopo onde foram criadas. Em Rust, o compilador analisa como cada vari√°vel √© capturada e escolhe automaticamente a melhor estrat√©gia de implementa√ß√£o.</p>
<p>A sintaxe b√°sica de uma closure √© simples: <code>|par√¢metros| express√£o</code>. Por exemplo, <code>|x| x + 1</code> √© uma closure que recebe um valor e retorna esse valor incrementado. Closures podem ser armazenadas em vari√°veis e passadas como argumentos para outras fun√ß√µes, tornando-as perfeitas para callbacks, iteradores e programa√ß√£o funcional.</p>
<pre><code class="language-rust">// Closure simples que captura uma vari√°vel do ambiente
let multiplicador = 5;
let multiplicar = |x| x * multiplicador; // Captura 'multiplicador'

println!(&quot;10 * {} = {}&quot;, multiplicador, multiplicar(10)); // 50
</code></pre>
<p>Rust possui tr√™s traits principais para closures, que determinam como elas capturam e usam vari√°veis:
- <strong><code>Fn</code></strong>: captura por refer√™ncia imut√°vel (<code>&amp;T</code>) - pode ser chamada m√∫ltiplas vezes sem modificar o ambiente
- <strong><code>FnMut</code></strong>: captura por refer√™ncia mut√°vel (<code>&amp;mut T</code>) - pode modificar o ambiente, mas pode ser chamada m√∫ltiplas vezes
- <strong><code>FnOnce</code></strong>: captura por valor (toma posse, move) - consome o ambiente, s√≥ pode ser chamada uma vez</p>
<pre><code class="language-rust">// Exemplo dos tr√™s tipos de closures
let mut contador = 0;

// Fn - apenas l√™, n√£o modifica
let ler = || println!(&quot;Contador: {}&quot;, contador);
ler();
ler(); // Pode chamar m√∫ltiplas vezes

// FnMut - modifica o ambiente
let mut incrementar = || {
    contador += 1;
    contador
};
println!(&quot;Novo valor: {}&quot;, incrementar()); // 1
println!(&quot;Novo valor: {}&quot;, incrementar()); // 2

// FnOnce - consome o valor (move)
let mensagem = String::from(&quot;Sistema ativado!&quot;);
let consumir = || {
    println!(&quot;{}&quot;, mensagem);
    mensagem // move mensagem pra fora
};
consumir(); // OK
// consumir(); // ERRO! N√£o pode chamar de novo
</code></pre>
<h3 id="por-que-closures-sao-importantes">Por que Closures s√£o Importantes?</h3>
<p>Closures s√£o fundamentais em Rust porque permitem:
1. <strong>Callbacks e Event Handlers</strong>: responder a eventos com l√≥gica customizada
2. <strong>Iteradores</strong>: transformar e filtrar cole√ß√µes de forma elegante com <code>map</code>, <code>filter</code>, <code>for_each</code>
3. <strong>Programa√ß√£o Funcional</strong>: compor opera√ß√µes complexas de forma declarativa
4. <strong>Lazy Evaluation</strong>: adiar computa√ß√µes at√© que sejam realmente necess√°rias
5. <strong>Threads</strong>: passar c√≥digo com contexto para execu√ß√£o paralela</p>
<p>Com isso podemos come√ßar a desenhar nosso header.</p>
<h2 id="criando-um-render-pro-nosso-header">Criando um render pro nosso header</h2>
<p>Primeiro vamos criar um teste para verificar se nossa fun√ß√£o <code>draw_header</code> existe. Nesse momento n√£o vamos usar o <code>rstest</code> pra criar uma <code>fixture</code> mas, vamos criar uma fun√ß√£o auxiliar.</p>
<p>Pra isso vamos importar a <code>struct</code> <code>TestBackend</code> que j√° vem com o <code>ratatui</code>,  com ele podemos criar uma terminal de teste e usar no nosso c√≥digo.</p>
<pre><code class="language-rust">use ratatui::backend::{backend::TestBackend, Terminal};

fn setup_terminal() -&gt; Terminal&lt;TestBackend&gt; {
    let backend = TestBackend::new(80, 24);
    Terminal::new(backend).unwrap()
}
</code></pre>
<p>Ent√£o a fun√ß√£o <code>setup_terminal</code> vai retornar um terminal pra n√≥s e assim podemos usar o m√©todo <code>new</code> pra gerar nosso backend, depois usando a <code>struct</code> <code>Terminal</code> criamos o terminal em si.</p>
<p>Com isso podemos criar um teste pra apenas verificar se vai ser chamada a nossa fun√ß√£o <code>draw_header</code> que vamos implementar.</p>
<p>Nossa fun√ß√£o <code>draw_header</code> vamos criar um terminal e chamar seu m√©todo <code>draw</code> e no m√©todo vamos passar o retorno da nossa fun√ß√£o <code>draw_header</code> e assim podemos passar o retorno da nossa fun√ß√£o <code>draw_header</code> como uma <code>clousure</code>. Finalmente podemos encadear um <code>expect</code> depois do <code>draw</code> para lan√ßar um erro caso aconte√ßa algum problema.</p>
<pre><code class="language-rust">use ratatui::{backend::TestBackend, layout::Rect, Terminal};

#[test]
fn test_draw_header_renders_successfully() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 3);

    // Act - Assert
    terminal
        .draw(|f| draw_header(f, area))
        .expect(&quot;draw_header should render&quot;);
}
</code></pre>
<p>Aqui nosso teste n√£o tem um assert por que s√≥ o fato de renderizar j√° √© considerado um sucesso, ent√£o vamos rodar assim o nosso c√≥digo e vamos ter o erro abaixo:</p>
<pre><code class="language-bash">error[E0425]: cannot find function `draw_header` in this scope
  --&gt; tests/tests_ui.rs:34:19
   |
34 |         .draw(|f| draw_header(f, area))
   |                   ^^^^^^^^^^^ not found in this scope
</code></pre>
<p>Bom como sabemos esse erro √© por que n√£o temos o draw_header criado, vamos cria-lo na nosso m√≥dulo ui.</p>
<pre><code class="language-rust">pub fn draw_header(f: &amp;mut Frame, area: Rect) {

}
</code></pre>
<p>Agora √© importante ressaltar que todas as fun√ß√µes que vamos testar ser√£o publicas nesse projeto, no futuro nos pr√≥ximos projetos vamos delimitar aspectos que precisam ser p√∫blicos e os aspectos privados, manejando os testes corretamente. Mas, nesse projeto eu quero que voc√™ se acostume a criar os testes de forma p√∫blica j√° que anteriormente s√≥ criamos testes no pr√≥prio
m√≥dulo.</p>
<p>Agora precisamos importar o <code>draw_header</code> no <code>tests_ui.rs</code> e depois rodar os testes:</p>
<pre><code class="language-rust">// tests_ui.rs
use wordsearch::ui::draw_header;

</code></pre>
<pre><code class="language-bash">    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/wordsearch-b906015e74c9ad81)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/wordsearch-ca09197567fe797a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/tests_ui.rs (target/debug/deps/tests_ui-547972e55c75e006)

running 1 test
test test_draw_header_renders_successfully ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests wordsearch

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Sucesso! Agora come√ßamos a construir o primeiro elemento da nossa ui.</p>
<h2 id="entendo-como-capturar-os-elementos-do-nosso-render">Entendo como capturar os elementos do nosso render</h2>
<p>Agora nosso teste j√° passou, queremos que nosso header tenha um label com o tempo que decorrido durante o jogo e o t√≠tulo do jogo que vai ser <code>_Wordsearch_</code>.</p>
<p>Pra isso vamos ter que criar no nosso teste uma nova fun√ß√£o auxiliar, nela vamos acessar nosso terminal de teste, ai vamos precisar navegar por alguns m√©todos, vamos acessar o m√©todo <code>backend</code> nele vamos acessar o m√©todo <code>buffer</code> que representa os elementos que foram renderizados. </p>
<p>Ent√£o vamos criar uma fun√ß√£o chamada <code>get_buffer_content</code>.</p>
<pre><code class="language-rust">fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;) {
    terminal
        .backend()
        .buffer()
}

</code></pre>
<p>Uma vez com isso ainda precisamos acessar o m√©todo <code>content</code> pra pegar o conte√∫do gerado para o buffer. O <code>content</code> vai retornar um tipo especial o <code>&amp;[Cell]</code> que √© uma cole√ß√£o e por usa vez tem implementado <code>iterator</code> pois ele √© uma sequ√™ncia de elementos.</p>
<pre><code class="language-rust">fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;){
    terminal
        .backend()
        .buffer()
        .content()
        .iter()
}
</code></pre>
<p>Como n√≥s queremos um conte√∫do especifico do <code>&amp;Cell</code> que foi gerado pelo nosso <code>iterator</code> vamos selecionado. No caso precisamo do campo <code>symbols</code> ent√£o vamos mapear todos os <code>symbols</code> dos elementos dentro do content e pra isso vamos criar uma <code>clousure</code> dedicada a capturar esse campo dos elementos de <code>content</code> e finalmente damos um <code>collect</code> no final.</p>
<p>O <code>collect</code> √© um m√©todo especial que ainda n√£o vimos mas, seu objetivo √© transformar um
<code>iterator</code> em uma cole√ß√£o, no nosso caso <code>symbols</code> √© um item do tipo <code>&amp;str</code> ent√£o o collect vai
transformar o retorno numa cole√ß√£o de <code>String</code> ent√£o vamos indicar que o retorno dessa fun√ß√£o √©
uma <code>String</code>.</p>
<pre><code class="language-rust">fn get_buffer_content(terminal: &amp;Terminal&lt;TestBackend&gt;) -&gt; String {
    terminal
        .backend()
        .buffer()
        .content()
        .iter()
        .map(|c| c.symbol())
        .collect()
}
</code></pre>
<p>Pra saber mais sobre os detalhes de cada m√©todo e seu retorno voc√™ pode <a href="https://docs.rs/ratatui/latest/ratatui/buffer/struct.Buffer.html#structfield.content">consultar a
documenta√ß√£o do <code>ratatui</code></a>.</p>
<h2 id="preenchendo-o-header">Preenchendo o header</h2>
<p>Ainda n√£o vamos desenhar a tela mas, vamos primeiro criar um teste nele vamos checar se dentro do conte√∫do do nosso header h√° uma string chamada tempo, uma string chamada <em>Found</em> que representa as palavras encontradas e outra chamada <code>_Wordsearch_</code>.</p>
<p>Com isso em mente vamos criar um teste chamado <code>test_draw_header_contains_required_elements</code> vamos passar como setup um terminal e uma area aqui vamos criar um ret√¢ngulo simples.</p>
<pre><code class="language-rust">#[test]
fn test_draw_header_contains_required_elements() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 3);

}

</code></pre>
<p>Agora vamos simplesmente chamar a fun√ß√£o <code>terminal.draw</code> precisamos fazer um desempacotamento
do m√©todo pois ele retorna um result.</p>
<pre><code class="language-rust">#[test]
fn test_draw_header_contains_required_elements() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 3);
    terminal.draw(|f| draw_header(f, area)).unwrap();

}

</code></pre>
<p>Agora vamos criar nosso <em>Act</em> recebendo o conte√∫do do nosso terminal gerado, pra isso vamos
usar a fun√ß√£o auxiliar <code>get_buffer_content</code> que criamos</p>
<pre><code class="language-rust">#[test]
fn test_draw_header_contains_required_elements() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 3);
    terminal.draw(|f| draw_header(f, area)).unwrap();

    // Act
    let content = get_buffer_content(&amp;terminal);

}
</code></pre>
<p>Finalmente vamos agora verificar se contem nele existem as strings que precisamos, pra isso
vamos usar a macro <code>assert!</code> e pra verificar vamos usar o pr√≥prio m√©todo contains que existe
dentro da <code>struct String</code>.</p>
<pre><code class="language-rust">#[test]
fn test_draw_header_contains_required_elements() {
    //Assert
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 3);
    terminal.draw(|f| draw_header(f, area)).unwrap();

    // Act
    let content = get_buffer_content(&amp;terminal);

    // Assert
    assert!(
        content.contains(&quot;Wordsearch&quot;), &quot;Should have a title&quot;
    );
    assert!(content.contains(&quot;Time:&quot;), &quot;Should have a label Time&quot;);
    assert!(
        content.contains(&quot;Found:&quot;),
        &quot;Should have a label Found&quot;
    );
}
</code></pre>
<p>Agora vamos rodar nosso teste e devemos receber a falha abaixo:</p>
<pre><code class="language-bash">failures:

---- test_draw_header_contains_required_elements stdout ----

thread 'test_draw_header_contains_required_elements' panicked at tests/tests_ui.rs:49:5:
Should have a title
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

</code></pre>
<p>Agora precisamos desenhar em si nosso header. Vamos criar uma <code>String</code>
para exibir o tempo.</p>
<pre><code class="language-rust">pub fn draw_header(f: &amp;mut Frame, area: Rect) {
    let time_str = String::from(&quot;Time: &quot;);

</code></pre>
<p>Agora vamos pra um t√≥pico novo dentro do <code>ratatui</code>, vamos trabalhar com a <code>struct Span</code>  para
criar nossos textos e para formata-los vamos chamar o m√©todo <code>styled</code>. Dentro de <code>styled</code> vamos
usar a <code>struct Style</code> para aplicar as formata√ß√µes, e sempre vamos chamar seu construtor
<code>default</code> para j√° nos entregar os atributos m√≠nimos preenchidos para facilitar nossa vida.</p>
<p>Essa √© uma forma parecida com uma formata√ß√£o <code>html</code>, assim podemos aplicar formata√ß√£o de texto
de forma mais conhecida para saber mais sobre as nossas op√ß√µes de estilos voc√™ pode <a href="https://docs.rs/ratatui/latest/ratatui/text/struct.Span.html">ver na
documenta√ß√£o</a>.</p>
<p>Para criar nosso t√≠tulo vamos criar um vetor chamado <code>header_text</code> e ele vai receber um vetor
de <a href="https://docs.rs/ratatui/latest/ratatui/text/struct.Line.html">Line</a> que basicamente
consiste em um ou mais spans. Ent√£o vamos adicionar um span para a palavra <code>Wordsearch</code> um para
<code>Found</code> e vamos criar um espa√ßamento entre essas palavras usando <code>Span::raw</code> j√° que vai ser um texto
vazio apenas.</p>
<p>Vamos tamb√©m por um √≠cone de lupa no nosso <code>header</code> pra isso vamos copiar o emoji atrav√©s do
site do <a href="https://emojipedia.org/"><code>emojipedia</code></a>.</p>
<pre><code class="language-rust">pub fn draw_header(f: &amp;mut Frame, area: Rect) {
    let time_str = String::new(&quot;Time: &quot;);

    let header_text = vec![Line::from(vec![
        Span::styled(
            &quot;üîç Wordsearch&quot;,
            Style::default()
                .fg(Color::Yellow.into())
                .add_modifier(Modifier::BOLD),
        ),
        Span::raw(&quot;  &quot;),
        Span::styled(time_str, Style::default().fg(Color::Cyan.into())),
        Span::raw(&quot;  &quot;),
        Span::styled(format!(&quot;Found: &quot;,), Style::default().fg(Color::Green.into())),
    ])];
</code></pre>
<p>Finalmente podemos fazer o render em si, agora precisamos para isso criar uma vari√°vel <code>header</code>
com ela vamos construir um <a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html"><code>Paragraph</code></a> que √© um widget que mostra um texto.</p>
<p>Ainda n√£o falei dos <em>widgets</em> mas, basicamente um <em>widget</em> √© um trecho de c√≥digo reutiliz√°vel para renderizar algum elemento da tela, pense como um peda√ßo do <em>layout</em> da sua tela, eles s√£o uteis pois s√£o elementos que podemos reutilizar e representam algum aspecto da nossa tela, seja um texto, um bot√£o ou qualquer outro
elemento visual que precisamos.</p>
<p>Al√©m do <code>Paragraph</code> n√≥s queremos que nosso header tenha uma borda, no <code>ratatui</code> precisamos
nesse caso criar uma <a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Paragraph.html#method.block"><code>Block</code></a> e tamb√©m vamos chamar o m√©todo <code>default()</code> para preencher com os valores m√≠nimos.</p>
<p>E pra finalizar nossa formata√ß√£o vamos usar uma <a href="https://docs.rs/ratatui/latest/ratatui/widgets/struct.Wrap.html"><code>struct Wrap</code></a> para configurar a quebra de linha e a op√ß√£o <code>trim</code> que √© para ajustar os espa√ßos, assim nossos textos n√£o v√£o ficar cortados e v√£o se ajustar ao tamanho da tela de exibi√ß√£o, ent√£o se voc√™ n√£o estiver usando o terminal como eu em tela cheia vai perceber que ele vai ajustar o texto com o tamanho da sua tela de terminal e n√£o vai cortar o texto.</p>
<pre><code class="language-rust">pub fn draw_header(f: &amp;mut Frame, area: Rect) {
    let time_str = String::new(&quot;Time: &quot;);

    let header_text = vec![Line::from(vec![
        Span::styled(
            &quot;üîç Wordsearch&quot;,
            Style::default()
                .fg(Color::Yellow.into())
                .add_modifier(Modifier::BOLD),
        ),
        Span::raw(&quot;  &quot;),
        Span::styled(time_str, Style::default().fg(Color::Cyan.into())),
        Span::raw(&quot;  &quot;),
        Span::styled(format!(&quot;Found: &quot;,), Style::default().fg(Color::Green.into())),
    ])];

    let header = Paragraph::new(header_text)
        .block(Block::default().borders(Borders::ALL))
        .wrap(Wrap { trim: true });

    f.render_widget(header, area);
}

</code></pre>
<p>Agora podemos rodar os testes novamente:</p>
<pre><code class="language-bash">cargo test
running 2 tests
test test_draw_header_contains_required_elements ... ok
test test_draw_header_renders_successfully ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests wordsearch

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Com o nosso teste funcionando vamos adicionar agora no nosso main dentro do nosso render. Vamos
passar a posi√ß√£o 0 do nosso <em>chunks</em> que √© a parte do <em>layout</em> do <code>header</code>.</p>
<pre><code class="language-rust">fn render(frame: &amp;mut Frame) {
    let size = frame.area();

    // Layout principal
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3), // Header
            Constraint::Min(0),    // Game area
            Constraint::Length(3), // Footer
        ])
        .split(size);

    // Header com informa√ß√µes do jogo
    draw_header(frame, chunks[0]);

</code></pre>
<h2 id="option-result-wrap-unwrap-e-expect">Option, Result, Wrap, Unwrap e Expect</h2>
<p>Bom agora chegou a hora de falarmos de algumas coisas que estamos usando a algum tempo e at√©
agora voc√™ sabia que existia e n√£o entramos muito a fundo e agora chegou a hora.</p>
<h3 id="wrap">Wrap</h3>
<p>Antes de falar sobre desembrulhar (unwrap), precisamos entender como embrulhar valores em Rust. Pense nisso como colocar um presente em uma caixa:
Nesse presente temos o conte√∫do que queremos dar e ele pode vir com um valor que queremos, ou
vazio ou ainda com uma mensagem do por que n√£o pode entregar o conte√∫do. Em rust por <em>default</em>
vai querer embrulhar sua resposta no m√©todo <code>main</code> que √© o nosso <code>Result</code> mas, tamb√©m durante
esse curso algumas vezes embrulhamos nossos valores usando um <code>Option</code>.</p>
<h3 id="option">Option<T></h3>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Option<T></a> √© um <code>enum</code> (tipo enumerado) que representa a possibilidade de ter um valor ou n√£o ter nada. Ele tem dois poss√≠veis estados:</p>
<p>Some(valor): O valor existe e pode ser acessado
None: N√£o h√° valor ‚Äî represente o "vazio" com seguran√ßa</p>
<pre><code class="language-rust">fn recuperar_muni√ß√£o_do_arsenal(tipo: &amp;str) -&gt; Option&lt;i32&gt; {
    match tipo {
        &quot;m√≠ssil&quot; =&gt; Some(5),        // Temos 5 m√≠sseis
        &quot;laser&quot; =&gt; Some(999),       // Energia infinita de laser
        &quot;plasma&quot; =&gt; None,           // N√£o temos plasma, estamos sem ele
        _ =&gt; None,                  // Tipo desconhecido = nada
    }
}

fn equipar_arma() {
    let muni√ß√£o = recuperar_muni√ß√£o_do_arsenal(&quot;m√≠ssil&quot;);

    match muni√ß√£o {
        Some(qtd) =&gt; println!(&quot;Equipado! Temos {} m√≠sseis!&quot;, qtd),
        None =&gt; println!(&quot;Arsenal vazio! Sem muni√ß√£o desse tipo.&quot;),
    }
}
</code></pre>
<p>Voc√™ usa Option quando uma opera√ß√£o pode n√£o retornar nada, mas n√£o h√° um "erro" em sentido t√©cnico. Por exemplo: buscar o primeiro soldado em uma lista (pode n√£o haver nenhum), procurar um item em um mapa (pode n√£o ter sido guardado l√°), ou verificar se um inimigo foi detectado pelo radar (o sensor pode estar desligado ou n√£o ter alvos). O Rust for√ßa voc√™ a lidar com ambos os casos, eliminando bugs silenciosos onde voc√™ acessa null por acidente.</p>
<p>Essa √© a forma dele tratar o famoso <em>null pointer</em> assim ao inv√©s de checar se o valor √© nulo
n√≥s verificamos se h√° algo ali.</p>
<h4 id="metodos-uteis">M√©todos √∫teis</h4>
<pre><code class="language-rust">let valor = Some(42);

// unwrap_or: se Some, retorna; se None, retorna padr√£o
let resultado = valor.unwrap_or(0);  // 42

// map: transforma o valor se existir
let dobrado = valor.map(|x| x * 2);  // Some(84)

// is_some / is_none: verifica√ß√µes simples
if valor.is_some() {
    println!(&quot;Tem valor!&quot;);
}
</code></pre>
<h3 id="result">Result<T></h3>
<p>Agora vamos para algo que usamos muito no nosso dia-a-dia com rust, o <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result<T, E></a> √© um <code>enum</code> com dois poss√≠veis estados que representa o resultado de uma opera√ß√£o que pode falhar:</p>
<p>Ok(valor): A opera√ß√£o funcionou e retorna um valor do tipo T
Err(erro): A opera√ß√£o falhou e retorna informa√ß√µes sobre o erro do tipo E</p>
<pre><code class="language-rust">fn conectar_ao_servidor_central(endere√ßo: &amp;str) -&gt; Result&lt;String, String&gt; {
    // Simulando tentativa de conex√£o
    if endere√ßo.contains(&quot;v√°lido&quot;) {
        Ok(&quot;Conex√£o estabelecida com sucesso!&quot;.to_string())
    } else {
        Err(&quot;Erro: Endere√ßo do servidor inv√°lido&quot;.to_string())
    }
}

// Usando o resultado
fn sincronizar_dados() {
    let resultado = conectar_ao_servidor_central(&quot;servidor-v√°lido.com&quot;);

    match resultado {
        Ok(mensagem) =&gt; println!(&quot;‚úì {}&quot;, mensagem),
        Err(erro) =&gt; println!(&quot;‚úó Falha: {}&quot;, erro),
    }
}
</code></pre>
<p>Voc√™ usa Result quando uma opera√ß√£o pode ter sucesso ou falha com uma raz√£o espec√≠fica. Por exemplo: conectar ao servidor central (pode falhar por rede), ler dados do sensores (pode haver interfer√™ncia), ou disparar a arma principal (pode travar). A diferen√ßa crucial: com Result, voc√™ sabe por que algo falhou, n√£o s√≥ que falhou.</p>
<h3 id="metodos-uteis_1">M√©todos √∫teis</h3>
<pre><code class="language-rust">let resultado = Ok::&lt;i32, String&gt;(50);

// unwrap_or: se Ok, retorna; se Err, retorna padr√£o
let valor = resultado.unwrap_or(0);  // 50

// map: transforma o Ok se existir
let dobrado = resultado.map(|x| x * 2);  // Ok(100)

// ? (operador try): retorna Err imediatamente (aprenderemos depois!)
fn operacao() -&gt; Result&lt;i32, String&gt; {
    let x = disparar_arma_principal(100)?;  // Se falhar, retorna o erro
    Ok(42)
}
</code></pre>
<h3 id="unwrap-expect">unwrap - expect</h3>
<p>Em Rust, tanto Option<T> quanto Result<T, E> encapsulam valores que podem ou n√£o estar presentes. √Äs vezes, por√©m, voc√™ est√° absolutamente certo de que o valor existe (ou aceita que o programa falhe se n√£o existir). √â a√≠ que unwrap() e expect() entram em cena.
O que fazem esses m√©todos?
unwrap() extrai o valor interno de um Option ou Result. Se for Some(valor) ou Ok(valor), voc√™ recebe valor. Se for None ou Err(e), o programa entra em p√¢nico (panic) e termina com uma mensagem gen√©rica:</p>
<pre><code class="language-rust">fn main() {
    let combustivel: Option&lt;u32&gt; = Some(100);
    let quantidade = combustivel.unwrap(); // 100 ‚Äî tudo certo!

    let vazio: Option&lt;u32&gt; = None;
    // let falha = vazio.unwrap(); // ‚ö†Ô∏è PANIC: &quot;called `Option::unwrap()` on a `None` value&quot;

}
</code></pre>
<h3 id="expect">Expect</h3>
<p>expect(mensagem) faz o mesmo que unwrap(), mas permite que voc√™ forne√ßa uma mensagem personalizada de erro. Isso torna o p√¢nico mais informativo durante a depura√ß√£o:</p>
<pre><code class="language-rust">let resultado: Result&lt;String, &amp;str&gt; = Err(&quot;falha no reator&quot;);
// let comando = resultado.expect(&quot;Sistema de propuls√£o falhou!&quot;); 
// ‚ö†Ô∏è PANIC: &quot;Sistema de propuls√£o falhou!: falha no reator&quot;
</code></pre>
<p>Quando usar unwrap/expect?</p>
<ul>
<li>Em testes unit√°rios: onde voc√™ quer que o teste falhe imediatamente se algo inesperado acontecer.</li>
<li>Em prot√≥tipos: para desenvolvimento r√°pido antes de adicionar tratamento de erros robusto.</li>
<li>Quando h√° garantia l√≥gica: por exemplo, depois de verificar explicitamente com is_some() ou is_ok()</li>
<li>Em c√≥digo de exemplo: para manter a clareza sem distrair com tratamento de erros</li>
</ul>
<h3 id="boas-praticas">Boas pr√°ticas</h3>
<p>Em c√≥digo de produ√ß√£o, prefira m√©todos que n√£o causam p√¢nico:</p>
<pre><code class="language-rust">// ‚ùå Perigoso em produ√ß√£o
let valor = opcao.unwrap();

// ‚úÖ Tratamento seguro com match
let valor = match opcao {
    Some(v) =&gt; v,
    None =&gt; return Err(&quot;Valor ausente&quot;),
};

// ‚úÖ Valor padr√£o com unwrap_or
let valor = opcao.unwrap_or(0);

// ‚úÖ Computa√ß√£o lazy com unwrap_or_else  
let valor = opcao.unwrap_or_else(|| calcular_padrao());

// ‚úÖ Propaga√ß√£o de erros com ?
let valor = resultado?;
</code></pre>
<h3 id="operador">Operador ?</h3>
<p>O operador ? √© uma forma elegante e segura de desembrulhar valores, mas ao inv√©s de causar p√¢nico, ele propaga o erro para quem chamou a fun√ß√£o. √â como dizer: "Se der erro aqui, eu n√£o posso resolver, ent√£o passo o problema para cima".</p>
<pre><code class="language-rust">// ‚ùå Sem o operador ? (verbose)
fn processar_dados() -&gt; Result&lt;String, String&gt; {
    let dado1 = match obter_dado1() {
        Ok(d) =&gt; d,
        Err(e) =&gt; return Err(e),  // Propagar erro manualmente
    };

    let dado2 = match obter_dado2() {
        Ok(d) =&gt; d,
        Err(e) =&gt; return Err(e),  // Propagar erro manualmente
    };

    Ok(format!(&quot;{} {}&quot;, dado1, dado2))
}

// ‚úÖ Com o operador ? (limpo e conciso)
fn processar_dados() -&gt; Result&lt;String, String&gt; {
    let dado1 = obter_dado1()?;  // Se Err, retorna automaticamente
    let dado2 = obter_dado2()?;  // Se Err, retorna automaticamente

    Ok(format!(&quot;{} {}&quot;, dado1, dado2))
}
</code></pre>
<p>O operador ? faz tr√™s coisas:</p>
<p>Se Ok/Some: Desembrulha o valor e continua
Se Err/None: Converte e retorna o erro imediatamente
Convers√£o autom√°tica: Converte tipos de erro compat√≠veis</p>
<p>‚úÖ USE quando:</p>
<p>A fun√ß√£o j√° retorna Result ou Option
Voc√™ quer propagar erros para o chamador
N√£o precisa fazer tratamento local do erro
Quer c√≥digo limpo e conciso</p>
<p>‚ùå N√ÉO use quando:</p>
<p>Precisa tratar o erro localmente
Quer fornecer valor padr√£o (use unwrap_or etc.)
Os tipos de erro n√£o s√£o compat√≠veis</p>
<p>Diferen√ßa entre ?, unwrap e match:</p>
<pre><code class="language-rust">// Operador ? - Propaga erro (seguro, requer Result/Option)
let valor = funcao_que_pode_falhar()?;

// unwrap - Causa p√¢nico (perigoso)
let valor = funcao_que_pode_falhar().unwrap();

// match - Tratamento expl√≠cito (verboso mas claro)
let valor = match funcao_que_pode_falhar() {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e),
};
</code></pre>
<p>Exemplo pr√°tico em um sistema de mecha:</p>
<pre><code class="language-rust">use std::collections::HashMap;

struct SistemaMecha {
    energia: HashMap&lt;String, u32&gt;,
}

impl SistemaMecha {
    fn obter_energia(&amp;self, sistema: &amp;str) -&gt; Option&lt;u32&gt; {
        self.energia.get(sistema).copied()
    }

    // ‚ùå Vers√£o perigosa - pode causar panic
    fn ativar_arma_inseguro(&amp;self) {
        let energia = self.obter_energia(&quot;arma&quot;).unwrap();
        println!(&quot;Arma ativada com {} unidades&quot;, energia);
    }

    // ‚úÖ Vers√£o segura - retorna Result
    fn ativar_arma_seguro(&amp;self) -&gt; Result&lt;(), String&gt; {
        let energia = self.obter_energia(&quot;arma&quot;)
            .ok_or_else(|| &quot;Sistema de arma sem energia!&quot;.to_string())?;

        if energia &lt; 10 {
            return Err(&quot;Energia insuficiente para disparo!&quot;.to_string());
        }

        println!(&quot;Arma ativada com {} unidades&quot;, energia);
        Ok(())
    }
}
</code></pre>
<p>Lembre-se quando usamos unwrap() √© como um bot√£o de eje√ß√£o, use apenas quando estiver preparado para as consequ√™ncias ou quando tiver certeza absoluta de que √© seguro.</p>
<h2 id="macros">Macros</h2>
<p>Existem dois tipos principais de macros em Rust: macros declarativas (definidas com [macro_rules!]https://doc.rust-lang.org/rust-by-example/macros.html) e macros procedurais (que s√£o fun√ß√µes especiais anotadas com atributos). As macros declarativas funcionam atrav√©s de pattern matching, voc√™ define padr√µes de sintaxe que a macro deve reconhecer e especifica o c√≥digo que deve ser gerado quando esse padr√£o √© encontrado. Elas s√£o como um match expression super-poderoso que trabalha com tokens de c√≥digo ao inv√©s de valores. As macros procedurais, por outro lado, s√£o mais flex√≠veis e podem manipular o AST (Abstract Syntax Tree) diretamente, mas tamb√©m s√£o mais complexas e requerem uma crate separada.</p>
<p>Exemplo B√°sico: Macro declarativa</p>
<pre><code class="language-rust">macro_rules! log_status {
    ($msg:expr) =&gt; {
        println!(&quot;[STATUS] {}&quot;, $msg);
    };

    ($level:expr, $msg:expr) =&gt; {
        println!(&quot;[{}] {}&quot;, $level, $msg);
    };
}

fn main() {
    log_status!(&quot;Sistema inicializado&quot;);
    log_status!(&quot;INFO&quot;, &quot;Todos os sistemas operacionais&quot;);

    // println!(&quot;[STATUS] {}&quot;, &quot;Sistema inicializado&quot;);
    // println!(&quot;[{}] {}&quot;, &quot;INFO&quot;, &quot;Todos os sistemas operacionais&quot;);
}
</code></pre>
<p>Fragmentos de Sintaxe (Fragment Specifiers)
Macros podem capturar diferentes tipos de elementos sint√°ticos:</p>
<p>expr - express√µes (como 2 + 2, minha_funcao())
ident - identificadores (nomes de vari√°veis, fun√ß√µes)
ty - tipos (i32, Vec<String>)
stmt - statements (declara√ß√µes)
block - blocos de c√≥digo ({ ... })
tt - token tree (qualquer token)
literal - literais (42, "texto")</p>
<pre><code class="language-rust">macro_rules! comando_mecha {
    // Captura um identificador (nome da a√ß√£o)
    ($acao:ident) =&gt; {
        println!(&quot;Executando comando: {}&quot;, stringify!($acao));
    };

    // Captura um identificador e uma express√£o (com par√¢metro)
    ($acao:ident, $param:expr) =&gt; {
        println!(&quot;Executando {}: com par√¢metro {}&quot;, 
                 stringify!($acao), $param);
    };
}

fn main() {
    comando_mecha!(avan√ßar);           // Identifica a a√ß√£o
    comando_mecha!(girar, 90);         // A√ß√£o com par√¢metro
}
</code></pre>
<p>Por que usar Macros?</p>
<p>Evitar repeti√ß√£o de c√≥digo (DRY - Don't Repeat Yourself): quando voc√™ tem um padr√£o que se repete mas n√£o pode ser abstra√≠do com fun√ß√µes
Criar DSLs (Domain-Specific Languages): criar sintaxe customizada para seu dom√≠nio
Interfaces vari√°veis: aceitar n√∫mero vari√°vel de argumentos (como println!, vec!)
Gera√ß√£o de c√≥digo em tempo de compila√ß√£o: zero overhead em runtime
Capturar informa√ß√µes do contexto: como file!(), line!(), column!() que fun√ß√µes n√£o conseguem</p>
<h2 id="trabalhando-com-o-footer">Trabalhando com o footer</h2>
<p>Agora vamos come√ßar a desenhar nosso footer, primeiro vamos criar um teste parecido com o header pra ver se ele consegue chamar a fun√ß√£o <code>draw_footer</code>.</p>
<pre><code class="language-rust">#[test]
fn test_draw_footer_renders_successfully() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 4);

    // Act - Assert
    terminal
        .draw(|f| draw_footer(f, area))
        .expect(&quot;draw_footer should render&quot;);
}
</code></pre>
<p>Agora vamos rodar o nosso teste:</p>
<pre><code class="language-bash">‚ùØ cargo test
   Compiling wordsearch v0.1.0 (/home/feanor/projects/wordsearch)
error[E0425]: cannot find function `draw_footer` in this scope
   --&gt; tests/tests_ui.rs:108:19
    |
108 |         .draw(|f| draw_footer(f, area))
    |                   ^^^^^^^^^^^ not found in this scope

For more information about this error, try `rustc --explain E0425`.
error: could not compile `wordsearch` (test &quot;tests_ui&quot;) due to 1 previous error
</code></pre>
<p>Certo isso acontece por que n√£o temos uma fun√ß√£o <code>draw_footer</code> ainda. Ent√£o vamos cria-la e ele
vai seguir a mesma assinatura do nosso <code>draw_header</code> pois eles possuem a mesma fun√ß√£o.</p>
<pre><code class="language-rust">//ui.rs
pub fn draw_footer(f: &amp;mut Frame, area: Rect) {
}
</code></pre>
<p>Agora importamos ele no teste e vamos executar novamente.</p>
<pre><code class="language-rust">running 3 tests
test test_draw_header_renders_successfully ... ok
test test_draw_footer_renders_successfully ... ok
test test_draw_header_contains_required_elements ... ok

</code></pre>
<p>Para o footer vamos precisar colocar os comandos do jogo pra auxiliar nosso jogador e pra isso
vamos criar um teste que verifique se o footer tem os comandos. Pra isso vamos criar um vetor
que vai armazenar uma tupla com duas <code>&amp;str</code>.</p>
<pre><code class="language-rust">#[test]
fn test_draw_footer_contains_all_controls() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 4);
    terminal.draw(|f| draw_footer(f, area)).unwrap();
    let controls = vec![
        (&quot;Move&quot;, &quot;movement in grid&quot;),
        (&quot;Select&quot;, &quot;selection letter&quot;),
        (&quot;Confirm&quot;, &quot;confirmation&quot;),
        (&quot;Clean&quot;, &quot;clean selection&quot;),
        (&quot;Close&quot;, &quot;close game&quot;),
    ];

    // Act
    let content = get_buffer_content(&amp;terminal);
}
</code></pre>
<p>Agora pra testarmos a fun√ß√£o vamos criar um <em>loop</em> onde vamos comparar se na nossa vari√°vel
content h√° as strings que est√£o em <em>controls</em> e pra isso vamos criar um  <em>for</em> que vai percorrer o vetor de <em>controls</em> e desestruturar a tupla em duas vari√°veis pra percorrermos
durante o nosso loop e comparar com o conte√∫do de <em>content</em>.</p>
<pre><code class="language-rust">#[test]
fn test_draw_footer_contains_all_controls() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 4);
    terminal.draw(|f| draw_footer(f, area)).unwrap();
    let controls = vec![
        (&quot;Move&quot;, &quot;movement in grid&quot;),
        (&quot;Select&quot;, &quot;selection letter&quot;),
        (&quot;Confirm&quot;, &quot;confirmation&quot;),
        (&quot;Clean&quot;, &quot;clean selection&quot;),
        (&quot;Close&quot;, &quot;close game&quot;),
    ];

    // Act
    let content = get_buffer_content(&amp;terminal);

    // Assert
    for (action, description) in controls {
        assert!(
            content.contains(action),
            &quot;Should control for {}: '{}'&quot;,
            description,
            action
        );
    }
}
</code></pre>
<p>Agora rodando vamos ter a falha que vai ser o texto dentro do nosso <em>assert</em>.</p>
<pre><code class="language-bash">
failures:

---- test_draw_footer_contains_all_controls stdout ----

thread 'test_draw_footer_contains_all_controls' panicked at tests/tests_ui.rs:95:9:
Should control for movement in grid: 'move'
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Certo agora vamos implementar nossa fun√ß√£o passando todos os controles que queremos.</p>
<pre><code class="language-rust">fn draw_footer(f: &amp;mut Frame, area: Rect) {
    let footer_text = vec![
        Line::from(vec![
            Span::raw(&quot;Controls: &quot;),
            Span::styled(&quot;‚Üë‚Üì‚Üê‚Üí&quot;, Style::default().fg(Color::Yellow)),
            Span::raw(&quot; Move | &quot;),
            Span::styled(&quot;SPACE&quot;, Style::default().fg(Color::Yellow)),
            Span::raw(&quot; Select | &quot;),
            Span::styled(&quot;ENTER&quot;, Style::default().fg(Color::Yellow)),
            Span::raw(&quot; Confirm | &quot;),
            Span::styled(&quot;c&quot;, Style::default().fg(Color::Yellow)),
            Span::raw(&quot; Clean | &quot;),
            Span::styled(&quot;q/ESC&quot;, Style::default().fg(Color::Yellow)),
            Span::raw(&quot; Close&quot;),
        ]),
        Line::from(vec![
            Span::styled(&quot;Status: &quot;, Style::default().fg(Color::Cyan)),
            Span::raw(&quot; &quot;),
        ]),
    ];

    let footer = Paragraph::new(footer_text)
        .block(Block::default().borders(Borders::ALL))
        .wrap(Wrap { trim: true });

    f.render_widget(footer, area);
}

</code></pre>
<p>Agora rodamos os testes e vemos que tudo est√° funcionando:</p>
<pre><code class="language-bash">running 4 tests
test test_draw_header_renders_successfully ... ok
test test_draw_header_contains_required_elements ... ok
test test_draw_footer_renders_successfully ... ok
test test_draw_footer_contains_all_controls ... ok
</code></pre>
<p>Agora precisamos colocar nossa fun√ß√£o footer no <code>main.rs</code></p>
<pre><code class="language-rust">fn main() {
    //c√≥digo

    // Header
    draw_header(frame, chunks[0]);
    // Footer
    draw_footer(frame, chunks[2]);

}
</code></pre>
<p>Importante refor√ßar que o footer como √© a ultima parte do nosso layout ele vai pro <code>chunks[2]</code> e podemos ver ele funcionando.</p>
<p>Vamos criar agora mais um teste para complementar o anterior e verificar se todos os comandos foram inseridos. Isso √© importante pra termos certeza que todas as op√ß√µes est√£o a vista do jogador.</p>
<pre><code class="language-rust">#[test]
fn test_draw_footer_shows_control_keys() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 4);
    terminal.draw(|f| draw_footer(f, area)).unwrap();

    // Act
    let content = get_buffer_content(&amp;terminal);
    let has_arrow_keys = content.contains(&quot;‚Üë&quot;) || content.contains(&quot;‚Üì&quot;);
    let has_space = content.contains(&quot;SPACE&quot;);
    let has_enter = content.contains(&quot;ENTER&quot;);
    let has_clear = content.contains(&quot;c&quot;);
    let has_quit = content.contains(&quot;q&quot;) || content.contains(&quot;ESC&quot;);

    // Assert
    assert!(has_arrow_keys, &quot;Should have the movement keys&quot;);
    assert!(has_space, &quot;Should show key space&quot;);
    assert!(has_enter, &quot;Should show key enter&quot;);
    assert!(has_clear, &quot;Should show key c&quot;);
    assert!(has_quit, &quot;Should show quit keys&quot;);
}
</code></pre>
<p>Agora verificando os testes:</p>
<pre><code class="language-bash">test test_draw_header_renders_successfully ... ok
test test_draw_header_contains_required_elements ... ok
test test_draw_footer_shows_control_keys ... ok
test test_draw_footer_renders_successfully ... ok
test test_draw_footer_contains_all_controls ... ok
</code></pre>
<p>Perfeito tudo funcionando! Agora podemos ir desenhar nosso grid.</p>
<h2 id="desenhando-o-grid">Desenhando o grid</h2>
<p>O grid ser√° necess√°rio dividir em partes, nesse primeiro momento s√≥ vamos desenha-lo. Mas,
ainda n√£o vamos por as palavras.</p>
<p>Para iniciar vamos fazer aquele teste b√°sico de ver se nosso <em>layout</em> de <em>grid</em> vai renderizar corretamente.</p>
<pre><code class="language-rust">#[test]
fn test_draw_grid_renders_successfully() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 20);

    // Act - Assert
    terminal
        .draw(|f| draw_grid(f, area))
        .expect(&quot;draw_grid deve renderizar sem erros&quot;);
}
</code></pre>
<p>Agora temos o erro que ele n√£o est√° no escopo:</p>
<pre><code class="language-bash">error[E0425]: cannot find function `draw_grid` in this scope
   --&gt; tests/tests_ui.rs:136:19
    |
136 |         .draw(|f| draw_grid(f, area))
    |                   ^^^^^^^^^ not found in this scope
</code></pre>
<p>Como as fun√ß√µes anteriores, vamos criar nossa fun√ß√£o <code>draw_grid</code> e tamb√©m vamos importar no
nosso teste.</p>
<pre><code class="language-rust">pub fn draw_grid(f: &amp;mut Frame, area: Rect) {
}
</code></pre>
<p>Agora se rodarmos os testes vamos ver que est√° tudo funcionando:</p>
<pre><code class="language-rust">running 6 tests
test test_draw_footer_shows_control_keys ... ok
test test_draw_grid_renders_successfully ... ok
test test_draw_footer_contains_all_controls ... ok
test test_draw_header_renders_successfully ... ok
test test_draw_footer_renders_successfully ... ok
test test_draw_header_contains_required_elements ... ok
</code></pre>
<p>Vamos criar um t√≠tulo na parte do <em>grid</em> mas, antes vamos criar um teste para verificar se nosso <em>grid</em> tem o t√≠tulo <em>Grade</em>.</p>
<pre><code class="language-rust">#[test]
fn test_draw_grid_has_title() {
    // Setup
    let mut terminal = setup_terminal();
    let area = Rect::new(0, 0, 80, 20);
    terminal.draw(|f| draw_grid(f, area)).unwrap();

    // Act
    let content = get_buffer_content(&amp;terminal);

    // Assert
    assert!(
        content.contains(&quot;Grade&quot;),
        &quot;Should a title 'Grade'&quot;
    );
}
</code></pre>
<p>Certo o teste agora falhou:</p>
<pre><code class="language-bash">failures:

---- test_draw_grid_has_title stdout ----

thread 'test_draw_grid_has_title' panicked at tests/tests_ui.rs:151:5:
Should a title 'Grade'
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Vamos criar um t√≠tulo no nosso <em>grid layout</em>. Nesse caso vamos criar um bloco e al√©m de criar
as bordas vamos dar a esse bloco o t√≠tulo <em>Grade</em> que queremos.</p>
<pre><code class="language-rust">pub fn draw_grid(f: &amp;mut Frame, area: Rect) {
    let block = Block::default().title(&quot;Grade&quot;).borders(Borders::ALL);

    f.render_widget(block, area);
}
</code></pre>
<p>Rodamos os testes:</p>
<pre><code class="language-bash">running 7 tests
test test_draw_grid_has_title ... ok
test test_draw_footer_renders_successfully ... ok
test test_draw_header_renders_successfully ... ok
test test_draw_grid_renders_successfully ... ok
test test_draw_header_contains_required_elements ... ok
test test_draw_footer_shows_control_keys ... ok
test test_draw_footer_contains_all_controls ... ok
</code></pre>
<p>Agora vamos adicionar ao nosso grid a nosso render.</p>
<pre><code class="language-rust">fn render(frame: &amp;mut Frame) {
    // Header
    draw_header(frame, chunks[0]);
    // Grid
    draw_grid(frame, chunks[1]);
    // Footer
    draw_footer(frame, chunks[2]);
}

</code></pre>
<p>Rodamos o nosso projeto e vemos que agora temos todos os elementos da nossa tela desenhados.</p>
<h2 id="arquitetando-nosso-grid-system">Arquitetando nosso <em>grid system</em></h2>
<p>Vamos come√ßar a trabalhar no nosso sistema que vai carregar as palavras e exibir na tela. Pra isso vamos come√ßar vamos criar um novo m√≥dulo para ser respons√°vel por todas as regras que s√£o relativas ao jogo em si, vamos chama-la de <code>game</code>, tamb√©m vamos criar um m√≥dulo que representa o nosso <em>grid</em> e chama-lo de <code>grid.rs</code>.</p>
<pre><code class="language-bash">touch src/game.rs
touch src/grid.rs
</code></pre>
<p>Vamos deixar esse m√≥dulo publico dentro do nosso <code>lib.rs</code></p>
<pre><code class="language-rust">pub mod ui;
pub mod game;
pub mod grid;

</code></pre>
<p>Para come√ßar nosso desenvolvimento vamos ter que criar uma representa√ß√£o do nosso <em>grid</em>.</p>
<h2 id="fundamentos-do-nosso-grid">Fundamentos do nosso grid.</h2>
<p>Agora preciso lhe explicar como vai funcionar nosso sistema de grid, primeiro teremos 4
estruturas distintas.</p>
<h3 id="grid">Grid</h3>
<p>Ele ser√° uma matriz de c√©lulas onde cada c√©lula vai ter uma letra.</p>
<p>Grid (10x10)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  P  A  L  A  V  R  A  S  X  Z       ‚îÇ  ‚Üê Linha 0
‚îÇ  R  U  S  T  O  M  N  Q  W  Y       ‚îÇ  ‚Üê Linha 1
‚îÇ  O  K  L  E  T  R  A  S  D  F       ‚îÇ  ‚Üê Linha 2
‚îÇ  G  H  J  K  L  M  N  O  P  Q       ‚îÇ
‚îÇ  R  S  T  U  V  W  X  Y  Z  A       ‚îÇ
‚îÇ  A  B  C  D  E  F  G  H  I  J       ‚îÇ
‚îÇ  M  N  O  P  Q  R  S  T  U  V       ‚îÇ
‚îÇ  A  W  X  Y  Z  A  B  C  D  E       ‚îÇ
‚îÇ  R  F  G  H  I  J  K  L  M  N       ‚îÇ
‚îÇ  Z  O  P  Q  R  S  T  U  V  W       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</p>
<p>Ai como vamos distribuir nossas palavras dentro dessa matriz?</p>
<h3 id="position">Position</h3>
<p>Vamos precisar de uma <code>struct Position</code> nela vamos conseguir definir a posi√ß√£o que vai ficar a
primeira letra da nossa palavra.</p>
<p><a class="glightbox" href="../images/M4/m4-position.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="" src="../images/M4/m4-position.png" /></a></p>
<h3 id="direction">Direction</h3>
<p>Vamos precisar tamb√©m de uma <code>struct Direction</code> nela vamos definir se a palavra vai seguir na
horizontal, vertical ou diagonal.</p>
<p><a class="glightbox" href="../images/M4/m4-direction.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="" src="../images/M4/m4-direction.png" /></a></p>
<h3 id="wordplacement"><code>Wordplacement</code></h3>
<p>Tamb√©m precisamos de uma <code>struct Wordplacement</code> sua fun√ß√£o vai ser a representa√ß√£o da nossa
palavra, com ele vamos ter a palavra em si, sua posi√ß√£o, sua dire√ß√£o e tamb√©m um marcador pra
indicar se ela foi encontrada ou n√£o.</p>
<p><a class="glightbox" href="../images/M4/m4-wordplacement.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img alt="" src="../images/M4/m4-wordplacement.png" /></a></p>
<p>Agora vamos construir cada estrutura. Primeiro vamos criar nossa <em>Position</em> e ela vai ter um n√∫mero de coluna e linha, vamos cria-lo como um <code>usize</code>. Vamos adicionar as <code>traits</code> <code>Debug</code> e <code>Clone</code>.</p>
<pre><code class="language-rust">//grid.rs
#[derive(Debug, Clone)]
pub struct Position {
    pub row: usize,
    pub col: usize,
}
</code></pre>
<p>A nossa <em>Direction</em> vai ser um <code>enum</code> com o nome das posi√ß√µes. Vamos adicionar nele as <code>traits</code> <code>Debug</code>, <code>Clone</code> e <code>PartialEq</code></p>
<pre><code class="language-rust">//grid.rs

#[derive(Debug, Clone, PartialEq)]
pub enum Direction {
    Horizontal,
    Vertical,
    DiagonalDown,
    DiagonalUp,
}
</code></pre>
<p>O <code>Wordplacement</code> vai agregar como falamos anteriormente a palavra, posi√ß√£o, dire√ß√£o e se ela foi encontrada ou n√£o.</p>
<pre><code class="language-rust">//grid.rs
pub struct WordPlacement {
    pub word: String,
    pub start: Position,
    pub direction: Direction,
    pub found: bool,
}
</code></pre>
<p>Finalmente vamos criar nosso <code>Grid</code> onde ele vai ser uma <code>struct</code> com suas c√©lulas que ser√° um vetor de caracteres, as palavras a serem encontradas que ser√£o um vetor de <code>WordPlacement</code> e seu tamanho que ser√° do tipo <code>usize</code>.</p>
<pre><code class="language-rust">pub struct Grid {
    cells: Vec&lt;Vec&lt;char&gt;&gt;,
    pub size: usize,
    pub words: Vec&lt;WordPlacement&gt;,
}
</code></pre>
<p>Com isso j√° podemos come√ßar a trabalhar com a l√≥gica do nosso jogo.</p>
<h2 id="manipulando-arquivos-em-rust">Manipulando arquivos em Rust</h2>
<p>Para o nosso jogo vamos criar um arquivo de texto simples para armazenar as palavras que
queremos que nosso jogador procure ent√£o agora vamos precisar trabalhar com leitura e escrita de arquivos em rust pra isso vamos trabalhar com a biblioteca <code>fs</code> que j√° vem por padr√£o.</p>
<p>A biblioteca padr√£o <a href="https://doc.rust-lang.org/std/fs/"><code>std::fs</code></a> fornece pra n√≥s as funcionalidades para manipula√ß√£o de arquivos e diret√≥rios do sistema de arquivos.</p>
<p>Para come√ßarmos a trabalhar com a leitura de arquivos vamos no nosso m√≥dulo <code>game</code> e criar uma nova <code>struct</code> que ser√° chamada de <code>GameState</code> onde ela vai controlar os estados do nosso jogo.</p>
<pre><code class="language-rust">//game.rs
use crate::grid::Grid;

pub struct GameState {
    pub grid: Grid,
}
</code></pre>
<p>Agora queremos que nosso <code>GameState</code> com a responsabilidade de ler o arquivo pra isso queremos criar uma fun√ß√£o <code>load_words_from_file</code> nele para que ele leia o conte√∫do do arquivo e transforme pra n√≥s como um vetor de <code>String</code>. Mas, primeiro vamos criar um teste que j√° verifique isso ent√£o vamos criar um novo arquivo de teste e criar duas fun√ß√µes auxiliares uma pra criar um arquivo e outra pra deletar um arquivo.</p>
<pre><code class="language-bash">touch /tests/tests_game.rs
</code></pre>
<pre><code class="language-rust">use std::fs;
use std::io;

// Helper: cria arquivo tempor√°rio para testes
fn create_test_file(filename: &amp;str, content: &amp;str) {
    fs::write(filename, content).expect(&quot;Error to create test file&quot;);
}

// Helper: limpa arquivo de teste
fn cleanup_test_file(filename: &amp;str) {
    fs::remove_file(filename).ok();
}
</code></pre>
<p>Com a fun√ß√£o <a href="https://doc.rust-lang.org/std/fs/fn.write.html"><code>fs::write</code></a> podemos passar o nome do arquivo e um conte√∫do que se o arquivo n√£o existir ele vai cria-lo.</p>
<p>J√° a fun√ß√£o <a href="https://doc.rust-lang.org/std/fs/fn.remove_file.html"><code>fs::remove_file</code></a> podemos passar um nome de arquivo e remove-lo.</p>
<p>Com isso j√° podemos criar nosso primeiro teste para validar um arquivo.</p>
<h2 id="lendo-nosso-arquivo-de-palavras">Lendo nosso arquivo de palavras</h2>
<p>A primeira coisa que vamos fazer √© criar um teste pra verificar pra isso vamos criar um arquivo com as palavras "rust", "python" e "java". E vamos chamar nosso m√©todo <code>load_words_from_file</code> e verificar se o tamanho e as palavras batem.</p>
<p>No final do teste vamos chamar a fun√ß√£o <code>cleanup_test_file</code> e ele vai ser nosso <code>Tear Down</code> que √© basicamente uma fun√ß√£o que limpa nosso teste para que ele n√£o afete os pr√≥ximos testes.</p>
<pre><code class="language-rust">//tests_game.rs
#[test]
fn test_load_words_from_valid_file() {
    // Setup
    let filename = &quot;test_words_valid.txt&quot;;
    create_test_file(filename, &quot;rust\npython\njava\n&quot;);

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert_eq!(words.len(), 3, &quot;Expected 3 words&quot;);
    assert_eq!(words, vec![&quot;rust&quot;, &quot;python&quot;, &quot;java&quot;]);

    // Tear down
    cleanup_test_file(filename);
}
</code></pre>
<p>Vamos adiantar e j√° criar o m√©todo antes de rodar o teste. Vamos fazer ele receber um <code>&amp;str</code> chamado filename e vamos retornar um <code>Result</code> que vai ser um vetor de <code>String</code> e por ser um result vamos por que o retorno com erro vai ser um <code>io::Error</code>.</p>
<pre><code class="language-rust">impl GameState {

    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
    }
}
</code></pre>
<pre><code class="language-bash">error[E0308]: mismatched types
  --&gt; src/game.rs:12:52
   |
12 |     pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
   |            --------------------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result&lt;Vec&lt;String&gt;, Error&gt;`, found `()`
   |            |
   |            implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `Result&lt;Vec&lt;String&gt;, std::io::Error&gt;`
           found unit type `()`
</code></pre>
<p>A falha que deu agora, acontece por que definimos que ele vai retornar um result ent√£o
precisamos pelo menos empacotar um vetor de <code>String</code>, pra isso vamos usar a fun√ß√£o
<a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> para ler nosso arquivo e salva-lo como um vetor.</p>
<pre><code class="language-rust">
impl GameState {

    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
        let content = fs::read_to_string(filename)?;
        let words: Vec&lt;String&gt; = content
            .lines()
            .map(|line| line.to_string())
            .collect();
        Ok(words)
    }
}
</code></pre>
<p>Agora rodando os testes v√£o passar. E agora estamos lendo com sucesso nosso arquivo gerado.</p>
<pre><code class="language-bash">running 1 test
test test_load_words_from_valid_file ... ok
</code></pre>
<p>Vamos fazer algumas modifica√ß√µes eu quero primeiro que nossas palavras sejam todas em caixa alta para isso vamos criar um teste que valide que as palavras s√£o todas em caixa alta.</p>
<pre><code class="language-rust">#[test]
fn test_convert_all_words_to_uppercase() {
    // Setup
    let filename = &quot;test_mixed_case.txt&quot;;
    create_test_file(filename, &quot;rust\nPython\nJaVa\nGO&quot;);

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert!(words.iter().all(|w| w.chars().all(|c| c.is_uppercase())),
        &quot;Should all words is uppercase, found: {:?}&quot;, words);

    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">running 2 tests
test should_convert_all_words_to_uppercase ... FAILED
test test_load_words_from_valid_file ... ok

failures:

---- should_convert_all_words_to_uppercase stdout ----

thread 'should_convert_all_words_to_uppercase' panicked at tests/tests_game.rs:40:5:
Should all words is uppercase, found: [&quot;rust&quot;, &quot;Python&quot;, &quot;JaVa&quot;, &quot;GO&quot;]
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Vamos refatorar nossa fun√ß√£o e ao inv√©s de usar o <code>to_string</code> vamos usar direto o m√©todo <code>to_uppercase</code> para deixar todos os caracteres em caixa alta.</p>
<pre><code class="language-rust">    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
        let content = fs::read_to_string(filename)?;
        let words: Vec&lt;String&gt; = content
            .lines()
            .map(|line| line.to_uppercase())
            .collect();

        Ok(words)
    }
</code></pre>
<pre><code class="language-bash">running 2 tests
test test_convert_all_words_to_uppercase ... ok
test test_load_words_from_valid_file ... FAILED

failures:

---- test_load_words_from_valid_file stdout ----

thread 'test_load_words_from_valid_file' panicked at tests/tests_game.rs:24:5:
assertion `left == right` failed
  left: [&quot;RUST&quot;, &quot;PYTHON&quot;, &quot;JAVA&quot;]
 right: [&quot;rust&quot;, &quot;python&quot;, &quot;java&quot;]
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Agora nosso teste anterior come√ßou a falhar, isso por que o teste era em caixa baixa, ent√£o vamos mudar o teste para tanto o setup quando o assert sejam em caixa alta.</p>
<pre><code class="language-rust">#[test]
fn test_load_words_from_valid_file() {
    // Setup
    let filename = &quot;test_words_valid.txt&quot;;
    create_test_file(filename, &quot;RUST\nPYTHON\nJAVA\n&quot;);

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert_eq!(words.len(), 3, &quot;Expected 3 words&quot;);
    assert_eq!(words, vec![&quot;RUST&quot;, &quot;PYTHON&quot;, &quot;JAVA&quot;]);

    // Tear down
    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">running 2 tests
test test_load_words_from_valid_file ... ok
test test_convert_all_words_to_uppercase ... ok
</code></pre>
<p>Temos que verificar agora se nosso texto quando tiver algumas sujeiras nas palavras como espa√ßo ou tabs eles precisam ser removidos.</p>
<pre><code class="language-rust">#[test]
fn test_trim_whitespace_from_words() {
    // Setup
    let filename = &quot;test_trim.txt&quot;;
    create_test_file(
        filename,
        &quot;  rust  \n\tpython\t\n   java  &quot;
    );

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert_eq!(words, vec![&quot;RUST&quot;, &quot;PYTHON&quot;, &quot;JAVA&quot;]);
    assert!(words.iter().all(|w| !w.starts_with(' ') &amp;&amp; !w.ends_with(' ')),
        &quot;Words should'nt space or tabs&quot;);

    // Tear Down
    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">---- test_trim_whitespace_from_words stdout ----

thread 'test_trim_whitespace_from_words' panicked at tests/tests_game.rs:59:5:
assertion `left == right` failed
  left: [&quot;  RUST  &quot;, &quot;\tPYTHON\t&quot;, &quot;   JAVA  &quot;]
 right: [&quot;RUST&quot;, &quot;PYTHON&quot;, &quot;JAVA&quot;]
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    test_trim_whitespace_from_words
</code></pre>
<p>Agora vamos precisar adicionar o m√©todo <code>trim</code> antes do <code>to_uppercase</code>.</p>
<pre><code class="language-rust">    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
        let content = fs::read_to_string(filename)?;
        let words: Vec&lt;String&gt; = content
            .lines()
            .map(|line| line.trim().to_uppercase())
            .collect();

        Ok(words)
    }
}
</code></pre>
<pre><code class="language-bash">running 3 tests
test test_convert_all_words_to_uppercase ... ok
test test_load_words_from_valid_file ... ok
test test_trim_whitespace_from_words ... ok
</code></pre>
<p>Agora j√° conseguimos garantir que nosso arquivo do jogo vai gerar as palavras da forma que queremos.</p>
<h2 id="analisando-os-casos-excepcionais">Analisando os casos excepcionais</h2>
<p>O que vai acontecer se nosso arquivo com as palavras tiver vazio ou ainda ele n√£o existir?
Normalmente vamos ter um arquivo l√°, mas caso n√£o tenha sabemos como nosso sistema vai se
comportar? Chamamos isso de casos excepcionais ou casos de borda ou ainda <em>edge cases</em> que s√£o comportamentos que s√≥ v√£o acontecer em casos muito particulares.
Vamos tentar fazer um teste para verificar.</p>
<pre><code class="language-rust">#[test]
fn test_return_error_when_file_does_not_exist() {
    // Setup
    let filename = &quot;file_not_found.txt&quot;;

    // Act
    let result = GameState::load_words_from_file(filename);

    // Assert
    assert!(result.is_err(), 
        &quot;Should raise a error if file not exist&quot;);
}
</code></pre>
<pre><code class="language-bash">running 4 tests
test test_return_error_when_file_does_not_exist ... ok
test test_convert_all_words_to_uppercase ... ok
test test_load_words_from_valid_file ... ok
test test_trim_whitespace_from_words ... ok
</code></pre>
<p>Muito bom o teste passou e agora se o arquivo for vazio, ele vai lan√ßar um erro? Vamos
verificar se ele n√£o vai retornar o m√©todo <code>is_empty</code> como verdadeiro.</p>
<pre><code class="language-rust">#[test]
fn test_empty_file_should_raise_error() {
    // Setup
    let filename = &quot;test_empty.txt&quot;;
    create_test_file(
        filename,
        &quot;&quot;
    );

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert!(!words.is_empty(), 
        &quot;Should raise a error if file is empty&quot;);

    // Tear Down
    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">running 5 tests
test test_return_error_when_file_does_not_exist ... ok
test test_empty_file_should_raise_error ... FAILED
test test_convert_all_words_to_uppercase ... ok
test test_load_words_from_valid_file ... ok
test test_trim_whitespace_from_words ... ok

failures:

---- test_empty_file_should_raise_error stdout ----

thread 'test_empty_file_should_raise_error' panicked at tests/tests_game.rs:93:5:
Should raise a error if file is empty
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Aqui o teste trouxe um erro pois n√£o tratamos esse caso ainda de n√£o ter nenhuma palavra, ent√£o agora precisamos trabalhar para gerar um m√≥dulo de erros pro nosso jogo.</p>
<h2 id="iniciando-nosso-modulo-de-erros">Iniciando nosso m√≥dulo de erros</h2>
<p>Pra iniciar vamos criar um novo m√≥dulo <code>error</code> e colocado no nosso <code>lib.rs</code>.</p>
<pre><code class="language-bash">touch src/error.rs
</code></pre>
<pre><code class="language-rust">//lib.rs
pub mod ui;
pub mod game;
pub mod grid;
pub mod error;
</code></pre>
<p>Agora queremos criar um <code>enum</code> com nossos erros, vamos criar um <code>IoError</code> pra usar no nosso result e outro <code>NoWordsProvided</code> para lan√ßar quando o arquivo estiver vazio. Tamb√©m vamos criar um coment√°rio com 3 barras "///" para servir como documenta√ß√£o.</p>
<pre><code class="language-rust">#[derive(Debug)]
pub enum WordSearchError {
    /// Error by I/O (file not found, permissions, etc.)
    IoError(std::io::Error),
    /// Any word found
    NoWordsProvided,
}

</code></pre>
<p>Agora precisamo adicionar um novo <code>impl</code> para indicar para o nosso compilador que nosso <code>WordSearchError</code> faz parte de <code>Error</code>.
 ```
impl std::error::Error for WordSearchError {}</p>
<pre><code>Aqui basicamente dizemos que o tipo `WordSearchError` implementa o `trait std::error::Error`.
Se voc√™ j√° tem um conhecimento de _estrutura de dados_ aqui n√£o √© uma heran√ßa mas sim uma
composi√ß√£o.

Aqui no caso o `for` n√£o √© um `loop` nesse contexto ele quer falar que &quot;Eu sei transformar `std::error::Error` em `WordsearchError`&quot;

Por que o bloco est√° vazio {}?
O trait `std::error::Error` j√° vem com implementa√ß√µes padr√£o (`default impls`) para a maioria dos seus m√©todos. Ent√£o aqui s√≥ precisamos realmente criar a implementa√ß√£o vazia.

Outro ponto importante √© que para cada `struct` ou `enum` que criamos podemos ter quantos `impl` quisermos.

Agora precisamos colocar mais um `impl` para que nosso `WordsearchError` fa√ßa o tratamento do `ioError` internamente. Toda vez que ele receber o `ioError` ele vai trata-lo e devolver um erro customizado do tipo `WordsearchError` para isso precisamos implementar a [`trait From`](https://doc.rust-lang.org/std/convert/trait.From.html).

Ao implementar a trait `From`, definimos o m√©todo `from`, que recebe como par√¢metro o tipo de origem (no caso, `std::io::Error`) e ele retorna `Self`, ou seja, o tipo que est√° recebendo a implementa√ß√£o o `WordSearchError`.
Dentro do m√©todo, criamos e retornamos a variante correspondente do nosso tipo de erro `WordSearchError::IoError(error)`.

```rust
//error.rs

impl From&lt;std::io::Error&gt; for WordSearchError {
    fn from(error: std::io::Error) -&gt; Self {
        WordSearchError::IoError(error)
    }
}
</code></pre>
<p>Com isso podemos apenas trabalhar como nosso erro customizado no nosso c√≥digo. </p>
<h2 id="customizando-nossas-mensagens-de-erro">Customizando nossas mensagens de erro</h2>
<p>Agora vamos implementar a trait Display para trazer uma melhor visualiza√ß√£o pro nosso erro. Nela precisamos criar uma fun√ß√£o <code>fmt</code> para que possamos criar uma mensagem customizada da forma que queremos.
Nesse caso tamb√©m vamos usar um <code>impl</code> s√≥ que para <code>fmt::Display</code> que √© a nossa trait e vamos fazer um match para verificar qual variante do nosso <code>enum</code> est√° sendo usada e formatar a mensagem de erro apropriada.
Tamb√©m nesse caso vamos usar a macro <code>write!</code> ao inv√©s do <code>println!</code> pois o <code>println!</code> sempre imprime diretamente no console (<code>stdout</code>), mas no nosso caso a <code>trait Display</code> est√° preparando a representa√ß√£o textual do erro para ser usada em diferentes contextos. O <code>write!</code> √© mais flex√≠vel porque ele escreve no <code>formatter</code> (<code>buffer</code>) que foi passado como par√¢metro, permitindo que essa representa√ß√£o seja usada com outras macros como <code>format!</code>, <code>println!</code>, salvamento em arquivos, etc.
N√≥s teremos ent√£o na fun√ß√£o <code>fmt</code> os par√¢metros <code>&amp;self</code> pois vamos usar o pr√≥prio contexto do <code>enum</code> e tamb√©m como disse
anteriormente o <code>formatter</code> que vai ser do tipo <code>fmt::Formatter&lt;'_&gt;</code> e vamos retornar um <code>fmt::Result</code>.</p>
<pre><code class="language-rust">impl fmt::Display for WordSearchError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            WordSearchError::IoError(e) =&gt; write!(f, &quot;IO Error: {}&quot;, e),
            WordSearchError::NoWordsProvided =&gt; write!(f, &quot;No words provided&quot;),
        }
    }
}
</code></pre>
<p>Novamente tivemos que recorrer a um <code>lifetime</code> no caso em <code>fmt::Formatter&lt;'_&gt;</code> porque o <code>Formatter</code> mant√©m uma refer√™ncia ao buffer onde o texto ser√° escrito, e essa refer√™ncia precisa ter um tempo de vida v√°lido. O <code>'_</code> indica que estamos deixando o Rust inferir automaticamente qual √© o lifetime correto.</p>
<p>Pense assim: quando voc√™ formata o erro de um jogo, √© como preparar uma mensagem em um quadro-negro antes de mostr√°-la ao jogador. O <code>Formatter</code> √© como uma seta apontando para esse quadro-negro, e o lifetime garante que o quadro n√£o seja apagado enquanto voc√™ ainda est√° escrevendo nele. O <code>'_</code> diz ao Rust: "voc√™ sabe quanto tempo isso precisa durar, n√£o preciso especificar".</p>
<p>Voltando ao <code>game.rs</code> vamos implementar uma condi√ß√£o parecida com o nosso <em>assert</em>  vamos verificar se <em>words</em> √© vazio e se
sim vamos lan√ßar o erro do tipo <code>NoWordsProvided</code> nele.</p>
<pre><code class="language-rust">    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, io::Error&gt; {
        let content = fs::read_to_string(filename)?;
        let words: Vec&lt;String&gt; = content
            .lines()
            .map(|line| line.trim().to_uppercase())
            .collect();

        if words.is_empty() {
            return Err(WordSearchError::NoWordsProvided);
        }

        Ok(words)
    }
</code></pre>
<p>Vamos mudar o tipo de erro da sa√≠da do nosso <code>Result</code> da fun√ß√£o pra <code>WordSearchError</code> tamb√©m.</p>
<pre><code class="language-rust">    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, WordSearchError&gt; {
</code></pre>
<p>Nos testes precisamos agora parar de desempacotar nossa string e ver se h√° um erro usando o m√©todo <code>is_err</code>.</p>
<pre><code class="language-rust">#[test]
fn test_empty_file_should_raise_error() {
    // Setup
    let filename = &quot;test_empty.txt&quot;;
    create_test_file(
        filename,
        &quot;&quot;
    );

    // Act
    let words = GameState::load_words_from_file(filename);

    // Assert
    assert!(words.is_err(), &quot;Should raise an error if file is empty&quot;);

    // Tear Down
    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/tests_game.rs (target/debug/deps/tests_game-48a4cab4eebeef08)

running 5 tests
test test_return_error_when_file_does_not_exist ... ok
test test_empty_file_should_raise_error ... ok
test test_trim_whitespace_from_words ... ok
test test_convert_all_words_to_uppercase ... ok
test test_load_words_from_valid_file ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/tests_ui.rs (target/debug/deps/tests_ui-16d9dc32c61ca57b)
</code></pre>
<p>Agora j√° temos um m√≥dulo de erros funcional vamos fazer um √∫ltimo teste pra verificar se estamos lidando bem com apenas uma palavra.</p>
<pre><code class="language-rust">#[test]
fn should_work_with_single_word() {
    // Setup
    let filename = &quot;test_single.txt&quot;;
    create_test_file(filename, &quot;rust&quot;);

    // Act
    let words = GameState::load_words_from_file(filename).unwrap();

    // Assert
    assert_eq!(words.len(), 1);
    assert_eq!(words[0], &quot;RUST&quot;);

    // Tear Down
    cleanup_test_file(filename);
}
</code></pre>
<pre><code class="language-bash">running 6 tests
test test_return_error_when_file_does_not_exist ... ok
test test_empty_file_should_raise_error ... ok
test test_load_words_from_valid_file ... ok
test test_convert_all_words_to_uppercase ... ok
test should_work_with_single_word ... ok
test test_trim_whitespace_from_words ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Agora temos algumas boas garantias que nosso sistema de arquivos vai funcionar.</p>
<h2 id="criando-um-alias-pra-um-tipo">Criando um alias pra um tipo</h2>
<p>Agora eu quero fazer uma mudan√ßa ao inv√©s de deixar o retorno do nosso m√©todo <code>load_words_from_file</code> como <code>Result&lt;Vec&lt;String&gt;, WordSearchError&gt;</code> quero deixa-lo apenas como <code>Result&lt;(T)&gt;</code> pra isso podemos criar um <a href="https://doc.rust-lang.org/reference/types.html"><code>type</code></a> que √© um <em>alias</em> ou um atalho ou ainda representar algo extenso com algo menor.</p>
<p>Ent√£o vamos criar esse <code>type</code> no final do nosso m√≥dulo.</p>
<pre><code class="language-rust">// error.rs
pub type Result&lt;T&gt; = std::result::Result&lt;T, WordSearchError&gt;;
</code></pre>
<p>Com isso a agora podemos alterar o retorno da nossa fun√ß√£o, e aqui estamos criando um alias pro Result da biblioteca  <code>std</code> com o nosso tipo de erro j√° declarado e chamando de result, por conta disso no nosso game vamos precisar importar explicitamente o result sendo ele o que est√° na nossa biblioteca error.</p>
<p>Al√©m disso como retornamos uma <code>Vec&lt;String&gt;</code> nosso alias precisa ainda receber o tipo <code>T</code> do retorno.</p>
<pre><code class="language-rust">use std::fs;

use crate::{error::{Result, WordSearchError}, grid::Grid};


pub struct GameState {
    pub grid: Grid,

}
impl GameState {

    pub fn load_words_from_file(filename: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
        let content = fs::read_to_string(filename)?;
        let words: Vec&lt;String&gt; = content
            .lines()
            .map(|line| line.trim().to_uppercase())
            .collect();

        if words.is_empty() {
            return Err(WordSearchError::NoWordsProvided);
        }

        Ok(words)
    }
}
</code></pre>
<pre><code class="language-bash">-&gt; cargo test
running 6 tests
test test_return_error_when_file_does_not_exist ... ok
test test_convert_all_words_to_uppercase ... ok
test test_empty_file_should_raise_error ... ok
test should_work_with_single_word ... ok
test test_load_words_from_valid_file ... ok
test test_trim_whitespace_from_words ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Com isso podemos centralizar todos os erros em <code>WordSearchError</code> e s√≥ passar o tipo do nosso retorno, isso que chamamos de "a√ßucar sint√°tico".</p>
<h2 id="lifetimes">Lifetimes</h2>
<p><strong>Lifetimes</strong> s√£o anota√ß√µes que dizem ao compilador por quanto tempo uma refer√™ncia √© v√°lida. Em C/C++, usar refer√™ncias para dados j√° desalocados causa bugs terr√≠veis. Em Rust, o compilador simplesmente n√£o permite.</p>
<p><strong>Pense assim:</strong> Lifetimes s√£o como etiquetas de validade em alimentos. O compilador verifica se voc√™ n√£o est√° usando algo "vencido". A maioria das vezes o compilador infere automaticamente, mas √†s vezes precisamos ajud√°-lo com anota√ß√µes expl√≠citas.</p>
<p>Normalmente precisamos anotar o lifetime quando em casos espec√≠ficos e sempre anotar os par√¢metros que recebemos emprestados <code>&amp;</code> pois ele mantem-se marcando o tempo de vida dos par√¢metros.</p>
<p>O c√≥digo abaixo vai dar erro porque o compilador n√£o sabe qual lifetime o retorno deve ter quando a fun√ß√£o recebe m√∫ltiplas refer√™ncias.</p>
<pre><code class="language-rust">fn escolher_arma(arma1: &amp;str, arma2: &amp;str, usar_primeira: bool) -&gt; &amp;str {
    if usar_primeira { arma1 } else { arma2 }
}
let rifle = String::from(&quot;Rifle de Plasma&quot;);
let espada = String::from(&quot;Espada Laser&quot;);
let arma = escolher_arma(&amp;rifle, &amp;espada, true); // Erro
println!(&quot;Arma: {}&quot;, arma);
</code></pre>
<p>O erro ocorre por que arma depende da vari√°vel rifle ou espada, mas o compilador n√£o sabe como retornar.
- Posso retornar arma1... mas qual √© o lifetime dela?
- Posso retornar arma2... mas qual √© o lifetime dela?
- S√£o diferentes? S√£o iguais?
- N√ÉO SEI! ERRO!</p>
<p>Isso acontece porque <code>arma1</code> e <code>arma2</code> podem ter lifetimes diferentes. O compilador n√£o consegue garantir qual ser√° retornado (arma1 ou arma2?) sem que voc√™ especifique explicitamente que ambos devem ter o mesmo lifetime.</p>
<p>Podemos resolver usando uma anota√ß√£o <code>&lt;'a&gt;</code>, assim dizemos que eles duram o tempo <code>a</code>.</p>
<pre><code class="language-rust">fn escolher_arma&lt;'a&gt;(arma1: &amp;'a str, arma2: &amp;'a str, usar_primeira: bool) -&gt; &amp;'a str {
    if usar_primeira { arma1 } else { arma2 }
}

let rifle = String::from(&quot;Rifle de Plasma&quot;);
let espada = String::from(&quot;Espada Laser&quot;);
let arma = escolher_arma(&amp;rifle, &amp;espada, true);
println!(&quot;Arma: {}&quot;, arma); // &quot;Rifle de Plasma&quot;
</code></pre>
<p><strong>O que <code>&lt;'a&gt;</code> significa?</strong>
- <code>'a</code> √© um nome de lifetime (pode ser <code>'b</code>, <code>'vida</code>, qualquer nome), todas essas refer√™ncias vivem <strong>pelo menos</strong> durante o tempo <code>'a</code> e tamb√©m vive durante <code>'a</code></p>
<p>Podemos tamb√©m usar dois lifetimes independentes e combinar esses dados.</p>
<pre><code class="language-rust">fn combinar_dados&lt;'a, 'b&gt;(
    piloto: &amp;'a str,
    missao: &amp;'b str,
) -&gt; (&amp;'a str, &amp;'b str) {
    (piloto, missao)
}

let piloto = String::from(&quot;Elena&quot;);
let resultado = {
    let missao = String::from(&quot;Reconhecimento&quot;);
    combinar_dados(&amp;piloto, &amp;missao)
}; // ‚ùå ERRO
</code></pre>
<p><strong>Por qu√™?</strong> <code>'a</code> e <code>'b</code> s√£o independentes. Se <code>missao</code> vive menos, n√£o podemos usar <code>resultado.1</code> depois. Ent√£o se mantermos
as vari√°veis no mesmo contexto ele √© funcional.</p>
<pre><code class="language-rust">fn combinar_dados&lt;'a, 'b&gt;(
    piloto: &amp;'a str,
    missao: &amp;'b str,
) -&gt; (&amp;'a str, &amp;'b str) {
    (piloto, missao)
}

let piloto = String::from(&quot;Elena&quot;);
let missao = String::from(&quot;Reconhecimento&quot;);
let resultado = combinar_dados(&amp;piloto, &amp;missao);
</code></pre>
<p>Se sua fun√ß√£o pode retornar o valor de um par√¢metro ou outro podemos anotar o mesmo lifetime pra v√°rios par√¢metros.</p>
<pre><code class="language-rust">fn maior_nome&lt;'a&gt;(nome1: &amp;'a str, nome2: &amp;'a str) -&gt; &amp;'a str {
    if nome1.len() &gt; nome2.len() { nome1 } else { nome2 }
}

let n1 = String::from(&quot;Gundam&quot;);
let n2 = String::from(&quot;Valkyrie&quot;);
println!(&quot;Maior: {}&quot;, maior_nome(&amp;n1, &amp;n2)); // &quot;Valkyrie&quot;
</code></pre>
<p>Agora tivemos casos que recebemos algum par√¢metro mas, vamos devolver um <code>static</code>, pra isso podemos usar o lifetime <code>static</code>.</p>
<pre><code class="language-rust">fn obter_status(codigo: u32) -&gt; &amp;'static str {
    match codigo {
        200 =&gt; &quot;Sistema Operacional&quot;,
        404 =&gt; &quot;Sensor N√£o Encontrado&quot;,
        500 =&gt; &quot;Erro Cr√≠tico&quot;,
        _ =&gt; &quot;Status Desconhecido&quot;,
    }
}

let status = obter_status(404);
println!(&quot;{}&quot;, status); // &quot;Sensor N√£o Encontrado&quot;
</code></pre>
<p>String literals s√£o <code>'static</code>, n√£o dependem do par√¢metro <code>codigo</code>. Ou seja esse lifetime est√° indicando que vamos retornar um
<code>static</code> e n√£o alguma transforma√ß√£o do par√¢metro.</p>
<p>Podemos tamb√©m usar lifetimes para <code>Struct</code> e m√©todos, no caso de m√©todos o retorno vive enquanto <code>self</code> for v√°lido.</p>
<pre><code class="language-rust">struct Mecha&lt;'a&gt; {
    nome: &amp;'a str,
    energia: u32,
}

impl&lt;'a&gt; Mecha&lt;'a&gt; {
    fn nome(&amp;self) -&gt; &amp;str {
        self.nome
    }

    fn energia(&amp;self) -&gt; u32 {
        self.energia
    }
}
let nome = String::from(&quot;Valkyrie&quot;);
let mecha = Mecha { nome: &amp;nome, energia: 100 };
println!(&quot;{} - {}%&quot;, mecha.nome(), mecha.energia());
</code></pre>
<h2 id="construindo-o-grid">Construindo o grid</h2>
<p>Precisamos criar um m√©todo tamb√©m que vai gerar nosso grid recebendo um tamanho e a mesma string de palavras.</p>
<pre><code class="language-rust">impl Grid {
    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
    }
}
</code></pre>
<p>Vamos criar agora uma inicializa√ß√£o onde vamos preencher nossa <code>struct Grid</code> e retorna-la.</p>
<pre><code class="language-rust">    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        let mut grid = Grid {
            cells: vec![vec![' '; size]; size],
            size,
            words: Vec::new(),
        };
        Ok(grid)
    }

</code></pre>
<p>Vamos preencher inicialmente o grid com as palavras do nosso arquivo, para isso precisamos de uma fun√ß√£o que coloque as palavras que v√£o vir do nosso arquivo no grid ent√£o, na nossa <code>struct Grid</code> vamos criar um m√©todo chamado <code>place_words</code> que vai receber a pr√≥pria <code>struct</code> e um vetor de <code>String</code> e como retorno vamos retornar apenas um Result ent√£o no final da nossa fun√ß√£o vamos retornar um <code>Ok(())</code>.</p>
<pre><code class="language-rust">    fn place_words(&amp;mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;()&gt; {
        Ok(())
    }

</code></pre>
<p>Precisamos inicialmente agora criar um novo arquivo de teste para testar nosso grid e depois criar um teste para validar que <code>Grid</code> retorna <em>OK</em> se for adicionado par√¢metros v√°lidos.</p>
<pre><code class="language-bash">touch tests/tests_grid.rs
</code></pre>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_valid_parameters() {
    // Setup
    let words = vec![
        &quot;RUST&quot;.to_string(),
        &quot;CODE&quot;.to_string(),
        &quot;TEST&quot;.to_string(),
    ];
    let size = 10;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_ok(), &quot;Grid creation should succeed with valid parameters&quot;);
}
</code></pre>
<pre><code class="language-bash">running 1 test
test test_grid_new_with_valid_parameters ... ok
</code></pre>
<p>Agora vamos criar um teste para validar se adicionarmos um size de valor 0 lan√ßar√° um erro. Para isso vamos criar um erro do
tipo <code>InvalidGridSize</code> ele vai ser respons√°vel por tratar o erro quando nosso <code>grid</code> for menor que 0, vamos fazer que ele
receba um par√¢metro.</p>
<pre><code class="language-rust">//error.rs
use std::fmt;

#[derive(Debug)]
pub enum WordSearchError {
    /// Error by I/O (file not found, permissions, etc.)
    IoError(std::io::Error),
    /// Any word found
    NoWordsProvided,
    /// Grid size not valid
    InvalidGridSize(usize),
}

impl fmt::Display for WordSearchError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            WordSearchError::IoError(e) =&gt; write!(f, &quot;IO Error: {}&quot;, e),
            WordSearchError::NoWordsProvided =&gt; write!(f, &quot;No words provided&quot;),
            WordSearchError::InvalidGridSize(size) =&gt; {
                write!(f, &quot;Invalid grid size: {}. Size must be greater than 2&quot;, size)
        }
    }
}
</code></pre>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_zero_size() {
    // Setup
    let words = vec![&quot;RUST&quot;.to_string()];
    let size = 0;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_err(), &quot;Grid creation should fail with size 0&quot;);
    if let Err(e) = result {
        match e {
            Error::InvalidGridSize(s) =&gt; assert_eq!(s, 0),
            _ =&gt; panic!(&quot;Expected InvalidGridSize error&quot;),
        }
    }
}
</code></pre>
<p>Agora como vamos validar o nosso construtor? Poder√≠amos colocar apenas uma verifica√ß√£o do nosso <code>new</code> mas, poder√≠amos usar um
<code>design partner</code> nesse caso que √© o padr√£o <code>build</code>.</p>
<p>O que √© o Builder Pattern?
O Builder Pattern √© um padr√£o de projeto criacional que permite construir objetos complexos passo a passo. Ele √© especialmente √∫til quando:</p>
<ul>
<li>Um objeto tem muitos par√¢metros opcionais</li>
<li>A valida√ß√£o precisa ser feita durante a constru√ß√£o</li>
<li>Voc√™ quer tornar a cria√ß√£o de objetos mais leg√≠vel</li>
</ul>
<p>Assim como quando estamos trabalhando com o arquivo que damos um <code>lines()</code>, <code>map()</code> e <code>collect()</code>, vamos criar nossos m√©todos
para encadear durante a constru√ß√£o do nosso grid. Mas, pra isso vamos precisar criar um <code>GridBuilder</code> e a fun√ß√£o dele vai ser
especificamente trabalhar com a valida√ß√£o de <code>size</code> e <code>words</code> e a parte das c√©lulas vai ficar respons√°vel no nosso grid j√°
criado.</p>
<p>Se fosse um projeto real eu acredito que a melhor abordagem seria criar um m√©todo que valide o size √© mais simples, por√©m
aqui vamos complicar um pouquinho apenas pra voc√™ ter uma vis√£o das possibilidades na hora de construir um objeto.</p>
<p>Nessa constru√ß√£o vamos criar uma <code>struct GridBuilder</code> nela vamos ter <code>size</code> e <code>words</code> seu principal objetivo vai ser validar
esses dois atributos e construir o <code>grid</code>. Ent√£o primeiros vamos criar a  <code>struct</code> e validar se size for menor ou igual a 0
vamos lan√ßar um erro <code>InvalidGridSize</code>.</p>
<pre><code class="language-rust">pub struct GridBuilder {
    size: Option&lt;usize&gt;,
    words: Option&lt;Vec&lt;String&gt;&gt;,
}

impl GridBuilder {
    pub fn new() -&gt; Self {
        Self {
            size: None,
            words: None,
        }
    }

    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {
        if size == 0 {
            return Err(WordSearchError::InvalidGridSize(size));
        }
        self.size = Some(size);
        Ok(self)
    }
</code></pre>
<p>Como estamos criando um builder vamos criar um m√©todo chamado <code>build</code> ele vai criar o grid.</p>
<pre><code class="language-rust">pub struct GridBuilder {
    size: Option&lt;usize&gt;,
    words: Option&lt;Vec&lt;String&gt;&gt;,
}

impl GridBuilder {
    pub fn new() -&gt; Self {
        Self {
            size: None,
            words: None,
        }
    }

    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {
        if size == 0 {
            return Err(WordSearchError::InvalidGridSize(size));
        }
        self.size = Some(size);
        Ok(self)
    }

    pub fn build(self) -&gt; Grid {
        let size = self.size.expect(&quot;Size must be set&quot;);

        Grid {
            size,
            cells: vec![vec![' '; size]; size],
            words: vec![],
        }
    }
}
</code></pre>
<p>Agora podemos construir ele no nosso <code>struct Grid</code> e podemos encadear nosso m√©todo <code>new</code> com a valida√ß√£o de <code>with_size</code> e
usar o operador "?" para propagar o erro depois s√≥ devolvemos o <code>grid</code> do nosso construtor.</p>
<pre><code class="language-rust">impl Grid {
    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        let grid = GridBuilder::new()
            .with_size(size)?
            .build();
        Ok(grid)
    }

}
</code></pre>
<pre><code class="language-bash">running
2 tests
test test_grid_new_with_zero_size ... ok
test test_grid_new_with_valid_parameters ... ok
</code></pre>
<h2 id="validando-nosso-vetor-de-palavras">Validando nosso vetor de palavras</h2>
<p>Primeiro vamos ajustar nosso m√©todo new em <code>grid.rs</code> para receber <code>WordPlacement</code> ao inv√©s de uma string. E vamos aplicar a
<code>trait Debug</code> tanto em <code>Grid</code> quanto em <code>WordPlacement</code></p>
<pre><code class="language-rust">#[derive(Debug)]
pub struct WordPlacement {
    pub word: String,
    pub start: Position,
    pub direction: Direction,
    pub found: bool,
}

#[derive(Debug)]
pub struct Grid {
    cells: Vec&lt;Vec&lt;char&gt;&gt;,
    pub size: usize,
    pub words: Vec&lt;WordPlacement&gt;,
}

impl Grid {
    pub fn new(size: usize, words: Vec&lt;WordPlacement&gt;) -&gt; Result&lt;Self&gt; {
        let grid = GridBuilder::new()
            .with_size(size)?
            .build();
        Ok(grid)
    }

}

</code></pre>
<p>Agora precisamos validar as palavras do nosso jogo, pra isso vamos criar um teste que quando for tentado construir o grid sem
palavras ele de um erro do tipo <code>NoWordsProvided</code> e no nosso grid vamos receber o par√¢metro de palavras.</p>
<pre><code class="language-rust">// tests_grid.rs
#[test]
fn test_grid_new_with_empty_words() {
    let words = Vec::new();
    let size = 10;

    let result = Grid::new(size, words);

    assert!(result.is_err(), &quot;Grid creation should fail with empty word list&quot;);
    if let Err(e) = result {
        match e {
            Error::EmptyWordList =&gt; {},
            _ =&gt; panic!(&quot;Expected EmptyWordList error&quot;),
        }
    }
}
</code></pre>
<pre><code class="language-rust">//grid.rs
pub struct Grid {
    cells: Vec&lt;Vec&lt;char&gt;&gt;,
    pub size: usize,
    pub words: Vec&lt;WordPlacement&gt;,
}

impl Grid {
    pub fn new(size: usize, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        let grid = GridBuilder::new()
            .with_size(size)?
            .with_words(words)?
            .build();
        Ok(grid)
    }

}

pub struct GridBuilder {
    size: Option&lt;usize&gt;,
    words: Option&lt;Vec&lt;String&gt;&gt;,
}

impl GridBuilder {
    pub fn new() -&gt; Self {
        Self {
            size: None,
            words: None,
        }
    }

    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {
        if size == 0 {
            return Err(WordSearchError::InvalidGridSize(size));
        }
        self.size = Some(size);
        Ok(self)
    }

    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        self.words = Some(words);
        Ok(self)
    }

    pub fn build(self) -&gt; Grid {
        let size = self.size.expect(&quot;Size must be set&quot;);

        Grid {
            size,
            cells: vec![vec![' '; size]; size],
            words: vec![],
        }
    }
}
</code></pre>
<pre><code class="language-bash">running 3 tests
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_zero_size ... ok
test test_grid_new_with_empty_words ... FAILED

failures:

---- test_grid_new_with_empty_words stdout ----

thread 'test_grid_new_with_empty_words' panicked at tests/test_grid.rs:44:5:
Grid creation should fail with empty word list
</code></pre>
<p>O que precisamos fazer agora √© criar uma valida√ß√£o se o <code>words</code> for um vetor vazio ele deve lan√ßar um erro. Por isso vamos
modificar nosso <code>with_words</code> para fazer essa valida√ß√£o.</p>
<pre><code class="language-rust">    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        if words.is_empty() {
            return Err(WordSearchError::NoWordsProvided);
        }
        self.words = Some(words);
        Ok(self)
    }
</code></pre>
<pre><code class="language-bash">running 3 tests
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_zero_size ... ok
test test_grid_new_with_valid_parameters ... ok

</code></pre>
<p>Agora o que acontece se criarmos um grid 5x5 e temos uma palavra como "Pneumoultramicroscopicossilicovulcanoconiose" acredito
que temos um problema n√£o?
Ent√£o vamos criar um teste para verificar se a palavra √© maior que o tamanho do nosso grid. Se a palavra for maior precisamos
lan√ßar um erro do tipo <code>WordTooLong</code> ent√£o vamos cria-lo.</p>
<pre><code class="language-rust"> use std::fmt;

#[derive(Debug)]
pub enum WordSearchError {
    /// Error by I/O (file not found, permissions, etc.)
    IoError(std::io::Error),
    /// Any word found
    NoWordsProvided,
    /// Grid size not valid
    InvalidGridSize(usize),
    /// Word is too long for the grid
    WordTooLong { word: String, size: usize },
}

impl fmt::Display for WordSearchError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            WordSearchError::IoError(e) =&gt; write!(f, &quot;IO Error: {}&quot;, e),
            WordSearchError::NoWordsProvided =&gt; write!(f, &quot;No words provided&quot;),
            WordSearchError::InvalidGridSize(size) =&gt; {
                write!(f, &quot;Invalid grid size: {}. Size must be greater than 0&quot;, size)
            }
            WordSearchError::WordTooLong { word, size } =&gt; {
                write!(f, &quot;Word '{}' with length {} is too long for grid size {}&quot;, 
                    word, word.len(), size)
            }
        }
    }
}
</code></pre>
<p>Com isso podemos criar um teste:</p>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_word_too_large() {
    // Setup
    let words = vec![&quot;VERYLONGWORDTHATDOESNOTFIT&quot;.to_string()];
    let size = 5;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_err(), &quot;Grid creation should fail when word is larger than grid&quot;);

    match result {
        Err(WordSearchError::WordTooLarge { word, size: grid_size }) =&gt; {
            assert_eq!(word, &quot;VERYLONGWORDTHATDOESNOTFIT&quot;);
            assert_eq!(grid_size, 5);
        }
        _ =&gt; panic!(&quot;Expected WordTooLong error&quot;),
    }
}
</code></pre>
<pre><code class="language-bash">running 4 tests
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_word_too_large ... FAILED
test test_grid_new_with_zero_size ... ok

failures:

---- test_grid_new_with_word_too_large stdout ----

thread 'test_grid_new_with_word_too_large' panicked at tests/test_grid.rs:64:5:
Grid creation should fail when word is larger than grid
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Precisamos agora criar um validador para nosso teste ent√£o aqui vamos precisar verificar o size e pra isso vamos criar uma vari√°vel condicional chamada let Some(current_size) e receber self.size o valor interno de self.size SE ele for Some.
Quando fazemos isso abrimos um bloco de c√≥digo {}  l√° podemos criar nosso c√≥digo condicional no caso ele vai percorrer words e verificar se alguma √© maior que current_size se isso for verdadeiro ele lan√ßa um erro, se n√£o <code>current_size</code> vai receber <code>self.size</code>.
Poderiamos aqui tanto fazer um <code>match</code> com <code>self.size</code> e verificar se a <code>option</code> tem algum Some ou vazia ou mesmo
desempacotar com um <code>unwrap</code> mas, a vantagem do if let √© ser seguro (n√£o causa panic), conciso (uma linha), e idiom√°tico. Al√©m disso, ele extrai o valor automaticamente, sem precisar desempacotar manualmente.</p>
<p>Por√©m tudo vai depender do que voc√™ acha melhor em cada situa√ß√£o, mas hoje vamos fazer assim.</p>
<pre><code class="language-rust">        if let Some(size) = self.size {
            for word in &amp;words {
                if word.len() &gt; size {
                    return Err(WordSearchError::WordTooLong {
                        word: word.clone(),
                        size,
                    });
                }
            }
        }
</code></pre>
<pre><code class="language-bash">running 4 tests
test test_grid_new_with_word_too_large ... ok
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_zero_size ... ok
test test_grid_new_with_valid_parameters ... ok
</code></pre>
<p>Vamos fazer um teste agora apenas pra validar se a palavra tem o mesmo tamanho do grid ela tem que aceitar.</p>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_exact_word_size() {
    // Setup
    let words = vec![&quot;EXACT&quot;.to_string()];
    let size = 5;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_ok(), &quot;Grid creation should succeed when word length equals grid size&quot;);
}
</code></pre>
<pre><code class="language-bash">running 5 tests
test test_grid_new_with_exact_word_size ... ok
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_word_too_large ... ok
test test_grid_new_with_zero_size ... ok

</code></pre>
<p>Agora uma ultima valida√ß√£o precisamos ver que uma palavra tenha pelo menos dois caracteres, sen√£o n√£o √© uma palavra n√£o?
Ent√£o vamos criar um error <code>WordInvalid</code> para lan√ßar quando o tamanho for menor que 2.</p>
<pre><code class="language-rust">use std::fmt;

#[derive(Debug)]
pub enum WordSearchError {
    /// Error by I/O (file not found, permissions, etc.)
    IoError(std::io::Error),
    /// Any word found
    NoWordsProvided,
    /// Grid size not valid
    InvalidGridSize(usize),
    /// Word is too long for the grid
    WordTooLong { word: String, size: usize },
    /// Word should the minimal 2 characters
    WordInvalid { word: String },
}

impl fmt::Display for WordSearchError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            WordSearchError::IoError(e) =&gt; write!(f, &quot;IO Error: {}&quot;, e),
            WordSearchError::NoWordsProvided =&gt; write!(f, &quot;No words provided&quot;),
            WordSearchError::InvalidGridSize(size) =&gt; {
                write!(f, &quot;Invalid grid size: {}. Size must be greater than 0&quot;, size)
            }
            WordSearchError::WordTooLong { word, size } =&gt; {
                write!(f, &quot;Word '{}' with length {} is too long for grid size {}&quot;, 
                    word, word.len(), size)
            }
            WordSearchError::WordInvalid { word } =&gt; {
                write!(f, &quot;Word '{}' with length {} is too short you need the minimum 2 characters&quot;, 
                    word, word.len())
            }
        }
    }
}
</code></pre>
<p>Agora criamos o teste:</p>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_word_only_caracter_should_a_error() {
    // Setup
    let words = vec![&quot;A&quot;.to_string()];
    let size = 2;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_err(), &quot;Grid creation should fail when word is only one character&quot;);

    match result {
        Err(WordSearchError::WordInvalid { word }) =&gt; {
            assert_eq!(word, &quot;A&quot;);
        }
        _ =&gt; panic!(&quot;Expected WordInvalid error&quot;),
    }
}
</code></pre>
<pre><code class="language-bash">running 6 tests
test test_grid_new_with_word_too_large ... ok
test test_grid_new_with_word_only_caracter ... FAILED
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_exact_word_size ... ok
test test_grid_new_with_zero_size ... ok

failures:

---- test_grid_new_with_word_only_caracter stdout ----

thread 'test_grid_new_with_word_only_caracter' panicked at tests/test_grid.rs:99:5:
Grid creation should fail when word is only one character
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Vamos colocar por seguran√ßa tamb√©m um validador no build se words existe.</p>
<pre><code class="language-rust">    pub fn build(self) -&gt; Grid {
        let size = self.size.expect(&quot;Size must be set&quot;);
        let words = self.words.expect(&quot;Words must be set&quot;);

        Grid {
            size,
            cells: vec![vec![' '; size]; size],
            words: vec![],
        }

</code></pre>
<p>Ajustando agora vamos fazer simplesmente outro <code>if</code> pra validar isso.</p>
<pre><code class="language-rust">    fn with_words(mut self, words: Vec&lt;String&gt;) -&gt; Result&lt;Self&gt; {
        if words.is_empty() {
            return Err(WordSearchError::NoWordsProvided);
        }
        if let Some(size) = self.size {
            for word in &amp;words {
                if word.len() &gt; size {
                    return Err(WordSearchError::WordTooLong {
                        word: word.clone(),
                        size,
                    });
                }
                if word.len() &lt; 2 {
                    return Err(WordSearchError::WordInvalid { word: word.clone() })
                }
            }
        }
        self.words = Some(words);
        Ok(self)
    }

</code></pre>
<pre><code class="language-bash">running 6 tests
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_exact_word_size ... ok
test test_grid_new_with_word_only_caracter_shoudl_a_error ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_zero_size ... ok
test test_grid_new_with_word_too_large ... ok
</code></pre>
<p>Certo tudo funcionando.</p>
<h2 id="validando-o-tamanho-do-jogo">Validando o tamanho do jogo</h2>
<p>Bom agora precisamos validar se o size do nosso jogo √© maior ou igual a 2, menos que 2 c√©lulas o jogo n√£o existe
praticamente. Ent√£o vamos refatorar nosso teste pra validar um grid de tamanho 1 ainda vai dar erro.
Vamos renomear o teste <code>test_grid_new_with_zero_size</code> para  <code>test_grid_new_with_one_size</code> e mudar o tamanho de 0 para 1.</p>
<pre><code class="language-rust">#[test]
fn test_grid_new_with_one_size() {
    // Setup
    let words = vec![&quot;HI&quot;.to_string()];
    let size = 1;

    // Act
    let result = Grid::new(size, words);

    // Assert
    assert!(result.is_err(), &quot;Grid creation should fail with size 1&quot;);

    match result {
        Err(WordSearchError::InvalidGridSize(s)) =&gt; {
            assert_eq!(s, 1, &quot;Error should contain the invalid size value&quot;);
        }
        _ =&gt; panic!(&quot;Expected InvalidGridSize error with value 1&quot;),
    }
}
</code></pre>
<pre><code class="language-bash">running 6 tests
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_word_too_large ... ok
test test_grid_new_with_word_only_caracter_shoudl_a_error ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_exact_word_size ... ok
test test_grid_new_with_one_size ... FAILED

failures:

---- test_grid_new_with_one_size stdout ----

thread 'test_grid_new_with_one_size' panicked at tests/test_grid.rs:33:14:
Expected InvalidGridSize error with value 1
</code></pre>
<p>Agora alterando nosso grid ele precisa ter valor maior que 1.</p>
<pre><code class="language-rust">    pub fn with_size(mut self, size: usize) -&gt; Result&lt;Self&gt; {
        if size &lt;= 1 {
            return Err(WordSearchError::InvalidGridSize(size));
        }
        self.size = Some(size);
        Ok(self)
    }
</code></pre>
<pre><code class="language-bash">running 6 tests
test test_grid_new_with_empty_words ... ok
test test_grid_new_with_one_size ... ok
test test_grid_new_with_exact_word_size ... ok
test test_grid_new_with_valid_parameters ... ok
test test_grid_new_with_word_only_caracter_shoudl_a_error ... ok
test test_grid_new_with_word_too_large ... ok
</code></pre>
<p>WIP - Conte√∫do em constru√ß√£o</p>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">November 21, 2025</span>
      
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.220ee61c.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>